<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HierBEM: include/hmatrix/hmatrix.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js", "TeX/AMScd.js.js"],
  jax: ["input/TeX","output/SVG"],
});
MathJax.Hub.Config({
  jax: ["input/TeX", "output/SVG"],
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js", "TeX/AMScd.js"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    skipTags: ["script","noscript","style","textarea","pre","code"],
    processEscapes: false,
    processEnvironments: true,
    preview: "TeX"
  },
  TeX: {
    Macros: {
      intd: "\\,{\\rm d}",
        diff: "{\\rm d}",
        Diff: "{\\rm D}",
        pdiff: "\\partial",
        DD: ["\\frac{\\diff}{\\diff #2}\\left( #1 \\right)", 2],
        Dd: ["\\frac{\\diff #1}{\\diff #2}", 2],
        PD: ["\\frac{\\pdiff}{\\pdiff #2}\\left( #1 \\right)", 2],
        Pd: ["\\frac{\\pdiff #1}{\\pdiff #2}", 2],
        rme: "{\\rm e}",
        rmi: "{\\rm i}",
        rmj: "{\\rm j}",
        vect: ["\\boldsymbol{#1}", 1],
        dform: ["\\overset{\\rightharpoonup}{\\boldsymbol{#1}}", 1],
        cochain: ["\\overset{\\rightharpoonup}{#1}", 1],
        bigabs: ["\\bigg\\lvert#1\\bigg\\rvert", 1],
        Abs: ["\\big\\lvert#1\\big\\rvert", 1],
        abs: ["\\lvert#1\\rvert", 1],
        bignorm: ["\\bigg\\lVert#1\\bigg\\rVert", 1],
        Norm: ["\\big\\lVert#1\\big\\rVert", 1],
        norm: ["\\lVert#1\\rVert", 1],
        normvect: "\\vect{n}",
        ouset: ["\\overset{#3}{\\underset{#2}{#1}}", 3],
        cscript: ["\\;\\; #1", 1],
        suchthat: "\\textit{S.T.\\;}",
        prefstar: "\\ast",
        restrict: "\\big\\vert",
        sgn: "{\\rm sgn}",
        erf: "{\\rm erf}",
        Bd: "{\\rm Bd}",
        Int: "{\\rm Int}",
        dim: "{\\rm dim}",
        rank: "{\\rm rank}",
        range: "{\\rm range}",
        divergence: "{\\rm div}",
        curl: "{\\rm curl}",
        grad: "{\\rm grad}",
        diag: "{\\rm diag}",
        tr: "{\\rm tr}",
        span: "{\\rm span}",
        lhs: "{\\rm LHS}",
        rhs: "{\\rm RHS}",
        argmin: "{\\rm argmin}",
        argmax: "{\\rm argmax}",
        esssup: "{\\rm ess sup}",
        essinf: "{\\rm ess inf}",
        kernel: "{\\rm ker}",
        image: "{\\rm Im}",
        diam: "{\\rm diam}"
    },
    equationNumbers: { autoNumber: "AMS" }
  },
  "HTML-CSS": {
     availableFonts: ["STIX","TeX"],
     preferredFont: "TeX",
     webFont: "TeX",
     imageFont: "TeX",
     showMathMenu: true
  },
  MMLorHTML: {
    prefer: {
      MSIE:    "MML",
      Firefox: "MML",
      Opera:   "HTML",
      other:   "HTML"
    }
  }
});
</script>
<script type="text/javascript" async="async" src="/js/MathJax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">HierBEM<span id="projectnumber">&#160;v1.0.0</span>
   </div>
   <div id="projectbrief">Hierarchical matrix based 3D Galerkin boundary element method (BEM) C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_73f6c25ff22e453adb4619599a10d18e.html">hmatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">hmatrix.h File Reference<div class="ingroups"><a class="el" href="group__hierarchical__matrices.html">Hierarchical matrices</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Definition of hierarchical matrix.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;deal.II/base/logstream.h&gt;</code><br />
<code>#include &lt;deal.II/base/numbers.h&gt;</code><br />
<code>#include &lt;deal.II/base/thread_management.h&gt;</code><br />
<code>#include &lt;deal.II/base/types.h&gt;</code><br />
<code>#include &lt;deal.II/lac/full_matrix.h&gt;</code><br />
<code>#include &lt;deal.II/lac/vector.h&gt;</code><br />
<code>#include &lt;openblas-pthread/cblas.h&gt;</code><br />
<code>#include &lt;tbb/tbb.h&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;mutex&gt;</code><br />
<code>#include &lt;queue&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="block__cluster_8h_source.html">cluster_tree/block_cluster.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="block__cluster__tree_8h_source.html">cluster_tree/block_cluster_tree.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="config_8h_source.html">config.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="hmatrix__support_8h_source.html">hmatrix/hmatrix_support.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="hmatrix__vmult__strategy_8h_source.html">hmatrix/hmatrix_vmult_strategy.h</a>&quot;</code><br />
<code>#include &quot;linear_algebra/lapack_full_matrix_ext.h&quot;</code><br />
<code>#include &quot;<a class="el" href="rkmatrix_8h_source.html">rkmatrix.h</a>&quot;</code><br />
<code>#include &quot;sequence_partition/sequence_partition.h&quot;</code><br />
<code>#include &quot;<a class="el" href="generic__functors_8h_source.html">utilities/generic_functors.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="number__traits_8h_source.html">utilities/number_traits.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for hmatrix.h:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="hmatrix_8h__incl.svg" width="7878" height="723"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="hmatrix_8h__dep__incl.svg" width="1766" height="707"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<p><a href="hmatrix_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html">HMatrix&lt; spacedim, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHMatrix_1_1VmultOrTvmultThreadData.html">HMatrix&lt; spacedim, Number &gt;::VmultOrTvmultThreadData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix_1_1UpdateTaskNodeForLUOrCholesky.html">HMatrix&lt; spacedim, Number &gt;::UpdateTaskNodeForLUOrCholesky</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac04719e202c88f36e4533fe1d326a494"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a> { <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>
, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>
, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>
, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>
 }</td></tr>
<tr class="separator:ac04719e202c88f36e4533fe1d326a494"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0fa1bc8ef65257338a3bdf368e9c7cc1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a0fa1bc8ef65257338a3bdf368e9c7cc1">DeclException1</a> (ExcInvalidHMatrixType, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a>,&lt;&lt; &quot;Invalid H-matrix node type: &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:a0fa1bc8ef65257338a3bdf368e9c7cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce884db40a4916de461a8cdf1a8a1f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a1ce884db40a4916de461a8cdf1a8a1f0">DeclException1</a> (ExcInvalidHMatrixState, <a class="el" href="hmatrix__support_8h.html#a8358c4882bca00f7e887d9b44e633aa0">HMatrixSupport::State</a>,&lt;&lt; &quot;Invalid H-matrix node state: &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:a1ce884db40a4916de461a8cdf1a8a1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7d59655d292be1ffea30d7cce8c7ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#acd7d59655d292be1ffea30d7cce8c7ad">DeclException1</a> (ExcInvalidHMatrixProperty, <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>,&lt;&lt; &quot;Invalid H-matrix node property: &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:acd7d59655d292be1ffea30d7cce8c7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3ece87ac4e1525057bfb682b0b9b24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#aeb3ece87ac4e1525057bfb682b0b9b24">DeclException1</a> (ExcInvalidHMatrixBlockType, <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>,&lt;&lt; &quot;Invalid H-matrix node block type: &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:aeb3ece87ac4e1525057bfb682b0b9b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb74a11c32d7078bdff06cd7b7487b5"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:aadb74a11c32d7078bdff06cd7b7487b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#aadb74a11c32d7078bdff06cd7b7487b5">InitHMatrixWrtBlockClusterNode</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type bc_node)</td></tr>
<tr class="separator:aadb74a11c32d7078bdff06cd7b7487b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dafc53598070d5dfaa3e9abb4eaf355"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a6dafc53598070d5dfaa3e9abb4eaf355"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a6dafc53598070d5dfaa3e9abb4eaf355">InitHMatrixWrtBlockClusterNode</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type bc_node, const std::vector&lt; std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &gt; &amp;Sigma_P)</td></tr>
<tr class="separator:a6dafc53598070d5dfaa3e9abb4eaf355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964e325e5cb3cd4048622e9687318520"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a964e325e5cb3cd4048622e9687318520"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a964e325e5cb3cd4048622e9687318520">InitHMatrixWrtBlockClusterNode</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type bc_node, const std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;hmat_pair)</td></tr>
<tr class="separator:a964e325e5cb3cd4048622e9687318520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb219ba2cfa0060bdd6d4155b884cfd"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:afeb219ba2cfa0060bdd6d4155b884cfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#afeb219ba2cfa0060bdd6d4155b884cfd">InitAndCreateHMatrixChildrenWithoutAlloc</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type bc_node)</td></tr>
<tr class="separator:afeb219ba2cfa0060bdd6d4155b884cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cc8ff50e421ec2bc9ce33a36d47968"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a81cc8ff50e421ec2bc9ce33a36d47968"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a81cc8ff50e421ec2bc9ce33a36d47968">InitAndCreateHMatrixChildren</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type bc_node, const unsigned int fixed_rank_k, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_node_property=HMatrixSupport::Property::general)</td></tr>
<tr class="separator:a81cc8ff50e421ec2bc9ce33a36d47968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad080fc1c19e1c9c323f5fae8a5704e57"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ad080fc1c19e1c9c323f5fae8a5704e57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ad080fc1c19e1c9c323f5fae8a5704e57">InitAndCreateHMatrixChildren</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type bc_node, const unsigned int fixed_rank_k, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_node_property=HMatrixSupport::Property::general)</td></tr>
<tr class="separator:ad080fc1c19e1c9c323f5fae8a5704e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0833d8503c82e9bea137e0145a61d31"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ac0833d8503c82e9bea137e0145a61d31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ac0833d8503c82e9bea137e0145a61d31">InitAndCreateHMatrixChildren</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type bc_node, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_node_property=HMatrixSupport::Property::general)</td></tr>
<tr class="separator:ac0833d8503c82e9bea137e0145a61d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a3904c1eb8b8b26dda1ecda3b2bcbe"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ad4a3904c1eb8b8b26dda1ecda3b2bcbe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ad4a3904c1eb8b8b26dda1ecda3b2bcbe">InitAndCreateHMatrixChildren</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type bc_node, const unsigned int fixed_rank_k, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, const std::array&lt; types::global_dof_index, 2 &gt; &amp;M_row_index_range, const std::array&lt; types::global_dof_index, 2 &gt; &amp;M_col_index_range, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_node_property=HMatrixSupport::Property::general)</td></tr>
<tr class="separator:ad4a3904c1eb8b8b26dda1ecda3b2bcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1543c003a94f46c954b2b2b56c83a940"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a1543c003a94f46c954b2b2b56c83a940"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a1543c003a94f46c954b2b2b56c83a940">InitAndCreateHMatrixChildren</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type bc_node, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, const std::array&lt; types::global_dof_index, 2 &gt; &amp;M_row_index_range, const std::array&lt; types::global_dof_index, 2 &gt; &amp;M_col_index_range, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_node_property=HMatrixSupport::Property::general)</td></tr>
<tr class="separator:a1543c003a94f46c954b2b2b56c83a940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ff73627a9480c63bd58514bd4ae598"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a75ff73627a9480c63bd58514bd4ae598"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a75ff73627a9480c63bd58514bd4ae598">InitAndCreateHMatrixChildren</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type bc_node, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;H)</td></tr>
<tr class="separator:a75ff73627a9480c63bd58514bd4ae598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090df12c1646d637bc390fa6dae55f24"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a090df12c1646d637bc390fa6dae55f24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *starting_hmat, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *current_hmat)</td></tr>
<tr class="separator:a090df12c1646d637bc390fa6dae55f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b0f4d71b52952d99ee7ecb0eb033cb"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a13b0f4d71b52952d99ee7ecb0eb033cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat_block, const unsigned int fixed_rank_k, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat_root_block=nullptr, size_t *calling_counter=nullptr, const std::string &amp;output_file_base_name=std::string(&quot;hmat-bct&quot;))</td></tr>
<tr class="separator:a13b0f4d71b52952d99ee7ecb0eb033cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee9050ba0b224929bcbf99484385a59"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:afee9050ba0b224929bcbf99484385a59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:afee9050ba0b224929bcbf99484385a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b93b5c19ef281408c6ed1e6460462e5"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a9b93b5c19ef281408c6ed1e6460462e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a9b93b5c19ef281408c6ed1e6460462e5">h_rk_mmult</a> (const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a9b93b5c19ef281408c6ed1e6460462e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0d61778a104b7e1452c3b9be60b5e4"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a4d0d61778a104b7e1452c3b9be60b5e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a4d0d61778a104b7e1452c3b9be60b5e4">h_rk_mTmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a4d0d61778a104b7e1452c3b9be60b5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbe51ba1fe5ea83d5910d1f893d589f"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:acfbe51ba1fe5ea83d5910d1f893d589f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#acfbe51ba1fe5ea83d5910d1f893d589f">h_rk_mTmult</a> (const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:acfbe51ba1fe5ea83d5910d1f893d589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b37e59459e75613a9e95f72757b8e1e"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a2b37e59459e75613a9e95f72757b8e1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a2b37e59459e75613a9e95f72757b8e1e">h_rk_Tmmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a2b37e59459e75613a9e95f72757b8e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a0160d0d1e6afa4f14892c4560e058"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a29a0160d0d1e6afa4f14892c4560e058"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a29a0160d0d1e6afa4f14892c4560e058">h_rk_Tmmult</a> (const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a29a0160d0d1e6afa4f14892c4560e058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84df06910d958d84ac8c544f9a8423a8"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a84df06910d958d84ac8c544f9a8423a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M, bool is_M1M2_last_in_M_Sigma_P=true)</td></tr>
<tr class="separator:a84df06910d958d84ac8c544f9a8423a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d344d3d2c8db0c93690bf7cbd4a4459"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a5d344d3d2c8db0c93690bf7cbd4a4459"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult</a> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a5d344d3d2c8db0c93690bf7cbd4a4459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e90e9592ce3d05bdea99a9b93d7606"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:af5e90e9592ce3d05bdea99a9b93d7606"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#af5e90e9592ce3d05bdea99a9b93d7606">rk_h_mmult</a> (const Number alpha, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:af5e90e9592ce3d05bdea99a9b93d7606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca19ab9519b7b1aa1b9660dbfa8fe604"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:aca19ab9519b7b1aa1b9660dbfa8fe604"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#aca19ab9519b7b1aa1b9660dbfa8fe604">rk_h_mTmult</a> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:aca19ab9519b7b1aa1b9660dbfa8fe604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2eac81199c6e3cdf57242dfae682841"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ab2eac81199c6e3cdf57242dfae682841"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ab2eac81199c6e3cdf57242dfae682841">rk_h_mTmult</a> (const Number alpha, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:ab2eac81199c6e3cdf57242dfae682841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d013f955b2d54b23231f9d4947662fe"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a6d013f955b2d54b23231f9d4947662fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a6d013f955b2d54b23231f9d4947662fe">rk_h_Tmmult</a> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a6d013f955b2d54b23231f9d4947662fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dedeab2f1f9c6e12ee04325863f07d"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a96dedeab2f1f9c6e12ee04325863f07d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a96dedeab2f1f9c6e12ee04325863f07d">rk_h_Tmmult</a> (const Number alpha, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a96dedeab2f1f9c6e12ee04325863f07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43aef4fd52ce71103baa047f549293c6"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a43aef4fd52ce71103baa047f549293c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M, bool is_M1M2_last_in_M_Sigma_P=true)</td></tr>
<tr class="separator:a43aef4fd52ce71103baa047f549293c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae495fd6b480f203cf797e7e86e996313"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ae495fd6b480f203cf797e7e86e996313"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:ae495fd6b480f203cf797e7e86e996313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb4579cb7d6a65805c548aa9c3f97b9"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:aceb4579cb7d6a65805c548aa9c3f97b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#aceb4579cb7d6a65805c548aa9c3f97b9">h_f_mmult</a> (const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:aceb4579cb7d6a65805c548aa9c3f97b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5bc5080b3c7e065e70fdba10faae55"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a8c5bc5080b3c7e065e70fdba10faae55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a8c5bc5080b3c7e065e70fdba10faae55">h_f_mTmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a8c5bc5080b3c7e065e70fdba10faae55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2ffe1ccde0ac2a90b63cfdd92a5235"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a3a2ffe1ccde0ac2a90b63cfdd92a5235"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a3a2ffe1ccde0ac2a90b63cfdd92a5235">h_f_mTmult</a> (const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a3a2ffe1ccde0ac2a90b63cfdd92a5235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d6d9989cc78f7fffa8c1e890512652"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a85d6d9989cc78f7fffa8c1e890512652"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a85d6d9989cc78f7fffa8c1e890512652">h_f_Tmmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a85d6d9989cc78f7fffa8c1e890512652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e12950b1f7f97350d7268f49ff8d420"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a5e12950b1f7f97350d7268f49ff8d420"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a5e12950b1f7f97350d7268f49ff8d420">h_f_Tmmult</a> (const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a5e12950b1f7f97350d7268f49ff8d420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723281b6cf62859890ec5ee49555c908"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a723281b6cf62859890ec5ee49555c908"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a723281b6cf62859890ec5ee49555c908">h_f_mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a723281b6cf62859890ec5ee49555c908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398869486c36312aefc9c22f395fc494"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a398869486c36312aefc9c22f395fc494"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a398869486c36312aefc9c22f395fc494">h_f_mmult</a> (const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a398869486c36312aefc9c22f395fc494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f0b303f7933e220bb976db96536ef9"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ac9f0b303f7933e220bb976db96536ef9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ac9f0b303f7933e220bb976db96536ef9">h_f_mTmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:ac9f0b303f7933e220bb976db96536ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4df594f8278dbd00a4d098f6e591f68"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ab4df594f8278dbd00a4d098f6e591f68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ab4df594f8278dbd00a4d098f6e591f68">h_f_mTmult</a> (const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:ab4df594f8278dbd00a4d098f6e591f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240be067972358dc350a79879eeb4c04"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a240be067972358dc350a79879eeb4c04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a240be067972358dc350a79879eeb4c04">h_f_Tmmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a240be067972358dc350a79879eeb4c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c1a545280989e74a77ae9133ca8a2c"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a21c1a545280989e74a77ae9133ca8a2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a21c1a545280989e74a77ae9133ca8a2c">h_f_Tmmult</a> (const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a21c1a545280989e74a77ae9133ca8a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374070dba133f2152e9c44ce10947f20"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a374070dba133f2152e9c44ce10947f20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M, bool is_M1M2_last_in_M_Sigma_P=true)</td></tr>
<tr class="separator:a374070dba133f2152e9c44ce10947f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b25e6262a25b27f374cab704407437"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a37b25e6262a25b27f374cab704407437"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult</a> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a37b25e6262a25b27f374cab704407437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a2ebfa11a73c83d768089617e308d8"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a34a2ebfa11a73c83d768089617e308d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a34a2ebfa11a73c83d768089617e308d8">f_h_mmult</a> (const Number alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a34a2ebfa11a73c83d768089617e308d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf140473681cc5ea3ab57fafdc986357"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:acf140473681cc5ea3ab57fafdc986357"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#acf140473681cc5ea3ab57fafdc986357">f_h_mTmult</a> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:acf140473681cc5ea3ab57fafdc986357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9fbb4b9a0e5e87096e8d8f833cbb76"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a8d9fbb4b9a0e5e87096e8d8f833cbb76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a8d9fbb4b9a0e5e87096e8d8f833cbb76">f_h_mTmult</a> (const Number alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a8d9fbb4b9a0e5e87096e8d8f833cbb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216aa00790edb8b8818a42eeab1c24f2"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a216aa00790edb8b8818a42eeab1c24f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a216aa00790edb8b8818a42eeab1c24f2">f_h_Tmmult</a> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a216aa00790edb8b8818a42eeab1c24f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb2efa78e5e8edd5a6c78bb13f99f72"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:aebb2efa78e5e8edd5a6c78bb13f99f72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#aebb2efa78e5e8edd5a6c78bb13f99f72">f_h_Tmmult</a> (const Number alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:aebb2efa78e5e8edd5a6c78bb13f99f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2138cf7f25917862b5353a6ceee9ea11"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a2138cf7f25917862b5353a6ceee9ea11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a2138cf7f25917862b5353a6ceee9ea11">f_h_mmult</a> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a2138cf7f25917862b5353a6ceee9ea11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951849a7b68e93f385c9e1fa0c4c251d"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a951849a7b68e93f385c9e1fa0c4c251d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a951849a7b68e93f385c9e1fa0c4c251d">f_h_mmult</a> (const Number alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a951849a7b68e93f385c9e1fa0c4c251d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942dd3cabbf54bd4e6bc5a922746b257"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a942dd3cabbf54bd4e6bc5a922746b257"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a942dd3cabbf54bd4e6bc5a922746b257">f_h_mTmult</a> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a942dd3cabbf54bd4e6bc5a922746b257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e6b54a178a7a0149f5ad6336e4e49c"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ae7e6b54a178a7a0149f5ad6336e4e49c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ae7e6b54a178a7a0149f5ad6336e4e49c">f_h_mTmult</a> (const Number alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:ae7e6b54a178a7a0149f5ad6336e4e49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f5fc097442bf1e9a1d54ca808ff700"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ae9f5fc097442bf1e9a1d54ca808ff700"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ae9f5fc097442bf1e9a1d54ca808ff700">f_h_Tmmult</a> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:ae9f5fc097442bf1e9a1d54ca808ff700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99210aa3242f85b43381b4ef49488e45"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a99210aa3242f85b43381b4ef49488e45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a99210aa3242f85b43381b4ef49488e45">f_h_Tmmult</a> (const Number alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a99210aa3242f85b43381b4ef49488e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242e7e3da010e972783e20326ae15a36"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a242e7e3da010e972783e20326ae15a36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M, bool is_M1M2_last_in_M_Sigma_P=true)</td></tr>
<tr class="separator:a242e7e3da010e972783e20326ae15a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade843f2c14289e1be70ff93679e8db15"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ade843f2c14289e1be70ff93679e8db15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ade843f2c14289e1be70ff93679e8db15">h_h_mmult_phase1_recursion</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt; &amp;Tind)</td></tr>
<tr class="separator:ade843f2c14289e1be70ff93679e8db15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0184540d75eabf04c9a409318a4565"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a3c0184540d75eabf04c9a409318a4565"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a3c0184540d75eabf04c9a409318a4565">h_h_mmult_phase2</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt; &amp;target_bc_tree, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a3c0184540d75eabf04c9a409318a4565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4d0483375618fed513fe9a9ca73dc6"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a0e4d0483375618fed513fe9a9ca73dc6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a0e4d0483375618fed513fe9a9ca73dc6">h_h_mmult_from_leaf_node</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> block_type_for_local_Z, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a0e4d0483375618fed513fe9a9ca73dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1a5fe7054002f55672d5ea81c3ac9c"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a4b1a5fe7054002f55672d5ea81c3ac9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a4b1a5fe7054002f55672d5ea81c3ac9c">h_h_mmult_from_leaf_node</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> block_type_for_local_Z, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a4b1a5fe7054002f55672d5ea81c3ac9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c51d3d90b5800a92b0679a2ac0b64ad"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a5c51d3d90b5800a92b0679a2ac0b64ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a5c51d3d90b5800a92b0679a2ac0b64ad">h_h_mmult_from_leaf_node_for_parallel_lu</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> block_type_for_local_Z, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a5c51d3d90b5800a92b0679a2ac0b64ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508e9db2e74ed9eaaa6f059ab87abeaa"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a508e9db2e74ed9eaaa6f059ab87abeaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a508e9db2e74ed9eaaa6f059ab87abeaa">h_h_mTmult_from_leaf_node</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> block_type_for_local_Z, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a508e9db2e74ed9eaaa6f059ab87abeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7573d10748a80abe2d6b969dc60788b5"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a7573d10748a80abe2d6b969dc60788b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a7573d10748a80abe2d6b969dc60788b5">h_h_mTmult_from_leaf_node</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> block_type_for_local_Z, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a7573d10748a80abe2d6b969dc60788b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca3547834f0e768bec39d63b7ab4288"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:acca3547834f0e768bec39d63b7ab4288"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#acca3547834f0e768bec39d63b7ab4288">h_h_mTmult_from_leaf_node_for_parallel_cholesky</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> block_type_for_local_Z, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:acca3547834f0e768bec39d63b7ab4288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b305bbf2fe7e513d4b06cff7b62874"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a15b305bbf2fe7e513d4b06cff7b62874"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a15b305bbf2fe7e513d4b06cff7b62874">h_h_Tmmult_from_leaf_node</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> block_type_for_local_Z, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a15b305bbf2fe7e513d4b06cff7b62874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e7f24d7d111a0e2257637604c4a9f3"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:ac4e7f24d7d111a0e2257637604c4a9f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ac4e7f24d7d111a0e2257637604c4a9f3">h_h_Tmmult_from_leaf_node</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> block_type_for_local_Z, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:ac4e7f24d7d111a0e2257637604c4a9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63f1a7be7435625f9d78f7d0cedfa38"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:af63f1a7be7435625f9d78f7d0cedfa38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#af63f1a7be7435625f9d78f7d0cedfa38">h_h_mmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:af63f1a7be7435625f9d78f7d0cedfa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c53846a0495ef6c79e154f1417b808"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a53c53846a0495ef6c79e154f1417b808"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a53c53846a0495ef6c79e154f1417b808">h_h_mmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a53c53846a0495ef6c79e154f1417b808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cebba380fc26680f8522816f78fd56"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:ac6cebba380fc26680f8522816f78fd56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ac6cebba380fc26680f8522816f78fd56">h_h_mmult_level_conserving_for_parallel_lu</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:ac6cebba380fc26680f8522816f78fd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480850d2b01f92d11d894a7930aed6fa"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a480850d2b01f92d11d894a7930aed6fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a480850d2b01f92d11d894a7930aed6fa">h_h_mTmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a480850d2b01f92d11d894a7930aed6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77204bf34aa9fc49787f01cc03c33696"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a77204bf34aa9fc49787f01cc03c33696"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a77204bf34aa9fc49787f01cc03c33696">h_h_mTmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a77204bf34aa9fc49787f01cc03c33696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8564c63e3c1e297183b945a9f9007429"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a8564c63e3c1e297183b945a9f9007429"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a8564c63e3c1e297183b945a9f9007429">h_h_mTmult_level_conserving_for_parallel_cholesky</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a8564c63e3c1e297183b945a9f9007429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59c59f9ec468f5fd3e122226080f7e4"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:aa59c59f9ec468f5fd3e122226080f7e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#aa59c59f9ec468f5fd3e122226080f7e4">h_h_Tmmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:aa59c59f9ec468f5fd3e122226080f7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2f95b99f9cad38f0648b612c724da8"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a7a2f95b99f9cad38f0648b612c724da8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a7a2f95b99f9cad38f0648b612c724da8">h_h_Tmmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a7a2f95b99f9cad38f0648b612c724da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eeb0a11d6f43231a21267b2b45fefb2"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a1eeb0a11d6f43231a21267b2b45fefb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat_dst, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat_src)</td></tr>
<tr class="separator:a1eeb0a11d6f43231a21267b2b45fefb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e61ba5438c4cf0337664ec4b8562873"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a3e61ba5438c4cf0337664ec4b8562873"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a3e61ba5438c4cf0337664ec4b8562873">copy_hmatrix_node</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat_dst, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;hmat_src)</td></tr>
<tr class="separator:a3e61ba5438c4cf0337664ec4b8562873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b3e4f5b78b4b6a9885325225eba0a1"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:af4b3e4f5b78b4b6a9885325225eba0a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#af4b3e4f5b78b4b6a9885325225eba0a1">copy_hmatrix</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat_dst, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat_src)</td></tr>
<tr class="separator:af4b3e4f5b78b4b6a9885325225eba0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb67e27b0623d39d9b974fe43b56c349"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:abb67e27b0623d39d9b974fe43b56c349"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#abb67e27b0623d39d9b974fe43b56c349">print_h_submatrix_accessor</a> (std::ostream &amp;out, const std::string &amp;name, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M)</td></tr>
<tr class="separator:abb67e27b0623d39d9b974fe43b56c349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a2429426558ca0d6982f97b3669bf3"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a78a2429426558ca0d6982f97b3669bf3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a78a2429426558ca0d6982f97b3669bf3">print_h_h_submatrix_mmult_accessor</a> (std::ostream &amp;out, const std::string &amp;name1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const std::string &amp;name2, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2)</td></tr>
<tr class="separator:a78a2429426558ca0d6982f97b3669bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b34ad37e3ad46b0fc514ad4a428e18"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a88b34ad37e3ad46b0fc514ad4a428e18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a88b34ad37e3ad46b0fc514ad4a428e18">hmatrix_solve_lu</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;L, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;U, Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b)</td></tr>
<tr class="separator:a88b34ad37e3ad46b0fc514ad4a428e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d08a58ab3946a4c2912f3b0af531f7"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:aa4d08a58ab3946a4c2912f3b0af531f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#aa4d08a58ab3946a4c2912f3b0af531f7">hmatrix_solve_cholesky</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;L, Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b)</td></tr>
<tr class="separator:aa4d08a58ab3946a4c2912f3b0af531f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Definition of hierarchical matrix. </p>
<dl class="section date"><dt>Date</dt><dd>2021-06-06 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jihuan Tian </dd></dl>

<p class="definition">Definition in file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac04719e202c88f36e4533fe1d326a494" name="ac04719e202c88f36e4533fe1d326a494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04719e202c88f36e4533fe1d326a494">&#9670;&nbsp;</a></span>HMatrixType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Matrix type of an HMaxtrix, which can be full matrix in the near field, rank-k matrix in the far field and hierarchical matrix which does not belong to the leaf set of a block cluster tree. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924" name="ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924"></a>FullMatrixType&#160;</td><td class="fielddoc"><p >FullMatrixType. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c" name="ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c"></a>RkMatrixType&#160;</td><td class="fielddoc"><p >RkMatrixType. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d" name="ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d"></a>HierarchicalMatrixType&#160;</td><td class="fielddoc"><p >HierarchicalType. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7" name="ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7"></a>UndefinedMatrixType&#160;</td><td class="fielddoc"><p >UndefinedMatrixType. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l00065">65</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a13b0f4d71b52952d99ee7ecb0eb033cb" name="a13b0f4d71b52952d99ee7ecb0eb033cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b0f4d71b52952d99ee7ecb0eb033cb">&#9670;&nbsp;</a></span>convertHMatBlockToRkMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void convertHMatBlockToRkMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat_root_block</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>calling_counter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_file_base_name</em> = <code>std::string(&quot;hmat-bct&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Convert an \(\mathcal{H}\)-matrix block <code>hmat_block</code> recursively into a rank-k matrix or a full matrix, which depends on whether the block cluster associated with <code>hmat_block</code> is large or not.</p>
<p >Generally speaking, this method can be considered as the agglomeration of all descendants of <code>hmat_block</code>.</p>
<dl class="section note">
<dt>Note </dt>
<dd>This method implements the operator \(\mathcal{T}_r^{\mathcal{R}
\leftarrow \mathcal{H}}\), i.e. the algorithm \(Convert\_H\) in (7.8) in Hackbusch's \(\mathcal{H}\)-matrix book. </dd>
</dl>
<p >This \(\mathcal{H}\)-matrix block is implemented as a node in a whole \(\mathcal{H}\)-matrix hierarchy. This conversion algorithm will recursively descend in the hierarchical matrices for processing:</p>
<ol type="1">
<li>when the current matrix block belongs to the near field set \(P^-\), it is represented as a full matrix and no operations will be applied to it;</li>
<li>when it belongs to the far field set \(P^+\), it is already a rank-k matrix, which will then be truncated to the given <code>fixed_rank_k</code>;</li>
<li><p class="startli">when it is not a leaf, i.e. it is a hierarchical matrix, this function will be called recursively for each of its children. After that,</p>
<p class="startli">a. if the block cluster related to the current matrix is large, pairwise agglomeration for rank-k matrices will be performed and a rank-k matrix will be obtained with the given rank <code>fixed_rank_k</code>;</p>
<p class="startli">b. if the block cluster related to the current matrix is small, agglomeration of full matrices will be performed and a full matrix will be obtained.</p>
</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat_block</td><td>the pointer to the current matrix block from which the recursion will start. </td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td>the fixed rank to which the rank-k matrices in the far field set will be truncated. </td></tr>
    <tr><td class="paramname">hmat_root_block</td><td>the pointer to the root \(\mathcal{H}\)-matrix block, which is only used for exporting matrix partition structure for further visualization. </td></tr>
    <tr><td class="paramname">calling_counter</td><td>the pointer to the counter which records the current total number of calling times of this function. Its value will be used to construct the name of the output file, which stores the matrix partition structure. </td></tr>
    <tr><td class="paramname">output_file_base_name</td><td>the based name of the output file which stores the matrix partition structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section">
<dt>Work flow </dt>
<dd><p class="startdd"></p>
<p class="interdd">When the current \(\mathcal{H}\)-matrix block belongs to the leaf set.</p>
<p class="interdd">When the current \(\mathcal{H}\)-matrix belongs to the near field set, it should be of a full matrix type. Therefore, we make an assertion here. After that we do nothing, since a near field node should always be represented as a full matrix, thus the rank truncation should not be applied.</p>
<p class="interdd">When the current \(\mathcal{H}\)-matrix belongs to the far field set, it should be of a rank-k matrix type. Therefore, we make an assertion here. After that the rank-k matrix block is truncated to the specified rank.</p>
<p class="interdd">When the current \(\mathcal{H}\)-matrix block does not belong to the leaf set, recursively convert each child of it to rank-k matrix if possible.</p>
<p class="interdd">When the current \(\mathcal{H}\)-matrix block belongs to the near field set, we perform the operation of full matrix agglomeration.</p>
<dl class="section note">
<dt>Note </dt>
<dd><p class="startdd">Normally, this case cannot happen because when an \(\mathcal{H}\)-matrix block belongs to the near field, it is represented as a full matrix and belongs to the leaf set. However, this contradicts the precondition that the current \(\mathcal{H}\)-matrix block does not belong to the leaf set.</p>
<p class="enddd">But still this situation may happen during the conversion of an \(\mathcal{H}\)-matrix to a different block cluster tree. </p>
</dd>
</dl>
<p class="interdd"><b>The general work flow for the agglomeration of a set of full matrix blocks is as below.</b></p>
<ol type="1">
<li><p class="startli">Create a large full matrix on the heap and assemble all submatrices into it which depends on the split mode of the block cluster.</p>
<p class="startli">a. When it is <code>CrossSplitMode</code>, apply agglomeration of four full submatrices.</p>
<p class="startli">b. When the split mode is <code>HorizontalSplitMode</code>, apply agglomeration of two full submatrices via vertical stacking.</p>
<p class="startli">c. When the split mode is <code>VerticalSplitMode</code>, apply agglomeration of two full submatrices via horizontal stacking.</p>
</li>
<li>Delete all submatrices associated with the current \(\mathcal{H}\)-matrix and clear the <code>std::vector</code> storing submatrix pointers.</li>
<li>Associate the new large full matrix with the current \(\mathcal{H}\)-matrix.</li>
<li>Update the \(\mathcal{H}\)-matrix type as <code>FullMatrix</code>.</li>
</ol>
<p class="interdd"><b>About matrix assembly for <code>CrossSplitMode</b></code> </p>
<p class="interdd">Let the block cluster associated with the current \(\mathcal{H}\)-matrix is \(\tau \times \sigma\). Assume the clusters are partitioned as \(\tau = [\tau_1, \tau_2]\) and \(\sigma =
[\sigma_1, \sigma_2]\). Then the ordering of the child block clusters are \(\tau_1 \times \sigma_1, \tau_1 \times \sigma_2,
\tau_2 \times \sigma_1, \tau_2 \times \sigma_2\).</p>
<p class="interdd">When the current \(\mathcal{H}\)-matrix block belongs to the far field set, perform the pairwise matrix agglomeration of rank-k submatrices or full submatrices, which has been implemented into the constructor of <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>.</p>
<p class="interdd">If the children of the current \(\mathcal{H}\)-matrix block are rank-k matrices, perform the pairwise rank-k matrix agglomeration directly.</p>
<p class="interdd">If the children of the current \(\mathcal{H}\)-matrix block are full matrices, firstly convert all of them into rank-k matrices, then perform the pairwise rank-k matrix agglomeration.</p>
<p class="interdd">Other cases are invalid.</p>
<p class="interdd">If the children of the current \(\mathcal{H}\)-matrix block are rank-k matrices, perform the pairwise rank-k matrix agglomeration directly.</p>
<p class="interdd">If the children of the current \(\mathcal{H}\)-matrix block are full matrices, firstly convert all of them into rank-k matrices, then perform the pairwise rank-k matrix agglomeration.</p>
<p class="interdd">Other cases are invalid.</p>
<p class="interdd">If the children of the current \(\mathcal{H}\)-matrix block are rank-k matrices, perform the pairwise rank-k matrix agglomeration directly.</p>
<p class="interdd">If the children of the current \(\mathcal{H}\)-matrix block are full matrices, firstly convert all of them into rank-k matrices, then perform the pairwise rank-k matrix agglomeration.</p>
<p class="interdd">Other cases are invalid.</p>
<p class="interdd">Visualize the partition structure if a not-null pointer to the root \(\mathcal{H}\)-matrix node and a a not-null pointer to a <code>calling_counter</code> are provided.</p>
<p class="enddd"></p>
</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l10017">10017</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l10017">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h_source.html#l00070">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l35624">HMatrix&lt; spacedim, Number &gt;::coarsen_to_partition()</a>, and <a class="el" href="hmatrix_8h_source.html#l10017">convertHMatBlockToRkMatrix()</a>.</p>

</div>
</div>
<a id="af4b3e4f5b78b4b6a9885325225eba0a1" name="af4b3e4f5b78b4b6a9885325225eba0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b3e4f5b78b4b6a9885325225eba0a1">&#9670;&nbsp;</a></span>copy_hmatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void copy_hmatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Recursively copy an \(\mathcal{H}\)-matrix into the target matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M_dst</td><td></td></tr>
    <tr><td class="paramname">M_src</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Copy the current \(\mathcal{H}\)-matrix node.</p>
<p >Recursively copy child \(\mathcal{H}\)-matrix nodes.</p>
<p >Create a corresponding child \(\mathcal{H}\)-matrix node on the heap and push it back into the <code>submatrices</code> list of the current \(\mathcal{H}\)-matrix node.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17518">17518</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l17518">copy_hmatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l17421">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l04289">HMatrix&lt; spacedim, Number &gt;::parent</a>, and <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17518">copy_hmatrix()</a>, and <a class="el" href="hmatrix_8h_source.html#l18140">HMatrix&lt; spacedim, Number &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a1eeb0a11d6f43231a21267b2b45fefb2" name="a1eeb0a11d6f43231a21267b2b45fefb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eeb0a11d6f43231a21267b2b45fefb2">&#9670;&nbsp;</a></span>copy_hmatrix_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void copy_hmatrix_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Deep copy an \(\mathcal{H}\)-matrix node into the target node, i.e. the copy is limited within the current node without recursion into its descendants. This function will be called by <code>copy_hmatrix</code>.</p>
<dl class="section note">
<dt>Note</dt>
<dd>1. Do not copy the list <code>submatrices</code> from the source submatrix, because newly created child matrices will be pushed back into this list.<ol type="1">
<li>Do not copy the list <code>leaf_set</code>. After the whole \(\mathcal{H}\)-matrix hierarchy has been constructed, the leaf set will be built in the constructor.</li>
<li>Do not copy the working data: <code>Sigma_P</code>, <code>Sigma_F</code>, <code>Sigma_R</code> and <code>Tind</code>.</li>
<li>Do not copy <code>parent</code> and it will be set during the recursive deep copy of the \(\mathcal{H}\)-matrix.</li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat_dst</td><td></td></tr>
    <tr><td class="paramname">hmat_src</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Copy the rank-k matrix in the source submatrix if it is not <code>NULL</code>.</p>
<p >Copy the full matrix in the source submatrix if it is not <code>NULL</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17421">17421</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l04263">HMatrix&lt; spacedim, Number &gt;::property</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04257">HMatrix&lt; spacedim, Number &gt;::state</a>, <a class="el" href="hmatrix_8h_source.html#l04323">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17518">copy_hmatrix()</a>, and <a class="el" href="hmatrix_8h_source.html#l18095">HMatrix&lt; spacedim, Number &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a3e61ba5438c4cf0337664ec4b8562873" name="a3e61ba5438c4cf0337664ec4b8562873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e61ba5438c4cf0337664ec4b8562873">&#9670;&nbsp;</a></span>copy_hmatrix_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void copy_hmatrix_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>hmat_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Shallow copy an \(\mathcal{H}\)-matrix node into the target node, i.e. the copy is limited within the current node without recursion into its descendants. Or rather, we can say the destination \(\mathcal{H}\)-matrix takes over the data from the source \(\mathcal{H}\)-matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat_dst</td><td></td></tr>
    <tr><td class="paramname">hmat_src</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17474">17474</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04279">HMatrix&lt; spacedim, Number &gt;::dot_node_id</a>, <a class="el" href="hmatrix_8h_source.html#l04338">HMatrix&lt; spacedim, Number &gt;::far_field_leaf_set</a>, <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l04328">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l04333">HMatrix&lt; spacedim, Number &gt;::near_field_leaf_set</a>, <a class="el" href="hmatrix_8h_source.html#l04294">HMatrix&lt; spacedim, Number &gt;::next_same_level_hmat_node</a>, <a class="el" href="hmatrix_8h_source.html#l04306">HMatrix&lt; spacedim, Number &gt;::next_same_level_same_column_hmat_node</a>, <a class="el" href="hmatrix_8h_source.html#l04300">HMatrix&lt; spacedim, Number &gt;::next_same_level_same_row_hmat_node</a>, <a class="el" href="hmatrix_8h_source.html#l04289">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="hmatrix_8h_source.html#l04318">HMatrix&lt; spacedim, Number &gt;::previous_same_level_same_column_hmat_node</a>, <a class="el" href="hmatrix_8h_source.html#l04312">HMatrix&lt; spacedim, Number &gt;::previous_same_level_same_row_hmat_node</a>, <a class="el" href="hmatrix_8h_source.html#l04263">HMatrix&lt; spacedim, Number &gt;::property</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04403">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="hmatrix_8h_source.html#l04391">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="hmatrix_8h_source.html#l04397">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, <a class="el" href="hmatrix_8h_source.html#l04257">HMatrix&lt; spacedim, Number &gt;::state</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="hmatrix_8h_source.html#l04323">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, <a class="el" href="hmatrix_8h_source.html#l04383">HMatrix&lt; spacedim, Number &gt;::Tind</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="aeb3ece87ac4e1525057bfb682b0b9b24" name="aeb3ece87ac4e1525057bfb682b0b9b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3ece87ac4e1525057bfb682b0b9b24">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidHMatrixBlockType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Invalid H-matrix node block type: &quot;&lt;&lt;&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Exception for invalid \(\mathcal{H}\)-matrix node block type (<code>HMatrixSupport::BlockType</code>). </p>

</div>
</div>
<a id="acd7d59655d292be1ffea30d7cce8c7ad" name="acd7d59655d292be1ffea30d7cce8c7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7d59655d292be1ffea30d7cce8c7ad">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidHMatrixProperty&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Invalid H-matrix node property: &quot;&lt;&lt;&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Exception for invalid \(\mathcal{H}\)-matrix node property (<code>HMatrixSupport::Property</code>). </p>

</div>
</div>
<a id="a1ce884db40a4916de461a8cdf1a8a1f0" name="a1ce884db40a4916de461a8cdf1a8a1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce884db40a4916de461a8cdf1a8a1f0">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidHMatrixState&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="hmatrix__support_8h.html#a8358c4882bca00f7e887d9b44e633aa0">HMatrixSupport::State</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Invalid H-matrix node state: &quot;&lt;&lt;&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Exception for invalid \(\mathcal{H}\)-matrix node state (<code>HMatrixSupport:State</code>). </p>

</div>
</div>
<a id="a0fa1bc8ef65257338a3bdf368e9c7cc1" name="a0fa1bc8ef65257338a3bdf368e9c7cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa1bc8ef65257338a3bdf368e9c7cc1">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidHMatrixType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Invalid H-matrix node type: &quot;&lt;&lt;&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Exception for invalid \(\mathcal{H}\)-matrix node type (<code>HMatrixType</code>). </p>

</div>
</div>
<a id="a37b25e6262a25b27f374cab704407437" name="a37b25e6262a25b27f374cab704407437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b25e6262a25b27f374cab704407437">&#9670;&nbsp;</a></span>f_h_mmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of a full matrix and a \(\mathcal{H}\)-matrix. A full matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11964">11964</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="lapack__full__matrix__ext_8h_source.html#l04563">LAPACKFullMatrixExt&lt; Number &gt;::fill_row()</a>, <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l02940">LAPACKFullMatrixExt&lt; Number &gt;::get_row()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, and <a class="el" href="hmatrix_8h_source.html#l23665">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l12342">f_h_mmult_for_h_h_mmult()</a>, and <a class="el" href="hmatrix_8h_source.html#l16039">h_h_mmult_level_conserving()</a>.</p>

</div>
</div>
<a id="a2138cf7f25917862b5353a6ceee9ea11" name="a2138cf7f25917862b5353a6ceee9ea11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2138cf7f25917862b5353a6ceee9ea11">&#9670;&nbsp;</a></span>f_h_mmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of a full matrix and a \(\mathcal{H}\)-matrix. A rank-k matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p ><b>The creation of the rank-k matrix <code>M1_rk</code> from <code>M1</code> will modify <code>M1</code> internally. Hence, we make a copy of <code>M1</code> here.</b></p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l12175">12175</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, and <a class="el" href="hmatrix_8h_source.html#l10959">rk_h_mmult()</a>.</p>

</div>
</div>
<a id="a34a2ebfa11a73c83d768089617e308d8" name="a34a2ebfa11a73c83d768089617e308d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a2ebfa11a73c83d768089617e308d8">&#9670;&nbsp;</a></span>f_h_mmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of a full matrix and a \(\mathcal{H}\)-matrix and the result is scaled by a factor. A full matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p ><b>Since the following <code>Tvmult</code> will compute \(y = y + M^T x\), <code>result_vect</code> should be reset to zero beforehand.</b></p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11999">11999</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a951849a7b68e93f385c9e1fa0c4c251d" name="a951849a7b68e93f385c9e1fa0c4c251d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951849a7b68e93f385c9e1fa0c4c251d">&#9670;&nbsp;</a></span>f_h_mmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of a full matrix and a \(\mathcal{H}\)-matrix and the result is scaled by a factor. A rank-k matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p ><b>The creation of the rank-k matrix <code>M1_rk</code> from <code>M1</code> will modify <code>M1</code> internally. Hence, we make a copy of <code>M1</code> here.</b></p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l12203">12203</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a242e7e3da010e972783e20326ae15a36" name="a242e7e3da010e972783e20326ae15a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242e7e3da010e972783e20326ae15a36">&#9670;&nbsp;</a></span>f_h_mmult_for_h_h_mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mmult_for_h_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_M1M2_last_in_M_Sigma_P</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of two \(\mathcal{H}\)-matrices, where the first one is of <code>FullMatrixType</code>. An \(\mathcal{H}\)-matrix is returned in <code>M</code>, which is either of <code>FullMatrixType</code> or <code>RkMatrixType</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">is_M1M2_last_in_M_Sigma_P</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Full matrix is returned.</p>
<p >Rank-k matrix is returned.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l12342">12342</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l11964">f_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l36264">HMatrix&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list()</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04403">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="hmatrix_8h_source.html#l04391">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="hmatrix_8h_source.html#l04397">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l28729">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_reduction()</a>.</p>

</div>
</div>
<a id="acf140473681cc5ea3ab57fafdc986357" name="acf140473681cc5ea3ab57fafdc986357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf140473681cc5ea3ab57fafdc986357">&#9670;&nbsp;</a></span>f_h_mTmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mTmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of a full matrix and a \(\mathcal{H}\)-matrix with the second operand being transposed. A full matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l12038">12038</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="lapack__full__matrix__ext_8h_source.html#l04563">LAPACKFullMatrixExt&lt; Number &gt;::fill_row()</a>, <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l02940">LAPACKFullMatrixExt&lt; Number &gt;::get_row()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, and <a class="el" href="hmatrix_8h_source.html#l21052">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l16558">h_h_mTmult_level_conserving()</a>.</p>

</div>
</div>
<a id="a942dd3cabbf54bd4e6bc5a922746b257" name="a942dd3cabbf54bd4e6bc5a922746b257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942dd3cabbf54bd4e6bc5a922746b257">&#9670;&nbsp;</a></span>f_h_mTmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mTmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of a full matrix and a \(\mathcal{H}\)-matrix with the second operand being transposed. A rank-k matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p ><b>The creation of the rank-k matrix <code>M1_rk</code> from <code>M1</code> will modify <code>M1</code> internally. Hence, we make a copy of <code>M1</code> here.</b></p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l12231">12231</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, and <a class="el" href="hmatrix_8h_source.html#l11119">rk_h_mTmult()</a>.</p>

</div>
</div>
<a id="a8d9fbb4b9a0e5e87096e8d8f833cbb76" name="a8d9fbb4b9a0e5e87096e8d8f833cbb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9fbb4b9a0e5e87096e8d8f833cbb76">&#9670;&nbsp;</a></span>f_h_mTmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mTmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of a full matrix and a \(\mathcal{H}\)-matrix with the second operand being transposed, the result of which will be scaled by a factor. A full matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l12073">12073</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ae7e6b54a178a7a0149f5ad6336e4e49c" name="ae7e6b54a178a7a0149f5ad6336e4e49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e6b54a178a7a0149f5ad6336e4e49c">&#9670;&nbsp;</a></span>f_h_mTmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mTmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of a full matrix and a \(\mathcal{H}\)-matrix with the second operand being transposed. The result will be scaled by a factor. A rank-k matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p ><b>The creation of the rank-k matrix <code>M1_rk</code> from <code>M1</code> will modify <code>M1</code> internally. Hence, we make a copy of <code>M1</code> here.</b></p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l12259">12259</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a216aa00790edb8b8818a42eeab1c24f2" name="a216aa00790edb8b8818a42eeab1c24f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216aa00790edb8b8818a42eeab1c24f2">&#9670;&nbsp;</a></span>f_h_Tmmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_Tmmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of a transposed full matrix and a \(\mathcal{H}\)-matrix. A full matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l12107">12107</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="lapack__full__matrix__ext_8h_source.html#l04563">LAPACKFullMatrixExt&lt; Number &gt;::fill_row()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l02958">LAPACKFullMatrixExt&lt; Number &gt;::get_column()</a>, <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, and <a class="el" href="hmatrix_8h_source.html#l23665">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17073">h_h_Tmmult_level_conserving()</a>.</p>

</div>
</div>
<a id="ae9f5fc097442bf1e9a1d54ca808ff700" name="ae9f5fc097442bf1e9a1d54ca808ff700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f5fc097442bf1e9a1d54ca808ff700">&#9670;&nbsp;</a></span>f_h_Tmmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_Tmmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of a transposed full matrix and a \(\mathcal{H}\)-matrix. A rank-k matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p ><b>The creation of the rank-k matrix <code>M1_rk</code> from <code>M1</code> will modify <code>M1</code> internally. Hence, we make a copy of <code>M1</code> here.</b></p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l12287">12287</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, and <a class="el" href="hmatrix_8h_source.html#l11273">rk_h_Tmmult()</a>.</p>

</div>
</div>
<a id="aebb2efa78e5e8edd5a6c78bb13f99f72" name="aebb2efa78e5e8edd5a6c78bb13f99f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb2efa78e5e8edd5a6c78bb13f99f72">&#9670;&nbsp;</a></span>f_h_Tmmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_Tmmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Scaled multiplication of a transposed full matrix and a \(\mathcal{H}\)-matrix. A full matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l12141">12141</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a99210aa3242f85b43381b4ef49488e45" name="a99210aa3242f85b43381b4ef49488e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99210aa3242f85b43381b4ef49488e45">&#9670;&nbsp;</a></span>f_h_Tmmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_Tmmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Scaled multiplication of a transposed full matrix and a \(\mathcal{H}\)-matrix. A rank-k matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p ><b>The creation of the rank-k matrix <code>M1_rk</code> from <code>M1</code> will modify <code>M1</code> internally. Hence, we make a copy of <code>M1</code> here.</b></p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l12314">12314</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aceb4579cb7d6a65805c548aa9c3f97b9" name="aceb4579cb7d6a65805c548aa9c3f97b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb4579cb7d6a65805c548aa9c3f97b9">&#9670;&nbsp;</a></span>h_f_mmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes with the result scaled by a factor. The second operand is a full matrix and the result is also represented as a full matrix because the associated block cluster node \(\tau\times\rho\) is small.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11496">11496</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a398869486c36312aefc9c22f395fc494" name="a398869486c36312aefc9c22f395fc494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398869486c36312aefc9c22f395fc494">&#9670;&nbsp;</a></span>h_f_mmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes with the result scaled by a factor. The second operand is a full matrix and the result is represented as a rank-k matrix because the associated block cluster is large.</p>
<p >The second matrix <code>M2</code> will be firstly converted to a rank-k matrix. Then its multiplication with <code>M1</code> will be carried by calling <code>h_rk_mmult</code>. Since the conversion from a full matrix to a rank-k matrix will modify the original data, a copy of <code>M2</code> will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a local copy of the full matrix <code>M2</code>.</p>
<p >Convert the full matrix <code>M2</code> to a rank-k matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11707">11707</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ae495fd6b480f203cf797e7e86e996313" name="ae495fd6b480f203cf797e7e86e996313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae495fd6b480f203cf797e7e86e996313">&#9670;&nbsp;</a></span>h_f_mmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the second one is a full matrix and the result is also represented as a full matrix because the associated block cluster node \(\tau\times\rho\) is small.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11460">11460</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="lapack__full__matrix__ext_8h_source.html#l04636">LAPACKFullMatrixExt&lt; Number &gt;::fill_col()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l02958">LAPACKFullMatrixExt&lt; Number &gt;::get_column()</a>, <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, and <a class="el" href="hmatrix_8h_source.html#l21052">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l11894">h_f_mmult_for_h_h_mmult()</a>, and <a class="el" href="hmatrix_8h_source.html#l16039">h_h_mmult_level_conserving()</a>.</p>

</div>
</div>
<a id="a723281b6cf62859890ec5ee49555c908" name="a723281b6cf62859890ec5ee49555c908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723281b6cf62859890ec5ee49555c908">&#9670;&nbsp;</a></span>h_f_mmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the second one is a full matrix and the result is represented as a rank-k matrix because the associated block cluster is large.</p>
<p >The second matrix <code>M2</code> will be firstly converted to a rank-k matrix. Then its multiplication with <code>M1</code> will be carried by calling <code>h_rk_mmult</code>. Since the conversion from a full matrix to a rank-k matrix will modify the original data, a copy of <code>M2</code> will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a local copy of the full matrix <code>M2</code>.</p>
<p >Convert the full matrix <code>M2</code> to a rank-k matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11669">11669</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l10444">h_rk_mmult()</a>, and <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>.</p>

</div>
</div>
<a id="a374070dba133f2152e9c44ce10947f20" name="a374070dba133f2152e9c44ce10947f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374070dba133f2152e9c44ce10947f20">&#9670;&nbsp;</a></span>h_f_mmult_for_h_h_mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mmult_for_h_h_mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_M1M2_last_in_M_Sigma_P</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of two \(\mathcal{H}\)-matrices, where the second one is of <code>FullMatrixType</code>. An \(\mathcal{H}\)-matrix is returned in <code>M</code>, which is either of <code>FullMatrixType</code> or <code>RkMatrixType</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">is_M1M2_last_in_M_Sigma_P</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Full matrix is returned.</p>
<p >Rank-k matrix is returned.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11894">11894</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l11460">h_f_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l36264">HMatrix&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list()</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04403">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="hmatrix_8h_source.html#l04391">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="hmatrix_8h_source.html#l04397">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l28729">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_reduction()</a>.</p>

</div>
</div>
<a id="a3a2ffe1ccde0ac2a90b63cfdd92a5235" name="a3a2ffe1ccde0ac2a90b63cfdd92a5235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2ffe1ccde0ac2a90b63cfdd92a5235">&#9670;&nbsp;</a></span>h_f_mTmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mTmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes with the second operand being transposed, where the second one is a full matrix and the result is also represented as a full matrix because the associated block cluster node \(\tau\times\rho\) is small. The result will be scaled by a factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11567">11567</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ab4df594f8278dbd00a4d098f6e591f68" name="ab4df594f8278dbd00a4d098f6e591f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4df594f8278dbd00a4d098f6e591f68">&#9670;&nbsp;</a></span>h_f_mTmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mTmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes with the second operand being transposed, where the second one is a full matrix and the result is represented as a rank-k matrix because the associated block cluster is large. The result will be scaled by a factor.</p>
<p >The second matrix <code>M2</code> will be firstly converted to a rank-k matrix. Then its multiplication with <code>M1</code> will be carried by calling <code>h_rk_mTmult</code>. Since the conversion from a full matrix to a rank-k matrix will modify the original data, a copy of <code>M2</code> will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a local copy of the full matrix <code>M2</code>.</p>
<p >Convert the full matrix <code>M2</code> to a rank-k matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11784">11784</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a8c5bc5080b3c7e065e70fdba10faae55" name="a8c5bc5080b3c7e065e70fdba10faae55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5bc5080b3c7e065e70fdba10faae55">&#9670;&nbsp;</a></span>h_f_mTmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mTmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes with the second operand being transposed, where the second one is a full matrix and the result is also represented as a full matrix because the associated block cluster node \(\tau\times\rho\) is small.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11532">11532</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="lapack__full__matrix__ext_8h_source.html#l04636">LAPACKFullMatrixExt&lt; Number &gt;::fill_col()</a>, <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l02940">LAPACKFullMatrixExt&lt; Number &gt;::get_row()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, and <a class="el" href="hmatrix_8h_source.html#l21052">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l16558">h_h_mTmult_level_conserving()</a>.</p>

</div>
</div>
<a id="ac9f0b303f7933e220bb976db96536ef9" name="ac9f0b303f7933e220bb976db96536ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f0b303f7933e220bb976db96536ef9">&#9670;&nbsp;</a></span>h_f_mTmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mTmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes with the second operand being transposed, where the second one is a full matrix and the result is represented as a rank-k matrix because the associated block cluster is large.</p>
<p >The second matrix <code>M2</code> will be firstly converted to a rank-k matrix. Then its multiplication with <code>M1</code> will be carried by calling <code>h_rk_mTmult</code>. Since the conversion from a full matrix to a rank-k matrix will modify the original data, a copy of <code>M2</code> will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a local copy of the full matrix <code>M2</code>.</p>
<p >Convert the full matrix <code>M2</code> to a rank-k matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11746">11746</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l10601">h_rk_mTmult()</a>, and <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>.</p>

</div>
</div>
<a id="a5e12950b1f7f97350d7268f49ff8d420" name="a5e12950b1f7f97350d7268f49ff8d420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e12950b1f7f97350d7268f49ff8d420">&#9670;&nbsp;</a></span>h_f_Tmmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_Tmmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11628">11628</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a21c1a545280989e74a77ae9133ca8a2c" name="a21c1a545280989e74a77ae9133ca8a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c1a545280989e74a77ae9133ca8a2c">&#9670;&nbsp;</a></span>h_f_Tmmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_Tmmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the scaled product of two \(\mathcal{H}\)-matrix nodes with the first operand being transposed, where the second one is a full matrix and the result is represented as a rank-k matrix because the associated block cluster is large.</p>
<p >The second matrix <code>M2</code> will be firstly converted to a rank-k matrix. Then its multiplication with <code>M1^T</code> will be carried by calling <code>h_rk_Tmmult</code>. Since the conversion from a full matrix to a rank-k matrix will modify the original data, a copy of <code>M2</code> will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a local copy of the full matrix <code>M2</code>.</p>
<p >Convert the full matrix <code>M2</code> to a rank-k matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11862">11862</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a85d6d9989cc78f7fffa8c1e890512652" name="a85d6d9989cc78f7fffa8c1e890512652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d6d9989cc78f7fffa8c1e890512652">&#9670;&nbsp;</a></span>h_f_Tmmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes with the first operand being transposed, where the second one is a full matrix and the result is also represented as a full matrix because the associated block cluster node \(\tau\times\rho\) is small.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11603">11603</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="lapack__full__matrix__ext_8h_source.html#l04636">LAPACKFullMatrixExt&lt; Number &gt;::fill_col()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l02958">LAPACKFullMatrixExt&lt; Number &gt;::get_column()</a>, <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, and <a class="el" href="hmatrix_8h_source.html#l23665">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17073">h_h_Tmmult_level_conserving()</a>.</p>

</div>
</div>
<a id="a240be067972358dc350a79879eeb4c04" name="a240be067972358dc350a79879eeb4c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240be067972358dc350a79879eeb4c04">&#9670;&nbsp;</a></span>h_f_Tmmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes with the first operand being transposed, where the second one is a full matrix and the result is represented as a rank-k matrix because the associated block cluster is large.</p>
<p >The second matrix <code>M2</code> will be firstly converted to a rank-k matrix. Then its multiplication with <code>M1^T</code> will be carried by calling <code>h_rk_Tmmult</code>. Since the conversion from a full matrix to a rank-k matrix will modify the original data, a copy of <code>M2</code> will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a local copy of the full matrix <code>M2</code>.</p>
<p >Convert the full matrix <code>M2</code> to a rank-k matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11823">11823</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l10751">h_rk_Tmmult()</a>, and <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>.</p>

</div>
</div>
<a id="a4b1a5fe7054002f55672d5ea81c3ac9c" name="a4b1a5fe7054002f55672d5ea81c3ac9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1a5fe7054002f55672d5ea81c3ac9c">&#9670;&nbsp;</a></span>h_h_mmult_from_leaf_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mmult_from_leaf_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type_for_local_Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >\(\mathcal{H}\)-matrix- \(\mathcal{H}\)-matrix multiplication with the result scaled by a factor, when the product matrix belongs to the leaf set of the target block cluster tree.</p>
<p >This function implements the recursive <code>MMR</code> algorithm in (7.26) in Hackbusch's \(\mathcal{H}\)-matrix book.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M0</td><td>The initial product matrix on the block cluster node \(\tau_0\times\rho_0\).</td></tr>
    <tr><td class="paramname">M</td><td>The current product matrix \(M\) on the block cluster node \(\tau\times\rho\), which will assembles the contribution from \(M_1
\cdot M_2\) (N.B. This description is only valid for the first call of this function. During recursive calls of this function, <code>M</code> may not be on a same level as the product of <code>M1</code> and <code>M2</code>, when both <code>M1</code> and <code>M2</code> have substructures and the multiplication needs to collect results from the multiplications of submatrices). For the first call of this function, <code>M</code> is the same as <code>M0</code>. </td></tr>
    <tr><td class="paramname">M1</td><td>The first operand of the multiplication, which is built upon the block cluster node \(\tau\times\sigma\). </td></tr>
    <tr><td class="paramname">M2</td><td>The second operand of the multiplication, which is built upon the block cluster node \(\sigma\times\rho\). </td></tr>
    <tr><td class="paramname">block_type_for_local_Z</td><td>Block type for the local \(\mathcal{H}\)-matrix <code>Z</code>, which is the product of <code>M1</code> and <code>M2</code>. </td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td>Flag indicating whether only the lower triangular part and the diagonal part of the \(\mathcal{H}\)-matrix <code>M</code> are stored. The naming of this variable follows the convention adopted by GNU Octave, where a lower triangular matrix has nonzero entries only on the main diagonal and below. See <code>tril</code> and <code>istril</code> function in GNU Octave. </td></tr>
  </table>
  </dd>
</dl>
<p >Here we make an assertion that the top level result \(\mathcal{H}\)-matrix <code>M0</code> should be a leaf node.</p>
<p >Create a block cluster node \(\tau\times\rho\) for the current local product matrix <code>Z</code>. Since this block cluster node will not be connected with other block cluster nodes in a block cluster tree, it has neither parent nor children and its level is set to zero.</p>
<p >Set the <code>is_near_field</code> flag of the block cluster node for the current local product matrix <code>Z</code> according to the matrix type of the initial leaf node \(\mathcal{H}\)-matrix <code>M0</code>, i.e. it inherits the <code>is_near_field</code> flag of the block cluster node for <code>M0</code>.</p>
<p >When the flag <code>is_result_matrix_store_tril_only</code> is true, determine if the \(\mathcal{H}\)-matrix property of the local product \(\mathcal{H}\)-matrix <code>Z</code> should be the same as that of <code>M</code> by checking if the index ranges of its \(\tau\) node and \(\sigma\) are the same, since only when they are the same, <code>Z</code> or <code>M's</code> property can be symmetric, Hermite symmetric or lower triangular.</p>
<p >The local product \(\mathcal{H}\)-matrix <code>Z</code> inherits the property of <code>M</code>, which can be either symmetric, Hermite symmetric or lower triangular.</p>
<p >If the local \(\mathcal{H}\)-matrix <code>Z</code> is symmetric, Hermite symmetric or lower triangular, its block type should be <code>diagonal_block</code> and an assertion is made about this fact.</p>
<p >Create the local product \(\mathcal{H}\)-matrix <code>Z</code> associated with the current block cluster node. During its initialization, memory will be allocated depending on its \(\mathcal{H}\)-matrix property and block type.</p>
<p >When either operand <code>M1</code> or <code>M2</code> is a leaf node, directly evaluation of their multiplication can be performed.</p>
<p >If the local product \(\mathcal{H}\)-matrix <code>Z</code> is expected to be symmetric, Hermite symmetric or lower triangular, also set the property of the associated full matrix correspondingly. This operation is mandatory because the property of the local full matrix <code>ZF</code> is <code>general</code>, which has overwritten the property of <code>Z</code>.</p>
<p >In this case, both <code>M1</code> and <code>M2</code> have child submatrices.</p>
<p ><b>When we perform submatrix multiplication, we use a higher specified rank, since the results will be assembled into the larger matrix <code>Z</code> via pairwise formatted addition, during which the actual matrix rank may increase.</b></p>
<p >The virtual submatrix block <code>Z.submatrices</code>[1], which is obtained from the cross type multiplication of <code>M1</code> and <code>M2</code>, will be evaluated in two scenarios:</p><ol type="1">
<li>when the result matrix is not expected to be symmetric, Hermite symmetric or lower triangular;</li>
<li>when the result matrix is required to be symmetric, Hermite symmetric or lower triangular a priori, then if the product matrix <code>Z</code> is not symmetric, Hermite symmetric or lower triangular.</li>
</ol>
<p >Here the "virtual" above means even though <code>Z</code> is actually not further divided and have no submatrices, the cross type multiplication will generate submatrix blocks virtually.</p>
<p >Assemble the local matrix <code>Z</code> to the product matrix <code>M</code>.</p>
<p >When the original matrix <code>M0</code> belongs to the near field, assemble the full matrix stored in <code>Z</code> directly into <code>M</code>.</p>
<p >When the original matrix <code>M0</code> does not belong to the near field, assemble the rank-k matrix stored in <code>Z</code> into <code>M</code> by first embedding then formatted addition, which has been implemented in the member function <code>assemble_from_rkmatrix</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l13010">13010</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a0e4d0483375618fed513fe9a9ca73dc6" name="a0e4d0483375618fed513fe9a9ca73dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4d0483375618fed513fe9a9ca73dc6">&#9670;&nbsp;</a></span>h_h_mmult_from_leaf_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mmult_from_leaf_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type_for_local_Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >\(\mathcal{H}\)-matrix- \(\mathcal{H}\)-matrix multiplication when the product matrix belongs to the leaf set of the target block cluster tree.</p>
<p >This function implements the recursive <code>MMR</code> algorithm in (7.26) in Hackbusch's \(\mathcal{H}\)-matrix book.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M0</td><td>The initial product matrix on the block cluster node \(\tau_0\times\rho_0\), which is a leaf node in the product block cluster tree.</td></tr>
    <tr><td class="paramname">M</td><td>The current product matrix \(M\) on the block cluster node \(\tau\times\rho\), which will assembles the contribution from \(M_1
\cdot M_2\) (N.B. This description is only valid for the first call of this function. During recursive calls of this function, <code>M</code> may not be on a same level as the product of <code>M1</code> and <code>M2</code>, when both <code>M1</code> and <code>M2</code> have substructures and the multiplication needs to collect results from the multiplications of submatrices). For the first call of this function, <code>M</code> is the same as <code>M0</code>. </td></tr>
    <tr><td class="paramname">M1</td><td>The first operand of the multiplication, which is built upon the block cluster node \(\tau\times\sigma\). </td></tr>
    <tr><td class="paramname">M2</td><td>The second operand of the multiplication, which is built upon the block cluster node \(\sigma\times\rho\). </td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Here we make an assertion that the top level result \(\mathcal{H}\)-matrix <code>M0</code> should be a leaf node.</p>
<p >Create a block cluster node \(\tau\times\rho\) for the current local product matrix <code>Z</code>. Since this block cluster node will not be connected with other block cluster nodes in a block cluster tree, it has neither parent nor children and its level is set to zero.</p>
<p >Set the <code>is_near_field</code> flag of the block cluster node for the current local product matrix <code>Z</code> according to the matrix type of the initial leaf node \(\mathcal{H}\)-matrix <code>M0</code>, i.e. it inherits the <code>is_near_field</code> flag of the block cluster node for <code>M0</code>.</p>
<p >When the flag <code>is_result_matrix_store_tril_only</code> is true, determine if the \(\mathcal{H}\)-matrix property of the local product \(\mathcal{H}\)-matrix <code>Z</code> should be the same as that of <code>M</code> by checking if the index ranges of its \(\tau\) node and \(\sigma\) are the same, since only when they are the same, <code>Z</code> or <code>M's</code> property can be symmetric, Hermite symmetric or lower triangular.</p>
<p >The local product \(\mathcal{H}\)-matrix <code>Z</code> inherits the property of <code>M</code>, which can be either symmetric, Hermite symmetric or lower triangular.</p>
<p >If the local \(\mathcal{H}\)-matrix <code>Z</code> is symmetric, Hermite symmetric or lower triangular, its block type should be <code>diagonal_block</code> and an assertion is made about this fact.</p>
<p >Create the local product \(\mathcal{H}\)-matrix <code>Z</code> associated with the current block cluster node. During its initialization, memory will be allocated depending on its \(\mathcal{H}\)-matrix property and block type.</p>
<p >When either operand <code>M1</code> or <code>M2</code> is a leaf node, directly evaluation of their multiplication can be performed.</p>
<p >If the local product \(\mathcal{H}\)-matrix <code>Z</code> is expected to be symmetric, Hermite symmetric or lower triangular, also set the property of the associated full matrix correspondingly. This operation is mandatory because the property of the local full matrix <code>ZF</code> is <code>general</code> , which has overwritten the property of <code>Z</code>.</p>
<p >In this case, both <code>M1</code> and <code>M2</code> have child submatrices.</p>
<p ><b>When we perform submatrix multiplication, we use a higher specified rank, since the results will be assembled into the larger matrix <code>Z</code> via pairwise formatted addition, during which the actual matrix rank may increase.</b></p>
<p >The submatrix block <code>Z.submatrices</code>[1], which is obtained from the cross type multiplication of <code>M1</code> and <code>M2</code>, will be evaluated in two scenarios:</p><ol type="1">
<li>when the \(\mathcal{H}\)-matrix <code>M</code> is not expected to be symmetric, Hermite symmetric or lower triangular;</li>
<li>when the \(\mathcal{H}\)-matrix <code>M</code> is required to be symmetric, Hermite symmetric or lower triangular a priori, and the product matrix <code>Z</code> should not be symmetric, Hermite symmetric or lower triangular.</li>
</ol>
<p >Assemble the local matrix <code>Z</code> to the product matrix <code>M</code>.</p>
<p >When the original matrix <code>M0</code> belongs to the near field, assemble the full matrix stored in <code>Z</code> directly into <code>M</code>.</p>
<p >When the original matrix <code>M0</code> does not belong to the near field, assemble the rank-k matrix stored in <code>Z</code> into <code>M</code> by first embedding then formatted addition, which has been implemented in the member function <code>assemble_from_rkmatrix</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l12592">12592</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l19656">HMatrix&lt; spacedim, Number &gt;::get_block_type()</a>, and <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l16039">h_h_mmult_level_conserving()</a>.</p>

</div>
</div>
<a id="a5c51d3d90b5800a92b0679a2ac0b64ad" name="a5c51d3d90b5800a92b0679a2ac0b64ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c51d3d90b5800a92b0679a2ac0b64ad">&#9670;&nbsp;</a></span>h_h_mmult_from_leaf_node_for_parallel_lu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mmult_from_leaf_node_for_parallel_lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type_for_local_Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Here we make an assertion that the top level result \(\mathcal{H}\)-matrix <code>M0</code> should be a leaf node.</p>
<p >Create a block cluster node \(\tau\times\rho\) for the current local product matrix <code>Z</code>. Since this block cluster node will not be connected with other block cluster nodes in a block cluster tree, it has neither parent nor children and its level is set to zero.</p>
<p >Set the <code>is_near_field</code> flag of the block cluster node for the current local product matrix <code>Z</code> according to the matrix type of the initial leaf node \(\mathcal{H}\)-matrix <code>M0</code>, i.e. it inherits the <code>is_near_field</code> flag of the block cluster node for <code>M0</code>.</p>
<p >When the flag <code>is_result_matrix_store_tril_only</code> is true, determine if the \(\mathcal{H}\)-matrix property of the local product \(\mathcal{H}\)-matrix <code>Z</code> should be the same as that of <code>M</code> by checking if the index ranges of its \(\tau\) node and \(\sigma\) are the same, since only when they are the same, <code>Z</code> or <code>M's</code> property can be symmetric or lower triangular.</p>
<p >The local product \(\mathcal{H}\)-matrix <code>Z</code> inherits the property of <code>M</code>, which can be either symmetric or lower triangular.</p>
<p >If the local \(\mathcal{H}\)-matrix <code>Z</code> is symmetric or lower triangular, its block type should be <code>diagonal_block</code> and an assertion is made about this fact.</p>
<p >Create the local product \(\mathcal{H}\)-matrix <code>Z</code> associated with the current block cluster node. During its initialization, memory will be allocated depending on its \(\mathcal{H}\)-matrix property and block type.</p>
<p >When either operand <code>M1</code> or <code>M2</code> is a leaf node, directly evaluation of their multiplication can be performed.</p>
<p >If the local product \(\mathcal{H}\)-matrix <code>Z</code> is expected to be symmetric or lower triangular, also set the property of the associated full matrix correspondingly. This operation is mandatory because the property of the local full matrix <code>ZF</code> is <code>general</code>, which has overwritten the property of <code>Z</code>.</p>
<p >In this case, both <code>M1</code> and <code>M2</code> have child submatrices.</p>
<p ><b>When we perform submatrix multiplication, we use a higher specified rank, since the results will be assembled into the larger matrix <code>Z</code> via pairwise formatted addition, during which the actual matrix rank may increase.</b></p>
<p >The virtual submatrix block <code>Z.submatrices</code>[1], which is obtained from the cross type multiplication of <code>M1</code> and <code>M2</code>, will be evaluated in two scenarios:</p><ol type="1">
<li>when the result matrix is not expected to be symmetric, Hermite symmetric or lower triangular;</li>
<li>when the result matrix is required to be symmetric, Hermite symmetric or lower triangular a priori, then if the product matrix <code>Z</code> is not symmetric, Hermite symmetric or lower triangular.</li>
</ol>
<p >Here the "virtual" above means even though <code>Z</code> is actually not further divided and have no submatrices, the cross type multiplication will generate submatrix blocks virtually.</p>
<p >Assemble the local matrix <code>Z</code> to the product matrix <code>M</code>.</p>
<p >When the original matrix <code>M0</code> belongs to the near field, assemble the full matrix stored in <code>Z</code> directly into <code>M</code>.</p>
<p >Only when the result matrix <code>M</code> is the top level result matrix <code>M0</code>, the mutex will be locked. Otherwise, the result matrix <code>M</code> is only a temporary object, which needs not be locked.</p>
<p >When the original matrix <code>M0</code> does not belong to the near field, assemble the rank-k matrix stored in <code>Z</code> into <code>M</code> by first embedding then formatted addition, which has been implemented in the member function <code>assemble_from_rkmatrix</code>.</p>
<p >Only when the result matrix <code>M</code> is the top level result matrix <code>M0</code>, the mutex will be locked. Otherwise, the result matrix <code>M</code> is only a temporary object, which needs not be locked.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l13410">13410</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a53c53846a0495ef6c79e154f1417b808" name="a53c53846a0495ef6c79e154f1417b808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c53846a0495ef6c79e154f1417b808">&#9670;&nbsp;</a></span>h_h_mmult_level_conserving() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of two level-conserving \(\mathcal{H}\)-matrices with a factor multiplied to the matrix product and the result will be added to the target matrix <code>M</code>, i.e. \(M = M + \alpha \cdot M_1 M_2\).</p>
<dl class="section note">
<dt>Note</dt>
<dd>It is required that an empty result matrix <code>M</code> should be created first with respect to a block cluster tree.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M0</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<p >All matrices (including the two operands and the product result) have substructure. Hence the \(\mathcal{H}\)-matrix multiplication type is cross.</p>
<p >N.B. When the \(\mathcal{H}\)-matrix is symmetric or lower triangular, it stores the lower triangular data only (including diagonal elements).</p>
<p >The submatrix block <code>M.submatrices</code>[1] will be evaluated in two scenarios:</p><ol type="1">
<li>when the result matrix is not expected to be symmetric, Hermite symmetric or lower triangular;</li>
<li>when the result matrix is required to be symmetric, Hermite symmetric or lower triangular a priori, then if the product matrix <code>M</code> is not symmetric, Hermite symmetric or lower triangular.</li>
</ol>
<p >This is the case when the product matrix <code>M</code> is further divided, while at least one of the two operands is a leaf. Hence the multiplication on this level can be directly evaluated.</p>
<ol type="1">
<li>When one of the operand matrix is a rank-k matrix, the product result is also a rank-k matrix.</li>
<li>When one of the operand matrix is a full matrix, the immediate product result is for sure a full matrix. However, because the block cluster associated with <code>M</code> is not a leaf, <code>M</code> should be represented as a rank-k matrix, which is converted from the full matrix. In the current implementation, this conversion has no accuracy loss.</li>
</ol>
<p >Add the result matrix <code>Z</code> into <code>M</code> and note that <code>Z</code> and <code>M</code> are associated with a same block cluster.</p>
<p >This addition is implemented by restricting <code>Z</code> to each leaf node of <code>M</code> first, then the addition operation will be performed on each leaf node respectively.</p>
<p ><b>The matrix <code>Z</code> should only be added into <code>M</code> but not simply overwrite <code>M</code>. This is because the result matrix <code>M</code> on the block cluster \(\tau\times\rho\) may be contributed from several multiplications with respect to a collection of \({\sigma_i}\), which forms a partition of the index set \(J\).</b></p>
<p >This is the first time of calling <code>h_h_mmult_from_leaf_node</code>, where the second argument <code>M</code> is the product of <code>M1</code> and <code>M2</code>. If there are further recursive calls of this function, the second argument will be one level higher than the product of <code>M1</code> and <code>M2</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l16210">16210</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="af63f1a7be7435625f9d78f7d0cedfa38" name="af63f1a7be7435625f9d78f7d0cedfa38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63f1a7be7435625f9d78f7d0cedfa38">&#9670;&nbsp;</a></span>h_h_mmult_level_conserving() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of two level-conserving \(\mathcal{H}\)-matrices and the result will be added to the target matrix <code>M</code>, i.e. \(M = M + M_1 M_2\).</p>
<dl class="section note">
<dt>Note</dt>
<dd>It is required that an empty result matrix <code>M</code> should be created first with respect to a block cluster tree.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >All matrices (including the two operands and the product result) have substructure. Hence the \(\mathcal{H}\)-matrix multiplication type is cross.</p>
<p >N.B. When the \(\mathcal{H}\)-matrix is symmetric, Hermite symmetric or lower triangular, it stores the lower triangular data only (including diagonal elements).</p>
<p >The submatrix block <code>M.submatrices</code>[1] will be evaluated in two scenarios:</p><ol type="1">
<li>when the result matrix is not expected to be symmetric, Hermite symmetric or lower triangular;</li>
<li>when the result matrix is required to be symmetric, Hermite symmetric or lower triangular a priori, then if the product matrix <code>M</code> is not symmetric, Hermite symmetric or lower triangular.</li>
</ol>
<p >This is the case when the product matrix <code>M</code> is further divided, while at least one of the two operands is a leaf. Hence the multiplication on this level can be directly evaluated.</p>
<ol type="1">
<li>When one of the operand matrix is a rank-k matrix, the product result is also a rank-k matrix.</li>
<li>When one of the operand matrix is a full matrix, the immediate product result is for sure a full matrix. However, because the block cluster associated with <code>M</code> is not a leaf, <code>M</code> should be represented as a rank-k matrix, which is converted from the full matrix. In the current implementation, this conversion has no accuracy loss.</li>
</ol>
<p >Add the result matrix <code>Z</code> into <code>M</code> and note that <code>Z</code> and <code>M</code> are associated with a same block cluster.</p>
<p >This addition is implemented by restricting <code>Z</code> to each leaf node of <code>M</code> first, then the addition operation will be performed on each leaf node respectively.</p>
<p ><b>The matrix <code>Z</code> should only be added into <code>M</code> but not simply overwrite <code>M</code>. This is because the result matrix <code>M</code> on the block cluster \(\tau\times\rho\) may be contributed from several multiplications with respect to a collection of \({\sigma_i}\), which forms a partition of the index set \(J\).</b></p>
<p >This is the first time of calling <code>h_h_mmult_from_leaf_node</code>, where the second argument <code>M</code> is the product of <code>M1</code> and <code>M2</code>. If there are further recursive calls of this function, the second argument will be one level higher than the product of <code>M1</code> and <code>M2</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l16039">16039</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l29431">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l11964">f_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l11460">h_f_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l12592">h_h_mmult_from_leaf_node()</a>, <a class="el" href="hmatrix_8h_source.html#l16039">h_h_mmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l10444">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04263">HMatrix&lt; spacedim, Number &gt;::property</a>, <a class="el" href="hmatrix_8h_source.html#l10959">rk_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l16039">h_h_mmult_level_conserving()</a>, and <a class="el" href="hmatrix_8h_source.html#l29322">HMatrix&lt; spacedim, Number &gt;::mmult_level_conserving()</a>.</p>

</div>
</div>
<a id="ac6cebba380fc26680f8522816f78fd56" name="ac6cebba380fc26680f8522816f78fd56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6cebba380fc26680f8522816f78fd56">&#9670;&nbsp;</a></span>h_h_mmult_level_conserving_for_parallel_lu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mmult_level_conserving_for_parallel_lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >All matrices (including the two operands and the product result) have substructure. Hence the \(\mathcal{H}\)-matrix multiplication type is cross.</p>
<p >N.B. When the \(\mathcal{H}\)-matrix is symmetric or lower triangular, it stores the lower triangular data only (including diagonal elements).</p>
<p >The submatrix block <code>M.submatrices</code>[1] will be evaluated in two scenarios:</p><ol type="1">
<li>when the result matrix is not expected to be symmetric, Hermite symmetric or lower triangular;</li>
<li>when the result matrix is required to be symmetric, Hermite symmetric or lower triangular a priori, then if the product matrix <code>M</code> is not symmetric, Hermite symmetric or lower triangular.</li>
</ol>
<p >This is the case when the product matrix <code>M</code> is further divided, while at least one of the two operands is a leaf. Hence the multiplication on this level can be directly evaluated.</p>
<ol type="1">
<li>When one of the operand matrix is a rank-k matrix, the product result is also a rank-k matrix.</li>
<li>When one of the operand matrix is a full matrix, the immediate product result is for sure a full matrix. However, because the block cluster associated with <code>M</code> is not a leaf, <code>M</code> should be represented as a rank-k matrix, which is converted from the full matrix. In the current implementation, this conversion has no accuracy loss.</li>
</ol>
<p >Add the result matrix <code>Z</code> into <code>M</code> and note that <code>Z</code> and <code>M</code> are associated with a same block cluster.</p>
<p >This addition is implemented by restricting <code>Z</code> to each leaf node of <code>M</code> first, then the addition operation will be performed on each leaf node respectively.</p>
<p ><b>The matrix <code>Z</code> should only be added into <code>M</code> but not simply overwrite <code>M</code>. This is because the result matrix <code>M</code> on the block cluster \(\tau\times\rho\) may be contributed from several multiplications with respect to a collection of \({\sigma_i}\), which forms a partition of the index set \(J\).</b></p>
<p >This is the first time of calling <code>h_h_mmult_from_leaf_node</code>, where the second argument <code>M</code> is the product of <code>M1</code> and <code>M2</code>. If there are further recursive calls of this function, the second argument will be one level higher than the product of <code>M1</code> and <code>M2</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l16373">16373</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ade843f2c14289e1be70ff93679e8db15" name="ade843f2c14289e1be70ff93679e8db15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade843f2c14289e1be70ff93679e8db15">&#9670;&nbsp;</a></span>h_h_mmult_phase1_recursion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mmult_phase1_recursion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>Tind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >There are still multiplication subtasks stored in <code>Sigma_P</code> to be handled recursively.</p>
<p >After previous reduction and splitting, the matrix multiplication for the current \(\mathcal{H}\)-matrix node should be replaced by the multiplication subtasks for submatrices. These subtasks are recorded as \(\mathcal{H}\)-matrix node pairs which are stored in \(\Sigma_b^P\) of the submatrices.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l12403">12403</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l36304">HMatrix&lt; spacedim, Number &gt;::determine_mm_split_mode_from_Sigma_P()</a>, <a class="el" href="hmatrix_8h_source.html#l28729">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_reduction()</a>, and <a class="el" href="hmatrix_8h_source.html#l04391">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l29207">HMatrix&lt; spacedim, Number &gt;::mmult()</a>.</p>

</div>
</div>
<a id="a3c0184540d75eabf04c9a409318a4565" name="a3c0184540d75eabf04c9a409318a4565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0184540d75eabf04c9a409318a4565">&#9670;&nbsp;</a></span>h_h_mmult_phase2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mmult_phase2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_bc_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Collect terms in <code>Sigma_R</code> and <code>Sigma_F</code> for the leaf nodes.</p>
<p >Here we make sure that \(\mathcal{H}\)-matrix pairs in the list \(\Sigma_b^P\) have all been processed and erased, hence the list should be empty.</p>
<p >Perform pairwise formatted addition for the list of rank-k matrices stored in the list \(\Sigma_b^R\), the result of which will be assigned to the <code>rkmatrix</code> field of the current \(\mathcal{H}\)-matrix leaf node.</p>
<p >Clear the list \(\Sigma_b^R\) after adding all of its rank-k matrices.</p>
<p >Clear the list \(\Sigma_b^F\) after adding all of its full matrices.</p>
<p ><b>Important</b>: Distribute matrices stored in \(\Sigma_b^R\) and \(\Sigma_b^F\) of each <b>non-leaf node</b> to the leaf nodes which are its descendants.</p>
<p >Convert the calculated product matrix to the specified matrix structure.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l12474">12474</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l36166">HMatrix&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees()</a>, <a class="el" href="hmatrix_8h_source.html#l18687">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04328">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04403">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="hmatrix_8h_source.html#l04391">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="hmatrix_8h_source.html#l04397">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, <a class="el" href="hmatrix_8h_source.html#l04383">HMatrix&lt; spacedim, Number &gt;::Tind</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l29207">HMatrix&lt; spacedim, Number &gt;::mmult()</a>.</p>

</div>
</div>
<a id="a7573d10748a80abe2d6b969dc60788b5" name="a7573d10748a80abe2d6b969dc60788b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7573d10748a80abe2d6b969dc60788b5">&#9670;&nbsp;</a></span>h_h_mTmult_from_leaf_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mTmult_from_leaf_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type_for_local_Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >\(\mathcal{H}\)-matrix- \(\mathcal{H}\)-matrix multiplication with the second operand transposed, when the product matrix belongs to the leaf set of the target block cluster tree.</p>
<p >This function implements the recursive <code>MMR</code> algorithm in (7.26) in Hackbusch's \(\mathcal{H}\)-matrix book.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M0</td><td>The initial product matrix on the block cluster node \(\tau_0\times\rho_0\). </td></tr>
    <tr><td class="paramname">M</td><td>The current product matrix \(M\) on the block cluster node \(\tau\times\rho\), which will assembles the contribution from \(M_1
\cdot M_2^T\) (N.B. This description is only valid for the first call of this function. During recursive calls of this function, <code>M</code> may not be on a same level as the product of <code>M1</code> and <code>M2</code>, when both <code>M1</code> and <code>M2</code> have substructures and the multiplication needs to collect results from the multiplications of submatrices). For the first call of this function, <code>M</code> is the same as <code>M0</code>. </td></tr>
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td>The first operand of the multiplication, which is built upon the block cluster node \(\tau\times\sigma\). </td></tr>
    <tr><td class="paramname">M2</td><td>The second operand of the multiplication, which is built upon the block cluster node \(\rho\times\sigma\). </td></tr>
    <tr><td class="paramname">block_type_for_local_Z</td><td>Block type for the local \(\mathcal{H}\)-matrix <code>Z</code>, which is the product of <code>M1</code> and <code>M2</code>. </td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td>Flag indicating whether only the lower triangular part and the diagonal part of the \(\mathcal{H}\)-matrix <code>M</code> are stored. The naming of this variable follows the convention adopted by GNU Octave, where a lower triangular matrix has nonzero entries only on the main diagonal and below. See <code>tril</code> and <code>istril</code> function in GNU Octave. </td></tr>
  </table>
  </dd>
</dl>
<p >Here we make an assertion that the top level result \(\mathcal{H}\)-matrix <code>M0</code> should be a leaf node.</p>
<p >Create a block cluster node \(\tau\times\rho\) for the current local product matrix <code>Z</code>. Since this block cluster node will not be connected with other block cluster nodes in a block cluster tree, it has neither parent nor children and its level is set to zero.</p>
<p ><b>Because the current multiplication is \(M_1\cdot M_2^T\), the product \bctnode is built from \(\tau\) of \(M_1\) and \(\tau\) of \(M_2\).</b></p>
<p >Set the <code>is_near_field</code> flag of the block cluster node for the current local product matrix <code>Z</code> according to the matrix type of the initial leaf node \(\mathcal{H}\)-matrix <code>M0</code>, i.e. it inherits the <code>is_near_field</code> flag of the block cluster node for <code>M0</code>.</p>
<p >When the flag <code>is_result_matrix_store_tril_only</code> is true, determine if the \(\mathcal{H}\)-matrix property of the local product \(\mathcal{H}\)-matrix <code>Z</code> should be the same as that of <code>M</code> by checking if the index ranges of its \(\tau\) node and \(\sigma\) are the same, since only when they are the same, <code>Z</code> or <code>M's</code> property can be symmetric or lower triangular.</p>
<p >The local product \(\mathcal{H}\)-matrix <code>Z</code> inherits the property of <code>M</code>, which can be either symmetric or lower triangular.</p>
<p >If the local \(\mathcal{H}\)-matrix <code>Z</code> is symmetric or lower triangular, its block type should be <code>diagonal_block</code> and an assertion is made about this fact.</p>
<p >Create the local product \(\mathcal{H}\)-matrix <code>Z</code> associated with the current block cluster node. During its initialization, memory will be allocated depending on its \(\mathcal{H}\)-matrix property and block type.</p>
<p >When either operand <code>M1</code> or <code>M2</code> is a leaf node, directly evaluation of their multiplication can be performed.</p>
<p >If the local product \(\mathcal{H}\)-matrix <code>Z</code> is expected to be symmetric or lower triangular, also set the property of the associated full matrix correspondingly. This operation is mandatory because the property of the local full matrix <code>ZF</code> is <code>general</code>, which has overwritten the property of <code>Z</code>.</p>
<p >In this case, both <code>M1</code> and <code>M2</code> have child submatrices.</p>
<p ><b>When we perform submatrix multiplication, we use a higher specified rank, since the results will be assembled into the larger matrix <code>Z</code> via pairwise formatted addition, during which the actual matrix rank may increase.</b></p>
<p >The submatrix block <code>Z.submatrices</code>[1], which is obtained from the cross type multiplication of <code>M1</code> and <code>M2</code>, will be evaluated in two scenarios:</p><ol type="1">
<li>when the \(\mathcal{H}\)-matrix <code>M</code> is not expected to be symmetric, Hermite symmetric or lower triangular;</li>
<li>when the \(\mathcal{H}\)-matrix <code>M</code> is required to be symmetric, Hermite symmetric or lower triangular a priori, and the product matrix <code>Z</code> should not be symmetric, Hermite symmetric or lower triangular.</li>
</ol>
<p >Assemble the product \(\mathcal{H}\)-matrix <code>Z</code> to the \(\mathcal{H}\)-matrix <code>M</code>.</p>
<p >When the original matrix <code>M0</code> belongs to the near field, assemble the full matrix stored in <code>Z</code> directly into <code>M</code>.</p>
<p >When the original matrix <code>M0</code> does not belong to the near field, assemble the rank-k matrix stored in <code>Z</code> into <code>M</code> by first embedding then formatted addition, which has been implemented in the member function <code>assemble_from_rkmatrix</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l14334">14334</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a508e9db2e74ed9eaaa6f059ab87abeaa" name="a508e9db2e74ed9eaaa6f059ab87abeaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508e9db2e74ed9eaaa6f059ab87abeaa">&#9670;&nbsp;</a></span>h_h_mTmult_from_leaf_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mTmult_from_leaf_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type_for_local_Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >\(\mathcal{H}\)-matrix- \(\mathcal{H}\)-matrix multiplication with the second operand transposed, when the product matrix belongs to the leaf set of the target block cluster tree.</p>
<p >This function implements the recursive <code>MMR</code> algorithm in (7.26) in Hackbusch's \(\mathcal{H}\)-matrix book.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M0</td><td>The initial product matrix on the block cluster node \(\tau_0\times\rho_0\). </td></tr>
    <tr><td class="paramname">M</td><td>The current product matrix \(M\) on the block cluster node \(\tau\times\rho\), which will assembles the contribution from \(M_1
\cdot M_2^T\) (N.B. This description is only valid for the first call of this function. During recursive calls of this function, <code>M</code> may not be on a same level as the product of <code>M1</code> and <code>M2</code>, when both <code>M1</code> and <code>M2</code> have substructures and the multiplication needs to collect results from the multiplications of submatrices). For the first call of this function, <code>M</code> is the same as <code>M0</code>. </td></tr>
    <tr><td class="paramname">M1</td><td>The first operand of the multiplication, which is built upon the block cluster node \(\tau\times\sigma\). </td></tr>
    <tr><td class="paramname">M2</td><td>The second operand of the multiplication, which is built upon the block cluster node \(\rho\times\sigma\). </td></tr>
    <tr><td class="paramname">block_type_for_local_Z</td><td>Block type for the local \(\mathcal{H}\)-matrix <code>Z</code>, which is the product of <code>M1</code> and <code>M2</code>. </td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td>Flag indicating whether only the lower triangular part and the diagonal part of the \(\mathcal{H}\)-matrix <code>M</code> are stored. The naming of this variable follows the convention adopted by GNU Octave, where a lower triangular matrix has nonzero entries only on the main diagonal and below. See <code>tril</code> and <code>istril</code> function in GNU Octave. </td></tr>
  </table>
  </dd>
</dl>
<p >Here we make an assertion that the top level result \(\mathcal{H}\)-matrix <code>M0</code> should be a leaf node.</p>
<p >Create a block cluster node \(\tau\times\rho\) for the current local product matrix <code>Z</code>. Since this block cluster node will not be connected with other block cluster nodes in a block cluster tree, it has neither parent nor children and its level is set to zero.</p>
<p ><b>Because the current multiplication is \(M_1\cdot M_2^T\), the product \bctnode is built from \(\tau\) of \(M_1\) and \(\tau\) of \(M_2\).</b></p>
<p >Set the <code>is_near_field</code> flag of the block cluster node for the current local product matrix <code>Z</code> according to the matrix type of the initial leaf node \(\mathcal{H}\)-matrix <code>M0</code>, i.e. it inherits the <code>is_near_field</code> flag of the block cluster node for <code>M0</code>.</p>
<p >When the flag <code>is_result_matrix_store_tril_only</code> is true, determine if the \(\mathcal{H}\)-matrix property of the local product \(\mathcal{H}\)-matrix <code>Z</code> should be the same as that of <code>M</code> by checking if the index ranges of its \(\tau\) node and \(\sigma\) are the same, since only when they are the same, <code>Z</code> or <code>M's</code> property can be symmetric, Hermite symmetric or lower triangular.</p>
<p >The local product \(\mathcal{H}\)-matrix <code>Z</code> inherits the property of <code>M</code>, which can be either symmetric or lower triangular.</p>
<p >If the local \(\mathcal{H}\)-matrix <code>Z</code> is symmetric or lower triangular, its block type should be <code>diagonal_block</code> and an assertion is made about this fact.</p>
<p >Create the local product \(\mathcal{H}\)-matrix <code>Z</code> associated with the current block cluster node. During its initialization, memory will be allocated depending on its \(\mathcal{H}\)-matrix property and block type.</p>
<p >When either operand <code>M1</code> or <code>M2</code> is a leaf node, directly evaluation of their multiplication can be performed.</p>
<p >If the local product \(\mathcal{H}\)-matrix <code>Z</code> is expected to be symmetric or lower triangular, also set the property of the associated full matrix correspondingly. This operation is mandatory because the property of the local full matrix <code>ZF</code> is <code>general</code>, which has overwritten the property of <code>Z</code>.</p>
<p >In this case, both <code>M1</code> and <code>M2</code> have child submatrices.</p>
<p ><b>When we perform submatrix multiplication, we use a higher specified rank, since the results will be assembled into the larger matrix <code>Z</code> via pairwise formatted addition, during which the actual matrix rank may increase.</b></p>
<p >The submatrix block <code>Z.submatrices</code>[1], which is obtained from the cross type multiplication of <code>M1</code> and <code>M2</code>, will be evaluated in two scenarios:</p><ol type="1">
<li>when the \(\mathcal{H}\)-matrix <code>M</code> is not expected to be symmetric, Hermite symmetric or lower triangular;</li>
<li>when the \(\mathcal{H}\)-matrix <code>M</code> is required to be symmetric, Hermite symmetric or lower triangular a priori, and the product matrix <code>Z</code> should not be symmetric, Hermite symmetric or lower triangular.</li>
</ol>
<p >Assemble the local matrix <code>Z</code> to the product matrix <code>M</code>.</p>
<p >When the original matrix <code>M0</code> belongs to the near field, assemble the full matrix stored in <code>Z</code> directly into <code>M</code>.</p>
<p >When the original matrix <code>M0</code> does not belong to the near field, assemble the rank-k matrix stored in <code>Z</code> into <code>M</code> by first embedding then formatted addition, which has been implemented in the member function <code>assemble_from_rkmatrix</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l13910">13910</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l19656">HMatrix&lt; spacedim, Number &gt;::get_block_type()</a>, and <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l16558">h_h_mTmult_level_conserving()</a>.</p>

</div>
</div>
<a id="acca3547834f0e768bec39d63b7ab4288" name="acca3547834f0e768bec39d63b7ab4288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca3547834f0e768bec39d63b7ab4288">&#9670;&nbsp;</a></span>h_h_mTmult_from_leaf_node_for_parallel_cholesky()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mTmult_from_leaf_node_for_parallel_cholesky </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type_for_local_Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Here we make an assertion that the top level result \(\mathcal{H}\)-matrix <code>M0</code> should be a leaf node.</p>
<p >Create a block cluster node \(\tau\times\rho\) for the current local product matrix <code>Z</code>. Since this block cluster node will not be connected with other block cluster nodes in a block cluster tree, it has neither parent nor children and its level is set to zero.</p>
<p ><b>Because the current multiplication is \(M_1\cdot M_2^T\), the product \bctnode is built from \(\tau\) of \(M_1\) and \(\tau\) of \(M_2\).</b></p>
<p >Set the <code>is_near_field</code> flag of the block cluster node for the current local product matrix <code>Z</code> according to the matrix type of the initial leaf node \(\mathcal{H}\)-matrix <code>M0</code>, i.e. it inherits the <code>is_near_field</code> flag of the block cluster node for <code>M0</code>.</p>
<p >When the flag <code>is_result_matrix_store_tril_only</code> is true, determine if the \(\mathcal{H}\)-matrix property of the local product \(\mathcal{H}\)-matrix <code>Z</code> should be the same as that of <code>M</code> by checking if the index ranges of its \(\tau\) node and \(\sigma\) are the same, since only when they are the same, <code>Z</code> or <code>M's</code> property can be symmetric or lower triangular.</p>
<p >The local product \(\mathcal{H}\)-matrix <code>Z</code> inherits the property of <code>M</code>, which can be either symmetric or lower triangular.</p>
<p >If the local \(\mathcal{H}\)-matrix <code>Z</code> is symmetric or lower triangular, its block type should be <code>diagonal_block</code> and an assertion is made about this fact.</p>
<p >Create the local product \(\mathcal{H}\)-matrix <code>Z</code> associated with the current block cluster node. During its initialization, memory will be allocated depending on its \(\mathcal{H}\)-matrix property and block type.</p>
<p >When either operand <code>M1</code> or <code>M2</code> is a leaf node, directly evaluation of their multiplication can be performed.</p>
<p >If the local product \(\mathcal{H}\)-matrix <code>Z</code> is expected to be symmetric or lower triangular, also set the property of the associated full matrix correspondingly. This operation is mandatory because the property of the local full matrix <code>ZF</code> is <code>general</code>, which has overwritten the property of <code>Z</code>.</p>
<p >In this case, both <code>M1</code> and <code>M2</code> have child submatrices.</p>
<p ><b>When we perform submatrix multiplication, we use a higher specified rank, since the results will be assembled into the larger matrix <code>Z</code> via pairwise formatted addition, during which the actual matrix rank may increase.</b></p>
<p >The submatrix block <code>Z.submatrices</code>[1], which is obtained from the cross type multiplication of <code>M1</code> and <code>M2</code>, will be evaluated in two scenarios:</p><ol type="1">
<li>when the \(\mathcal{H}\)-matrix <code>M</code> is not expected to be symmetric, Hermite symmetric, or lower triangular;</li>
<li>when the \(\mathcal{H}\)-matrix <code>M</code> is required to be symmetric, Hermite symmetric or lower triangular a priori, and the product matrix <code>Z</code> should not be symmetric, Hermite symmetric or lower triangular.</li>
</ol>
<p >Assemble the product \(\mathcal{H}\)-matrix <code>Z</code> to the \(\mathcal{H}\)-matrix <code>M</code>.</p>
<p >When the original matrix <code>M0</code> belongs to the near field, assemble the full matrix stored in <code>Z</code> directly into <code>M</code>.</p>
<p >Only when the result matrix <code>M</code> is the top level result matrix <code>M0</code>, the mutex will be locked. Otherwise, the result matrix <code>M</code> is only a temporary object, which needs not be locked.</p>
<p >When the original matrix <code>M0</code> does not belong to the near field, assemble the rank-k matrix stored in <code>Z</code> into <code>M</code> by first embedding then formatted addition, which has been implemented in the member function <code>assemble_from_rkmatrix</code>.</p>
<p >Only when the result matrix <code>M</code> is the top level result matrix <code>M0</code>, the mutex will be locked. Otherwise, the result matrix <code>M</code> is only a temporary object, which needs not be locked.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l14735">14735</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a77204bf34aa9fc49787f01cc03c33696" name="a77204bf34aa9fc49787f01cc03c33696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77204bf34aa9fc49787f01cc03c33696">&#9670;&nbsp;</a></span>h_h_mTmult_level_conserving() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mTmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of two level-conserving \(\mathcal{H}\)-matrices with the second operand transposed. The result will multiplied by a factor and then added to the target matrix <code>M</code>, i.e. \(M = M + \alpha \cdot M_1 M_2^T\).</p>
<dl class="section note">
<dt>Note</dt>
<dd>It is required that an empty result matrix <code>M</code> should be created first with respect to a block cluster tree.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >All matrices (including the two operands and the product result) have substructure. Hence the \(\mathcal{H}\)-matrix multiplication type is cross.</p>
<p >N.B. When the \(\mathcal{H}\)-matrix is symmetric or lower triangular, it stores the lower triangular data only (including diagonal elements).</p>
<p >The submatrix block <code>M.submatrices</code>[1] will be evaluated in two scenarios:</p><ol type="1">
<li>when the result matrix is not expected to be symmetric, Hermite symmetric or lower triangular;</li>
<li>when the result matrix is required to be symmetric, Hermite symmetric or lower triangular a priori, then if the product matrix <code>M</code> is not symmetric, Hermite symmetric or lower triangular.</li>
</ol>
<p >This is the case when the product matrix <code>M</code> is further divided, while some of the two operands is a leaf. Hence the multiplication on this level can be directly evaluated.</p>
<ol type="1">
<li>When one of the operand matrix is a rank-k matrix, the product result is also a rank-k matrix.</li>
<li>When one of the operand matrix is a full matrix, the immediate product result is for sure a full matrix. However, because the block cluster associated with <code>M</code> is not a leaf, <code>M</code> should be represented as a rank-k matrix, which is converted from the full matrix. In the current implementation, this conversion has no accuracy loss.</li>
</ol>
<p >Add the result matrix <code>Z</code> into <code>M</code> and note that <code>Z</code> and <code>M</code> are associated with a same block cluster.</p>
<p >This addition is implemented by restricting <code>Z</code> to each leaf node of <code>M</code> first, then the addition operation will be performed on each leaf node respectively.</p>
<p ><b>The matrix <code>Z</code> should only be added into <code>M</code> but not simply overwrite <code>M</code>. This is because the result matrix <code>M</code> on the block cluster \(\tau\times\rho\) may be contributed from several multiplications with respect to a collection of \({\sigma_i}\), which forms a partition of the index set \(J\).</b></p>
<p >This is the first time of calling <code>h_h_mTmult_from_leaf_node</code>, where the second argument <code>M</code> is the product of <code>M1</code> and <code>M2</code>. If there are further recursive calls of this function, the second argument will be one level higher than the product of <code>M1</code> and <code>M2</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l16725">16725</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a480850d2b01f92d11d894a7930aed6fa" name="a480850d2b01f92d11d894a7930aed6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480850d2b01f92d11d894a7930aed6fa">&#9670;&nbsp;</a></span>h_h_mTmult_level_conserving() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mTmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of two level-conserving \(\mathcal{H}\)-matrices with the second operand transposed. The result will be added to the target matrix <code>M</code>, i.e. \(M = M + M_1 M_2^T\).</p>
<dl class="section note">
<dt>Note</dt>
<dd>It is required that an empty result matrix <code>M</code> should be created first with respect to a block cluster tree.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >All matrices (including the two operands and the product result) have substructure. Hence the \(\mathcal{H}\)-matrix multiplication type is cross.</p>
<p >N.B. When the \(\mathcal{H}\)-matrix is symmetric or lower triangular, it stores the lower triangular data only (including diagonal elements).</p>
<p >The submatrix block <code>M.submatrices</code>[1] will be evaluated in two scenarios:</p><ol type="1">
<li>when the result matrix is not expected to be symmetric, Hermite symmetric or lower triangular;</li>
<li>when the result matrix is required to be symmetric, Hermite symmetric or lower triangular a priori, then if the product matrix <code>M</code> is not symmetric, Hermite symmetric or lower triangular.</li>
</ol>
<p >This is the case when the product matrix <code>M</code> is further divided, while some of the two operands is a leaf. Hence the multiplication on this level can be directly evaluated.</p>
<ol type="1">
<li>When one of the operand matrix is a rank-k matrix, the product result is also a rank-k matrix.</li>
<li>When one of the operand matrix is a full matrix, the immediate product result is for sure a full matrix. However, because the block cluster associated with <code>M</code> is not a leaf, <code>M</code> should be represented as a rank-k matrix, which is converted from the full matrix. In the current implementation, this conversion has no accuracy loss.</li>
</ol>
<p >Add the result matrix <code>Z</code> into <code>M</code> and note that <code>Z</code> and <code>M</code> are associated with a same block cluster.</p>
<p >This addition is implemented by restricting <code>Z</code> to each leaf node of <code>M</code> first, then the addition operation will be performed on each leaf node respectively.</p>
<p ><b>The matrix <code>Z</code> should only be added into <code>M</code> but not simply overwrite <code>M</code>. This is because the result matrix <code>M</code> on the block cluster \(\tau\times\rho\) may be contributed from several multiplications with respect to a collection of \({\sigma_i}\), which forms a partition of the index set \(J\).</b></p>
<p >This is the first time of calling <code>h_h_mTmult_from_leaf_node</code>, where the second argument <code>M</code> is the product of <code>M1</code> and <code>M2</code>. If there are further recursive calls of this function, the second argument will be one level higher than the product of <code>M1</code> and <code>M2</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l16558">16558</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l29431">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l12038">f_h_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l11532">h_f_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l13910">h_h_mTmult_from_leaf_node()</a>, <a class="el" href="hmatrix_8h_source.html#l16558">h_h_mTmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l10601">h_rk_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04263">HMatrix&lt; spacedim, Number &gt;::property</a>, <a class="el" href="hmatrix_8h_source.html#l11119">rk_h_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l16558">h_h_mTmult_level_conserving()</a>, and <a class="el" href="hmatrix_8h_source.html#l29363">HMatrix&lt; spacedim, Number &gt;::mTmult_level_conserving()</a>.</p>

</div>
</div>
<a id="a8564c63e3c1e297183b945a9f9007429" name="a8564c63e3c1e297183b945a9f9007429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8564c63e3c1e297183b945a9f9007429">&#9670;&nbsp;</a></span>h_h_mTmult_level_conserving_for_parallel_cholesky()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mTmult_level_conserving_for_parallel_cholesky </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >All matrices (including the two operands and the product result) have substructure. Hence the \(\mathcal{H}\)-matrix multiplication type is cross.</p>
<p >N.B. When the \(\mathcal{H}\)-matrix is symmetric or lower triangular, it stores the lower triangular data only (including diagonal elements).</p>
<p >The submatrix block <code>M.submatrices</code>[1] will be evaluated in two scenarios:</p><ol type="1">
<li>when the result matrix is not expected to be symmetric, Hermite symmetric or lower triangular;</li>
<li>when the result matrix is required to be symmetric, Hermite symmetric or lower triangular a priori, then if the product matrix <code>M</code> is not symmetric, Hermite symmetric or lower triangular.</li>
</ol>
<p >This is the case when the product matrix <code>M</code> is further divided, while some of the two operands is a leaf. Hence the multiplication on this level can be directly evaluated.</p>
<ol type="1">
<li>When one of the operand matrix is a rank-k matrix, the product result is also a rank-k matrix.</li>
<li>When one of the operand matrix is a full matrix, the immediate product result is for sure a full matrix. However, because the block cluster associated with <code>M</code> is not a leaf, <code>M</code> should be represented as a rank-k matrix, which is converted from the full matrix. In the current implementation, this conversion has no accuracy loss.</li>
</ol>
<p >Add the result matrix <code>Z</code> into <code>M</code> and note that <code>Z</code> and <code>M</code> are associated with a same block cluster.</p>
<p >This addition is implemented by restricting <code>Z</code> to each leaf node of <code>M</code> first, then the addition operation will be performed on each leaf node respectively.</p>
<p ><b>The matrix <code>Z</code> should only be added into <code>M</code> but not simply overwrite <code>M</code>. This is because the result matrix <code>M</code> on the block cluster \(\tau\times\rho\) may be contributed from several multiplications with respect to a collection of \({\sigma_i}\), which forms a partition of the index set \(J\).</b></p>
<p >This is the first time of calling <code>h_h_mTmult_from_leaf_node</code>, where the second argument <code>M</code> is the product of <code>M1</code> and <code>M2</code>. If there are further recursive calls of this function, the second argument will be one level higher than the product of <code>M1</code> and <code>M2</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l16887">16887</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ac4e7f24d7d111a0e2257637604c4a9f3" name="ac4e7f24d7d111a0e2257637604c4a9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e7f24d7d111a0e2257637604c4a9f3">&#9670;&nbsp;</a></span>h_h_Tmmult_from_leaf_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_Tmmult_from_leaf_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type_for_local_Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Scaled \(\mathcal{H}\)-matrix- \(\mathcal{H}\)-matrix multiplication with the first operand transposed, when the product matrix belongs to the leaf set of the target block cluster tree.</p>
<p >This function implements the recursive <code>MMR</code> algorithm in (7.26) in Hackbusch's \(\mathcal{H}\)-matrix book.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M0</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">block_type_for_local_Z</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Here we make an assertion that the top level result \(\mathcal{H}\)-matrix <code>M0</code> should be a leaf node.</p>
<p >Create a block cluster node \(\tau\times\rho\) for the current local product matrix <code>Z</code>. Since this block cluster node will not be connected with other block cluster nodes in a block cluster tree, it has neither parent nor children and its level is set to zero.</p>
<p ><b>Because the current multiplication is \(M_1^T\cdot M_2\), the product \bctnode is built from \(\sigma\) of \(M_1\) and \(\sigma\) of \(M_2\).</b></p>
<p >Set the <code>is_near_field</code> flag of the block cluster node for the current local product matrix <code>Z</code> according to the matrix type of the initial leaf node \(\mathcal{H}\)-matrix <code>M0</code>, i.e. it inherits the <code>is_near_field</code> flag of the block cluster node for <code>M0</code>.</p>
<p >When the flag <code>is_result_matrix_store_tril_only</code> is true, determine if the \(\mathcal{H}\)-matrix property of the local product \(\mathcal{H}\)-matrix <code>Z</code> should be the same as that of <code>M</code> by checking if the index ranges of its \(\tau\) node and \(\sigma\) are the same, since only when they are the same, <code>Z</code> or <code>M's</code> property can be symmetric or lower triangular.</p>
<p >The local product \(\mathcal{H}\)-matrix <code>Z</code> inherits the property of <code>M</code>, which can be either symmetric or lower triangular.</p>
<p >If the local \(\mathcal{H}\)-matrix <code>Z</code> is symmetric or lower triangular, its block type should be <code>diagonal_block</code> and an assertion is made about this fact.</p>
<p >Create the local product \(\mathcal{H}\)-matrix <code>Z</code> associated with the current block cluster node. During its initialization, memory will be allocated depending on its \(\mathcal{H}\)-matrix property and block type.</p>
<p >When either operand <code>M1</code> or <code>M2</code> is a leaf node, directly evaluation of their multiplication can be performed.</p>
<p >If the local product \(\mathcal{H}\)-matrix <code>Z</code> is expected to be symmetric or lower triangular, also set the property of the associated full matrix correspondingly. This operation is mandatory because the property of the local full matrix <code>ZF</code> is <code>general</code>, which has overwritten the property of <code>Z</code>.</p>
<p >In this case, both <code>M1</code> and <code>M2</code> have child submatrices.</p>
<p ><b>When we perform submatrix multiplication, we use a higher specified rank, since the results will be assembled into the larger matrix <code>Z</code> via pairwise formatted addition, during which the actual matrix rank may increase.</b></p>
<p >The submatrix block <code>Z.submatrices</code>[1], which is obtained from the cross type multiplication of <code>M1</code> and <code>M2</code>, will be evaluated in two scenarios:</p><ol type="1">
<li>when the \(\mathcal{H}\)-matrix <code>M</code> is not expected to be symmetric, Hermite symmetric or lower triangular;</li>
<li>when the \(\mathcal{H}\)-matrix <code>M</code> is required to be symmetric, Hermite symmetric or lower triangular a priori, and the product matrix <code>Z</code> should not be symmetric, Hermite symmetric or lower triangular.</li>
</ol>
<p >Assemble the local matrix <code>Z</code> to the product matrix <code>M</code>.</p>
<p >When the original matrix <code>M0</code> belongs to the near field, assemble the full matrix stored in <code>Z</code> directly into <code>M</code>.</p>
<p >When the original matrix <code>M0</code> does not belong to the near field, assemble the rank-k matrix stored in <code>Z</code> into <code>M</code> by first embedding then formatted addition, which has been implemented in the member function <code>assemble_from_rkmatrix</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l15626">15626</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a15b305bbf2fe7e513d4b06cff7b62874" name="a15b305bbf2fe7e513d4b06cff7b62874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b305bbf2fe7e513d4b06cff7b62874">&#9670;&nbsp;</a></span>h_h_Tmmult_from_leaf_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_Tmmult_from_leaf_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type_for_local_Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >\(\mathcal{H}\)-matrix- \(\mathcal{H}\)-matrix multiplication with the first operand transposed, when the product matrix belongs to the leaf set of the target block cluster tree.</p>
<p >This function implements the recursive <code>MMR</code> algorithm in (7.26) in Hackbusch's \(\mathcal{H}\)-matrix book.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M0</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">block_type_for_local_Z</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Here we make an assertion that the top level result \(\mathcal{H}\)-matrix <code>M0</code> should be a leaf node.</p>
<p >Create a block cluster node \(\tau\times\rho\) for the current local product matrix <code>Z</code>. Since this block cluster node will not be connected with other block cluster nodes in a block cluster tree, it has neither parent nor children and its level is set to zero.</p>
<p ><b>Because the current multiplication is \(M_1^T\cdot M_2\), the product \bctnode is built from \(\sigma\) of \(M_1\) and \(\sigma\) of \(M_2\).</b></p>
<p >Set the <code>is_near_field</code> flag of the block cluster node for the current local product matrix <code>Z</code> according to the matrix type of the initial leaf node \(\mathcal{H}\)-matrix <code>M0</code>, i.e. it inherits the <code>is_near_field</code> flag of the block cluster node for <code>M0</code>.</p>
<p >When the flag <code>is_result_matrix_store_tril_only</code> is true, determine if the \(\mathcal{H}\)-matrix property of the local product \(\mathcal{H}\)-matrix <code>Z</code> should be the same as that of <code>M</code> by checking if the index ranges of its \(\tau\) node and \(\sigma\) are the same, since only when they are the same, <code>Z</code> or <code>M's</code> property can be symmetric or lower triangular.</p>
<p >The local product \(\mathcal{H}\)-matrix <code>Z</code> inherits the property of <code>M</code>, which can be either symmetric or lower triangular.</p>
<p >If the local \(\mathcal{H}\)-matrix <code>Z</code> is symmetric or lower triangular, its block type should be <code>diagonal_block</code> and an assertion is made about this fact.</p>
<p >Create the local product \(\mathcal{H}\)-matrix <code>Z</code> associated with the current block cluster node. During its initialization, memory will be allocated depending on its \(\mathcal{H}\)-matrix property and block type.</p>
<p >When either operand <code>M1</code> or <code>M2</code> is a leaf node, directly evaluation of their multiplication can be performed.</p>
<p >If the local product \(\mathcal{H}\)-matrix <code>Z</code> is expected to be symmetric or lower triangular, also set the property of the associated full matrix correspondingly. This operation is mandatory because the property of the local full matrix <code>ZF</code> is <code>general</code>, which has overwritten the property of <code>Z</code>.</p>
<p >In this case, both <code>M1</code> and <code>M2</code> have child submatrices.</p>
<p ><b>When we perform submatrix multiplication, we use a higher specified rank, since the results will be assembled into the larger matrix <code>Z</code> via pairwise formatted addition, during which the actual matrix rank may increase.</b></p>
<p >The submatrix block <code>Z.submatrices</code>[1], which is obtained from the cross type multiplication of <code>M1</code> and <code>M2</code>, will be evaluated in two scenarios:</p><ol type="1">
<li>when the \(\mathcal{H}\)-matrix <code>M</code> is not expected to be symmetric, Hermite symmetric or lower triangular;</li>
<li>when the \(\mathcal{H}\)-matrix <code>M</code> is required to be symmetric, Hermite symmetric or lower triangular a priori, and the product matrix <code>Z</code> should not be symmetric, Hermite symmetric or lower triangular.</li>
</ol>
<p >Assemble the local matrix <code>Z</code> to the product matrix <code>M</code>.</p>
<p >When the original matrix <code>M0</code> belongs to the near field, assemble the full matrix stored in <code>Z</code> directly into <code>M</code>.</p>
<p >When the original matrix <code>M0</code> does not belong to the near field, assemble the rank-k matrix stored in <code>Z</code> into <code>M</code> by first embedding then formatted addition, which has been implemented in the member function <code>assemble_from_rkmatrix</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l15219">15219</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l19656">HMatrix&lt; spacedim, Number &gt;::get_block_type()</a>, and <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17073">h_h_Tmmult_level_conserving()</a>.</p>

</div>
</div>
<a id="a7a2f95b99f9cad38f0648b612c724da8" name="a7a2f95b99f9cad38f0648b612c724da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2f95b99f9cad38f0648b612c724da8">&#9670;&nbsp;</a></span>h_h_Tmmult_level_conserving() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_Tmmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Scaled multiplication of two level-conserving \(\mathcal{H}\)-matrices with the first operand transposed. The result will be added to the target matrix <code>M</code>, i.e. \(M = M + \alpha M_1^T M_2\).</p>
<dl class="section note">
<dt>Note</dt>
<dd>It is required that an empty result matrix <code>M</code> should be created first with respect to a block cluster tree.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >All matrices (including the two operands and the product result) have substructure. Hence the \(\mathcal{H}\)-matrix multiplication type is cross.</p>
<p >N.B. When the \(\mathcal{H}\)-matrix is symmetric or lower triangular, it stores the lower triangular data only (including diagonal elements).</p>
<p >The submatrix block <code>M.submatrices</code>[1] will be evaluated in two scenarios:</p><ol type="1">
<li>when the result matrix is not expected to be symmetric, Hermite symmetric or lower triangular;</li>
<li>when the result matrix is required to be symmetric, Hermite symmetric or lower triangular a priori, then if the product matrix <code>M</code> is not symmetric, Hermite symmetric or lower triangular.</li>
</ol>
<p >This is the case when the product matrix <code>M</code> is further divided, while at least one of the two operands is a leaf. Hence the multiplication on this level can be directly evaluated.</p>
<ol type="1">
<li>When one of the operand matrix is a rank-k matrix, the product result is also a rank-k matrix.</li>
<li>When one of the operand matrix is a full matrix, the immediate product result is for sure a full matrix. However, because the block cluster associated with <code>M</code> is not a leaf, <code>M</code> should be represented as a rank-k matrix, which is converted from the full matrix. In the current implementation, this conversion has no accuracy loss.</li>
</ol>
<p >Add the result matrix <code>Z</code> into <code>M</code> and note that <code>Z</code> and <code>M</code> are associated with a same block cluster.</p>
<p >This addition is implemented by restricting <code>Z</code> to each leaf node of <code>M</code> first, then the addition operation will be performed on each leaf node respectively.</p>
<p ><b>The matrix <code>Z</code> should only be added into <code>M</code> but not simply overwrite <code>M</code>. This is because the result matrix <code>M</code> on the block cluster \(\tau\times\rho\) may be contributed from several multiplications with respect to a collection of \({\sigma_i}\), which forms a partition of the index set \(J\).</b></p>
<p >This is the first time of calling <code>h_h_mmult_from_leaf_node</code>, where the second argument <code>M</code> is the product of <code>M1</code> and <code>M2</code>. If there are further recursive calls of this function, the second argument will be one level higher than the product of <code>M1</code> and <code>M2</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17241">17241</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aa59c59f9ec468f5fd3e122226080f7e4" name="aa59c59f9ec468f5fd3e122226080f7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59c59f9ec468f5fd3e122226080f7e4">&#9670;&nbsp;</a></span>h_h_Tmmult_level_conserving() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_Tmmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of two level-conserving \(\mathcal{H}\)-matrices with the first operand transposed. The result will be added to the target matrix <code>M</code>, i.e. \(M = M + M_1^T M_2\).</p>
<dl class="section note">
<dt>Note</dt>
<dd>It is required that an empty result matrix <code>M</code> should be created first with respect to a block cluster tree.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >All matrices (including the two operands and the product result) have substructure. Hence the \(\mathcal{H}\)-matrix multiplication type is cross.</p>
<p >N.B. When the \(\mathcal{H}\)-matrix is symmetric or lower triangular, it stores the lower triangular data only (including diagonal elements).</p>
<p >The submatrix block <code>M.submatrices</code>[1] will be evaluated in two scenarios:</p><ol type="1">
<li>when the result matrix is not expected to be symmetric, Hermite symmetric or lower triangular;</li>
<li>when the result matrix is required to be symmetric, Hermite symmetric or lower triangular a priori, then if the product matrix <code>M</code> is not symmetric, Hermite symmetric or lower triangular.</li>
</ol>
<p >This is the case when the product matrix <code>M</code> is further divided, while at least one of the two operands is a leaf. Hence the multiplication on this level can be directly evaluated.</p>
<ol type="1">
<li>When one of the operand matrix is a rank-k matrix, the product result is also a rank-k matrix.</li>
<li>When one of the operand matrix is a full matrix, the immediate product result is for sure a full matrix. However, because the block cluster associated with <code>M</code> is not a leaf, <code>M</code> should be represented as a rank-k matrix, which is converted from the full matrix. In the current implementation, this conversion has no accuracy loss.</li>
</ol>
<p >Add the result matrix <code>Z</code> into <code>M</code> and note that <code>Z</code> and <code>M</code> are associated with a same block cluster.</p>
<p >This addition is implemented by restricting <code>Z</code> to each leaf node of <code>M</code> first, then the addition operation will be performed on each leaf node respectively.</p>
<p ><b>The matrix <code>Z</code> should only be added into <code>M</code> but not simply overwrite <code>M</code>. This is because the result matrix <code>M</code> on the block cluster \(\tau\times\rho\) may be contributed from several multiplications with respect to a collection of \({\sigma_i}\), which forms a partition of the index set \(J\).</b></p>
<p >This is the first time of calling <code>h_h_mmult_from_leaf_node</code>, where the second argument <code>M</code> is the product of <code>M1</code> and <code>M2</code>. If there are further recursive calls of this function, the second argument will be one level higher than the product of <code>M1</code> and <code>M2</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17073">17073</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l29431">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l12107">f_h_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l11603">h_f_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l15219">h_h_Tmmult_from_leaf_node()</a>, <a class="el" href="hmatrix_8h_source.html#l17073">h_h_Tmmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l10751">h_rk_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04263">HMatrix&lt; spacedim, Number &gt;::property</a>, <a class="el" href="hmatrix_8h_source.html#l11273">rk_h_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17073">h_h_Tmmult_level_conserving()</a>, and <a class="el" href="hmatrix_8h_source.html#l29404">HMatrix&lt; spacedim, Number &gt;::Tmmult_level_conserving()</a>.</p>

</div>
</div>
<a id="a9b93b5c19ef281408c6ed1e6460462e5" name="a9b93b5c19ef281408c6ed1e6460462e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b93b5c19ef281408c6ed1e6460462e5">&#9670;&nbsp;</a></span>h_rk_mmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_rk_mmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes and the result is scaled by a factor, where the second one <code>M2</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix.</p>
<p >The arithmetic operation to be performed is </p><p class="formulaDsp">
\[
M = \alpha \cdot M_1 \cdot M_2 = \alpha \cdot M_1 (A B^T) = \alpha \cdot
(M_1 A) B^T = \alpha \cdot A&#39; B^T, \]
</p>
<p> where \(A&#39; = M_1 A\) is calculated as a series of \(\mathcal{H}\)-matrix/vector multiplications. For details, </p><p class="formulaDsp">
\[ M_1 A =
M_1 \begin{bmatrix} a_{\sigma,1} &amp; \cdots &amp; a_{\sigma,r} \end{bmatrix} =
\begin{bmatrix}
M_1 a_{\sigma,1} &amp; \cdots &amp; M_1 a_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
a&#39;_{\tau,1} &amp; \cdots &amp; a&#39;_{\tau,r}
\end{bmatrix}.
\]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a temporary <code>Vector</code> storing a column \(a_{\sigma,j}\) in the <code>A</code> component of <code>M2</code> and another <code>Vector</code> \(a&#39;_{\tau,j}\) storing the \(\mathcal{H}\)-matrix/vector product \(M_1 \cdot a_{\sigma,j}\).</p>
<p >Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M2</code>. Its <code>B</code> component matrix is the same as that of <code>M2</code>.</p>
<p >Then we calculate the <code>A</code> component matrix of <code>M</code>, which is <code>M1*M2</code>.A.</p>
<p ><b>Since the following <code>vmult</code> will compute \(y = y + M x\), <code>result_vect</code> should be reset to zero beforehand.</b></p>
<p >Fill the result vector into the <code>A</code> component matrix of <code>M</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l10518">10518</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="afee9050ba0b224929bcbf99484385a59" name="afee9050ba0b224929bcbf99484385a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee9050ba0b224929bcbf99484385a59">&#9670;&nbsp;</a></span>h_rk_mmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_rk_mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the second one <code>M2</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix.</p>
<p >The arithmetic operation to be performed is </p><p class="formulaDsp">
\[
M = M_1 \cdot M_2 = M_1 (A B^T) = (M_1 A) B^T = A&#39; B^T,
\]
</p>
<p> where \(A&#39; = M_1 A\) is calculated as a series of \(\mathcal{H}\)-matrix/vector multiplications. For details, </p><p class="formulaDsp">
\[
M_1 A = M_1
\begin{bmatrix}
a_{\sigma,1} &amp; \cdots &amp; a_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
M_1 a_{\sigma,1} &amp; \cdots &amp; M_1 a_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
a&#39;_{\tau,1} &amp; \cdots &amp; a&#39;_{\tau,r}
\end{bmatrix}.
\]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a temporary <code>Vector</code> storing a column \(a_{\sigma,j}\) in the <code>A</code> component of <code>M2</code> and another <code>Vector</code> \(a&#39;_{\tau,j}\) storing the \(\mathcal{H}\)-matrix/vector product \(M_1 \cdot a_{\sigma,j}\).</p>
<p >Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M2</code>. Its <code>B</code> component matrix is the same as that of <code>M2</code>.</p>
<p >Then we calculate the <code>A</code> component matrix of <code>M</code>, which is <code>M1*M2</code>.A.</p>
<p >Fill the result vector into the <code>A</code> component matrix of <code>M</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l10444">10444</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="rkmatrix_8h_source.html#l01140">RkMatrix&lt; Number &gt;::formal_rank</a>, <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="rkmatrix_8h_source.html#l01145">RkMatrix&lt; Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="rkmatrix_8h_source.html#l01150">RkMatrix&lt; Number &gt;::n</a>, <a class="el" href="rkmatrix_8h_source.html#l01134">RkMatrix&lt; Number &gt;::rank</a>, <a class="el" href="rkmatrix_8h_source.html#l02445">RkMatrix&lt; Number &gt;::reinit()</a>, and <a class="el" href="hmatrix_8h_source.html#l21052">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l11669">h_f_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l16039">h_h_mmult_level_conserving()</a>, and <a class="el" href="hmatrix_8h_source.html#l10890">h_rk_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="a84df06910d958d84ac8c544f9a8423a8" name="a84df06910d958d84ac8c544f9a8423a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84df06910d958d84ac8c544f9a8423a8">&#9670;&nbsp;</a></span>h_rk_mmult_for_h_h_mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_rk_mmult_for_h_h_mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_M1M2_last_in_M_Sigma_P</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the second one <code>M2</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix. This function is to be called by the matrix-matrix multiplication function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l10890">10890</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l10444">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l36264">HMatrix&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list()</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04403">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="hmatrix_8h_source.html#l04391">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="hmatrix_8h_source.html#l04397">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l28729">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_reduction()</a>.</p>

</div>
</div>
<a id="acfbe51ba1fe5ea83d5910d1f893d589f" name="acfbe51ba1fe5ea83d5910d1f893d589f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbe51ba1fe5ea83d5910d1f893d589f">&#9670;&nbsp;</a></span>h_rk_mTmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_rk_mTmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes with the second operand being transposed, where the second operand <code>M2</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix. The result will be scaled by a factor.</p>
<p >The arithmetic operation to be performed is </p><p class="formulaDsp">
\[
M = \alpha \cdot M_1 \cdot M_2^T = \alpha \cdot M_1 (A B^T)^T = \alpha
\cdot (M_1 B) A^T = \alpha \cdot A&#39; B&#39;^T, \]
</p>
<p> where \(A&#39; = M_1 B\) is calculated as a series of \(\mathcal{H}\)-matrix/vector multiplications, and \(B&#39; =
A\). For details, </p><p class="formulaDsp">
\[ M_1 B = M_1 \begin{bmatrix} b_{\sigma,1} &amp; \cdots &amp;
b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_1 b_{\sigma,1} &amp; \cdots &amp;
M_1 b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} b&#39;_{\tau,1} &amp; \cdots &amp;
b&#39;_{\tau,r} \end{bmatrix}. \]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a temporary <code>Vector</code> storing a column \(b_{\sigma,j}\) in the <code>B</code> component of <code>M2</code> and another <code>Vector</code> \(b&#39;_{\tau,j}\) storing the \(\mathcal{H}\)-matrix/vector product \(M_1 \cdot b_{\sigma,j}\).</p>
<p >Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M2</code>. Its <code>B</code> component matrix is the same as that of <code>M2</code>.</p>
<p >Then we calculate the <code>A</code> component matrix of <code>M</code>, which is <code>M1*M2</code>.B.</p>
<p >Fill the result vector into the <code>A</code> component matrix of <code>M</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l10672">10672</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a4d0d61778a104b7e1452c3b9be60b5e4" name="a4d0d61778a104b7e1452c3b9be60b5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0d61778a104b7e1452c3b9be60b5e4">&#9670;&nbsp;</a></span>h_rk_mTmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_rk_mTmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes with the second operand being transposed, where the second operand <code>M2</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix.</p>
<p >The arithmetic operation to be performed is </p><p class="formulaDsp">
\[
M = M_1 \cdot M_2^T = M_1 (A B^T)^T = (M_1 B) A^T = A&#39; B&#39;^T,
\]
</p>
<p> where \(A&#39; = M_1 B\) is calculated as a series of \(\mathcal{H}\)-matrix/vector multiplications, and \(B&#39; = A\). For details, </p><p class="formulaDsp">
\[
M_1 B = M_1
\begin{bmatrix}
b_{\sigma,1} &amp; \cdots &amp; b_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
M_1 b_{\sigma,1} &amp; \cdots &amp; M_1 b_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
b&#39;_{\tau,1} &amp; \cdots &amp; b&#39;_{\tau,r}
\end{bmatrix}.
\]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a temporary <code>Vector</code> storing a column \(b_{\sigma,j}\) in the <code>B</code> component of <code>M2</code> and another <code>Vector</code> \(b&#39;_{\tau,j}\) storing the \(\mathcal{H}\)-matrix/vector product \(M_1 \cdot b_{\sigma,j}\).</p>
<p >Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M2</code>. Its <code>B</code> component matrix is the same as that of <code>M2</code>.</p>
<p >Then we calculate the <code>A</code> component matrix of <code>M</code>, which is <code>M1*M2</code>.B.</p>
<p >Fill the result vector into the <code>A</code> component matrix of <code>M</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l10601">10601</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="rkmatrix_8h_source.html#l01140">RkMatrix&lt; Number &gt;::formal_rank</a>, <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="rkmatrix_8h_source.html#l01145">RkMatrix&lt; Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="rkmatrix_8h_source.html#l01150">RkMatrix&lt; Number &gt;::n</a>, <a class="el" href="rkmatrix_8h_source.html#l01134">RkMatrix&lt; Number &gt;::rank</a>, <a class="el" href="rkmatrix_8h_source.html#l02445">RkMatrix&lt; Number &gt;::reinit()</a>, and <a class="el" href="hmatrix_8h_source.html#l21052">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l11746">h_f_mTmult()</a>, and <a class="el" href="hmatrix_8h_source.html#l16558">h_h_mTmult_level_conserving()</a>.</p>

</div>
</div>
<a id="a29a0160d0d1e6afa4f14892c4560e058" name="a29a0160d0d1e6afa4f14892c4560e058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a0160d0d1e6afa4f14892c4560e058">&#9670;&nbsp;</a></span>h_rk_Tmmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_rk_Tmmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the scaled product of two \(\mathcal{H}\)-matrix nodes with the first operand being transposed, where the second one <code>M2</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix.</p>
<p >The arithmetic operation to be performed is</p>
<p class="formulaDsp">
\[
M = \alpha M_1^T \cdot M_2 = \alpha M_1^T (A B^T) = \alpha (M_1^T A) B^T =
\alpha A&#39; B^T, \]
</p>
<p >where \(A&#39; = M_1^T A\) is calculated as a series of transposed- \(\mathcal{H}\)-matrix/vector multiplications. For details, </p><p class="formulaDsp">
\[
M_1^T A = M_1^T
\begin{bmatrix}
a_{\sigma,1} &amp; \cdots &amp; a_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
M_1^T a_{\sigma,1} &amp; \cdots &amp; M_1^T a_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
a&#39;_{\tau,1} &amp; \cdots &amp; a&#39;_{\tau,r}
\end{bmatrix}.
\]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a temporary <code>Vector</code> storing a column \(a_{\sigma,j}\) in the <code>A</code> component of <code>M2</code> and another <code>Vector</code> \(a&#39;_{\tau,j}\) storing the transposed- \(\mathcal{H}\)-matrix/vector product \(M_1^T \cdot a_{\sigma,j}\).</p>
<p >Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M2</code>. Its <code>B</code> component matrix is the same as that of <code>M2</code>.</p>
<p >Then we calculate the <code>A</code> component matrix of <code>M</code>, which is <code>M1^T*M2</code>.A.</p>
<p >Fill the result vector into the <code>A</code> component matrix of <code>M</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l10832">10832</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a2b37e59459e75613a9e95f72757b8e1e" name="a2b37e59459e75613a9e95f72757b8e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b37e59459e75613a9e95f72757b8e1e">&#9670;&nbsp;</a></span>h_rk_Tmmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_rk_Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes with the first operand being transposed, where the second one <code>M2</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix.</p>
<p >The arithmetic operation to be performed is </p><p class="formulaDsp">
\[
M = M_1^T \cdot M_2 = M_1^T (A B^T) = (M_1^T A) B^T = A&#39; B^T,
\]
</p>
<p> where \(A&#39; = M_1^T A\) is calculated as a series of transposed- \(\mathcal{H}\)-matrix/vector multiplications. For details, </p><p class="formulaDsp">
\[
M_1^T A = M_1^T
\begin{bmatrix}
a_{\sigma,1} &amp; \cdots &amp; a_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
M_1^T a_{\sigma,1} &amp; \cdots &amp; M_1^T a_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
a&#39;_{\tau,1} &amp; \cdots &amp; a&#39;_{\tau,r}
\end{bmatrix}.
\]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a temporary <code>Vector</code> storing a column \(a_{\sigma,j}\) in the <code>A</code> component of <code>M2</code> and another <code>Vector</code> \(a&#39;_{\tau,j}\) storing the transposed- \(\mathcal{H}\)-matrix/vector product \(M_1^T \cdot a_{\sigma,j}\).</p>
<p >Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M2</code>. Its <code>B</code> component matrix is the same as that of <code>M2</code>.</p>
<p >Then we calculate the <code>A</code> component matrix of <code>M</code>, which is <code>M1^T*M2</code>.A.</p>
<p >Fill the result vector into the <code>A</code> component matrix of <code>M</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l10751">10751</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="rkmatrix_8h_source.html#l01140">RkMatrix&lt; Number &gt;::formal_rank</a>, <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="rkmatrix_8h_source.html#l01145">RkMatrix&lt; Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="rkmatrix_8h_source.html#l01150">RkMatrix&lt; Number &gt;::n</a>, <a class="el" href="rkmatrix_8h_source.html#l01134">RkMatrix&lt; Number &gt;::rank</a>, <a class="el" href="rkmatrix_8h_source.html#l02445">RkMatrix&lt; Number &gt;::reinit()</a>, and <a class="el" href="hmatrix_8h_source.html#l23665">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l11823">h_f_Tmmult()</a>, and <a class="el" href="hmatrix_8h_source.html#l17073">h_h_Tmmult_level_conserving()</a>.</p>

</div>
</div>
<a id="aa4d08a58ab3946a4c2912f3b0af531f7" name="aa4d08a58ab3946a4c2912f3b0af531f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d08a58ab3946a4c2912f3b0af531f7">&#9670;&nbsp;</a></span>hmatrix_solve_cholesky()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hmatrix_solve_cholesky </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17589">17589</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a88b34ad37e3ad46b0fc514ad4a428e18" name="a88b34ad37e3ad46b0fc514ad4a428e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b34ad37e3ad46b0fc514ad4a428e18">&#9670;&nbsp;</a></span>hmatrix_solve_lu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hmatrix_solve_lu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17576">17576</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ac0833d8503c82e9bea137e0145a61d31" name="ac0833d8503c82e9bea137e0145a61d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0833d8503c82e9bea137e0145a61d31">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildren() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_node_property</em> = <code>HMatrixSupport::Property::general</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Recursively construct the children of an \(\mathcal{H}\)-matrix with respect to a block cluster tree by starting from a tree node which is associated with the current \(\mathcal{H}\)-matrix. There is no rank truncation to the rank-k matrices.</p>
<p >The matrices in the leaf set are initialized with the data in the given global full matrix <code>M</code>, which is created on the complete block cluster index set \(I \times J\) and whose elements should be accessed via indices stored in the block cluster.</p>
<p >During the recursive calling of this function, the source data matrix <code>M</code> is kept intact, which will not be restricted to small matrix blocks.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The full matrix <code>M</code> is global, while <code>hmat</code> may not be global, but only a block in the global matrix, and <code>bc_node</code> in this case is not the root node of the block cluster tree.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td>Pointer to the current \(\mathcal{H}\)-matrix node, <b>which has already been created on the heap but with its internal data left empty.</b> </td></tr>
    <tr><td class="paramname">bc_node</td><td>Pointer to a <a class="el" href="classTreeNode.html" title="Class for general tree node.">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree.">BlockClusterTree</a>, which is to be associated with <code>hmat</code>. It is not necessarily the root node. </td></tr>
    <tr><td class="paramname">M</td><td>The global full matrix containing all the data required to initialize the \(\mathcal{H}\)-matrix. </td></tr>
  </table>
  </dd>
</dl>
<p >Link <code>hmat</code> with <code>bc_node</code>.</p>
<p >Link row and column indices.</p>
<p >Update the matrix dimension of <code>hmat</code>.</p>
<p >When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>. Then we will continue constructing hierarchical submatrices.</p>
<p >Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p >Set the state of the child \(\mathcal{H}\)-matrix, which is the same as its parent.</p>
<p >Set the block type of the child \(\mathcal{H}\)-matrix, which depends on the block type of its parent.</p>
<p >When the current \(\mathcal{H}\)-matrix block is <code>undefined_block</code>, all child \(\mathcal{H}\)-matrices are <code>undefined_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>diagonal_block</code>, the first and fourth child \(\mathcal{H}\)-matrices are <code>diagonal_block</code>, while the second child \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code> and the third child \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>upper_triangular_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>lower_triangular_block</code>.</p>
<p >Set the property of the child \(\mathcal{H}\)-matrix, which depends on the property of its parent.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>general</code>, all of its children have the same property <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>symmetric</code>, only those diagonal submatrices are <code>symmetric</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>hermite_symmetric</code>, only those diagonal submatrices are <code>hermite_symmetric</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>upper_triangular</code>, only those diagonal submatrices are <code>upper_triangular</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>lower_triangular</code>, only those diagonal submatrices are <code>lower_triangular</code>, while the other submatrices are <code>general</code>.</p>
<p >Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p >Set the pointer to the parent \(\mathcal{H}\)-matrix node of the current child \(\mathcal{H}\)-matrix node.</p>
<p >Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, <code>hmat</code> should be represented as a <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>. When the block cluster belongs to the far field, <code>hmat</code> should be represented as an <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the current \(\mathcal{H}\)-matrix.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>general</code> property, all \(\mathcal{H}\)-matrix nodes in the leaf set should be created with allocated memory.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>symmetric</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or lower triangular part of the original \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be a symmetric full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>symmetric</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is symmetric to the corresponding block in the lower triangular part.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>hermite_symmetric</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or lower triangular part of the original \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be an Hermite symmetric full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>hermite_symmetric</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is symmetric to the corresponding block in the lower triangular part.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>lower_triangular</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or lower triangular part in the top level \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be a lower triangular full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>lower_triangular</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is zero-valued.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>upper_triangular</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or upper triangular part in the top level \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be a upper triangular full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>upper_triangular</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is zero-valued.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l06601">6601</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l04289">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="hmatrix_8h_source.html#l04263">HMatrix&lt; spacedim, Number &gt;::property</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04257">HMatrix&lt; spacedim, Number &gt;::state</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="hmatrix_8h_source.html#l04323">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a1543c003a94f46c954b2b2b56c83a940" name="a1543c003a94f46c954b2b2b56c83a940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1543c003a94f46c954b2b2b56c83a940">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildren() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_row_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_col_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_node_property</em> = <code>HMatrixSupport::Property::general</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Recursively construct the children of an \(\mathcal{H}\)-matrix with respect to a block cluster tree by starting from a tree node which is associated with the current \(\mathcal{H}\)-matrix. There is no rank truncation to the rank-k matrices.</p>
<p >The matrices in the leaf set are initialized with the data in the given full matrix <code>M</code>, which is created on the block cluster index set \(\tau \times
\sigma\) associated with the current \(\mathcal{H}\)-matrix. Hence, this full matrix is just a block of the original global full matrix created on the block cluster index set \(I \times J\).</p>
<p >During the recursive calling of this function, the source data matrix <code>M</code> is kept intact, which will not be restricted to small matrix blocks. </p>
<p >Link <code>hmat</code> with <code>bc_node</code>.</p>
<p >Link row and column indices.</p>
<p >Update the matrix dimension of <code>hmat</code>.</p>
<p >When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>. Then we will continue constructing hierarchical submatrices.</p>
<p >Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p >Set the state of the child \(\mathcal{H}\)-matrix, which is the same as its parent.</p>
<p >Set the block type of the child \(\mathcal{H}\)-matrix, which depends on the block type of its parent.</p>
<p >When the current \(\mathcal{H}\)-matrix block is <code>undefined_block</code>, all child \(\mathcal{H}\)-matrices are <code>undefined_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>diagonal_block</code>, the first and fourth child \(\mathcal{H}\)-matrices are <code>diagonal_block</code>, while the second child \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code> and the third child \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>upper_triangular_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>lower_triangular_block</code>.</p>
<p >Set the property of the child \(\mathcal{H}\)-matrix, which depends on the property of its parent.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>general</code>, all of its children have the same property <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>symmetric</code>, only those diagonal submatrices are <code>symmetric</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>hermite_symmetric</code>, only those diagonal submatrices are <code>hermite_symmetric</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>upper_triangular</code>, only those diagonal submatrices are <code>upper_triangular</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>lower_triangular</code>, only those diagonal submatrices are <code>lower_triangular</code>, while the other submatrices are <code>general</code>.</p>
<p >Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p >Set the pointer to the parent \(\mathcal{H}\)-matrix node of the current child \(\mathcal{H}\)-matrix node.</p>
<p >Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, <code>hmat</code> should be represented as a <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>. When the block cluster belongs to the far field, <code>hmat</code> should be represented as an <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the current \(\mathcal{H}\)-matrix.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>general</code> property, all \(\mathcal{H}\)-matrix nodes in the leaf set should be created with allocated memory.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>symmetric</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or lower triangular part of the original \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be a symmetric full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>symmetric</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is symmetric to the corresponding block in the lower triangular part.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>hermite_symmetric</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or lower triangular part of the original \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be an Hermite symmetric full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>hermite_symmetric</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is symmetric to the corresponding block in the lower triangular part.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>lower_triangular</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or lower triangular part in the top level \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be a lower triangular full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>lower_triangular</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is zero-valued.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>upper_triangular</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or upper triangular part in the top level \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be a upper triangular full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>upper_triangular</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is zero-valued.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l08318">8318</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l04289">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="hmatrix_8h_source.html#l04263">HMatrix&lt; spacedim, Number &gt;::property</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04257">HMatrix&lt; spacedim, Number &gt;::state</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="hmatrix_8h_source.html#l04323">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a81cc8ff50e421ec2bc9ce33a36d47968" name="a81cc8ff50e421ec2bc9ce33a36d47968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81cc8ff50e421ec2bc9ce33a36d47968">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildren() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_node_property</em> = <code>HMatrixSupport::Property::general</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Recursively construct the children of an \(\mathcal{H}\)-matrix with respect to a block cluster tree by starting from a tree node which is associated with the current \(\mathcal{H}\)-matrix.</p>
<p >The matrices in the leaf set are initialized with zero values. The rank of the near field matrices are predefined fixed values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td>Pointer to the current \(\mathcal{H}\)-matrix node, <b>which has already been created on the heap but with its internal data left empty.</b> </td></tr>
    <tr><td class="paramname">bc_node</td><td>Pointer to a <a class="el" href="classTreeNode.html" title="Class for general tree node.">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree.">BlockClusterTree</a>, which is to be associated with <code>hmat</code>. </td></tr>
    <tr><td class="paramname">top_hmat_node_property</td><td>The property of the \(\mathcal{H}\)-matrix node on the top level </td></tr>
  </table>
  </dd>
</dl>
<p >Link <code>hmat</code> with <code>bc_node</code>.</p>
<p >Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively.</p>
<p >Update the matrix dimension of <code>hmat</code>.</p>
<p >When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>.</p>
<p >Then we will continue constructing its hierarchical submatrices.</p>
<p >Create an empty \(\mathcal{H}\)-matrix on the heap.</p>
<p >Set the state of the child \(\mathcal{H}\)-matrix, which is the same as its parent.</p>
<p >Set the block type of the child \(\mathcal{H}\)-matrix, which depends on the block type of its parent.</p>
<p >When the current \(\mathcal{H}\)-matrix block is <code>undefined_block</code>, all child \(\mathcal{H}\)-matrices are <code>undefined_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>diagonal_block</code>, the first and fourth child \(\mathcal{H}\)-matrices are <code>diagonal_block</code>, while the second child \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code> and the third child \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>upper_triangular_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>lower_triangular_block</code>.</p>
<p >Set the property of the child \(\mathcal{H}\)-matrix, which depends on the property of its parent.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>general</code>, all of its children have the same property <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>symmetric</code>, only those diagonal submatrices are <code>symmetric</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>hermite_symmetric</code>, only those diagonal submatrices are <code>hermite_symmetric</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>upper_triangular</code>, only those diagonal submatrices are <code>upper_triangular</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>lower_triangular</code>, only those diagonal submatrices are <code>lower_triangular</code>, while the other submatrices are <code>general</code>.</p>
<p >Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p >Set the pointer to the parent \(\mathcal{H}\)-matrix node of the current child \(\mathcal{H}\)-matrix node.</p>
<p >Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, <code>hmat</code> should be represented as a <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>. When the block cluster belongs to the far field, <code>hmat</code> should be represented as an <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the current \(\mathcal{H}\)-matrix.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>general</code> property, all \(\mathcal{H}\)-matrix nodes in the leaf set should be created with allocated memory.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>symmetric</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or lower triangular part of the original \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be a symmetric full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>symmetric</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is symmetric to the corresponding block in the lower triangular part.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>hermite_symmetric</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or lower triangular part of the original \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be a Hermite symmetric full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>hermite_symmetric</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is Hermite symmetric to the corresponding block in the lower triangular part.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>lower_triangular</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or lower triangular part in the top level \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be a lower triangular full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>lower_triangular</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is zero-valued.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>upper_triangular</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or upper triangular part in the top level \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be a upper triangular full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>upper_triangular</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is zero-valued.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04976">4976</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l04289">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="hmatrix_8h_source.html#l04263">HMatrix&lt; spacedim, Number &gt;::property</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04257">HMatrix&lt; spacedim, Number &gt;::state</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="hmatrix_8h_source.html#l04323">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, and <a class="el" href="hmatrix_8h_source.html#l18074">HMatrix&lt; spacedim, Number &gt;::reinit()</a>.</p>

</div>
</div>
<a id="ad080fc1c19e1c9c323f5fae8a5704e57" name="ad080fc1c19e1c9c323f5fae8a5704e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad080fc1c19e1c9c323f5fae8a5704e57">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildren() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_node_property</em> = <code>HMatrixSupport::Property::general</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Recursively construct the children of an \(\mathcal{H}\)-matrix with respect to a block cluster tree by starting from a tree node which is associated with the current \(\mathcal{H}\)-matrix.</p>
<p >The matrices in the leaf set are initialized with the data in the given global full matrix <code>M</code>. <code>M</code> is created on the complete block cluster index set \(I \times J\) and whose elements should be accessed via indices stored in the block cluster. The rank of the far field matrices are predefined fixed values.</p>
<p >During the recursive calling of this function, the source data matrix <code>M</code> is kept intact, which will not be restricted to small matrix blocks.</p>
<dl class="section note">
<dt>Note</dt>
<dd><code>hmat</code> may not be global, but only a block in the global matrix, and <code>bc_node</code> in this case is not the root node of the block cluster tree.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td>Pointer to the current \(\mathcal{H}\)-matrix node, <b>which has already been created on the heap but with its internal data left empty.</b> </td></tr>
    <tr><td class="paramname">bc_node</td><td>Pointer to a <a class="el" href="classTreeNode.html" title="Class for general tree node.">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree.">BlockClusterTree</a>, which is to be associated with <code>hmat</code>. </td></tr>
    <tr><td class="paramname">M</td><td>The global full matrix containing all the data required to initialize the \(\mathcal{H}\)-matrix. </td></tr>
  </table>
  </dd>
</dl>
<p >Link <code>hmat</code> with <code>bc_node</code>.</p>
<p >Link row and column indices.</p>
<p >Update the matrix dimension of <code>hmat</code>.</p>
<p >When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>. Then we will continue constructing hierarchical submatrices.</p>
<p >Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p >Set the state of the child \(\mathcal{H}\)-matrix, which is the same as its parent.</p>
<p >Set the block type of the child \(\mathcal{H}\)-matrix, which depends on the block type of its parent.</p>
<p >When the current \(\mathcal{H}\)-matrix block is <code>undefined_block</code>, all child \(\mathcal{H}\)-matrices are <code>undefined_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>diagonal_block</code>, the first and fourth child \(\mathcal{H}\)-matrices are <code>diagonal_block</code>, while the second child \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code> and the third child \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>upper_triangular_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>lower_triangular_block</code>.</p>
<p >Set the property of the child \(\mathcal{H}\)-matrix, which depends on the property of its parent.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>general</code>, all of its children have the same property <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>symmetric</code>, only those diagonal submatrices are <code>symmetric</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>hermite_symmetric</code>, only those diagonal submatrices are <code>hermite_symmetric</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>upper_triangular</code>, only those diagonal submatrices are <code>upper_triangular</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>lower_triangular</code>, only those diagonal submatrices are <code>lower_triangular</code>, while the other submatrices are <code>general</code>.</p>
<p >Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p >Set the pointer to the parent \(\mathcal{H}\)-matrix node of the current child \(\mathcal{H}\)-matrix node.</p>
<p >Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, <code>hmat</code> should be represented as a <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>. When the block cluster belongs to the far field, <code>hmat</code> should be represented as an <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the current \(\mathcal{H}\)-matrix.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>general</code> property, all \(\mathcal{H}\)-matrix nodes in the leaf set should be created with allocated memory.</p>
<p >Assign matrix values from <code>M</code> to the current \(\mathcal{H}\)-matrix.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>symmetric</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or lower triangular part of the original \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be a symmetric full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>symmetric</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is symmetric to the corresponding block in the lower triangular part.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>hermite_symmetric</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or lower triangular part of the original \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be an Hermite symmetric full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>hermite_symmetric</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is Hermite symmetric to the corresponding block in the lower triangular part.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>lower_triangular</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or lower triangular part in the top level \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be a lower triangular full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>lower_triangular</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is zero-valued.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>upper_triangular</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or upper triangular part in the top level \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be a upper triangular full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>upper_triangular</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is zero-valued.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l05726">5726</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l04289">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="hmatrix_8h_source.html#l04263">HMatrix&lt; spacedim, Number &gt;::property</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04257">HMatrix&lt; spacedim, Number &gt;::state</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="hmatrix_8h_source.html#l04323">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="ad4a3904c1eb8b8b26dda1ecda3b2bcbe" name="ad4a3904c1eb8b8b26dda1ecda3b2bcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a3904c1eb8b8b26dda1ecda3b2bcbe">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildren() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_row_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_col_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_node_property</em> = <code>HMatrixSupport::Property::general</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Recursively construct the children of an \(\mathcal{H}\)-matrix with respect to a block cluster tree by starting from a tree node which is associated with the current \(\mathcal{H}\)-matrix.</p>
<p >The matrices in the leaf set are initialized with the data in the given full matrix <code>M</code>, which is created on the block cluster index set \(\tau \times \sigma\). <b>N.B. This block cluster should be one of the ancestors of the block cluster associated with <code>hmat</code> that has been passed to the initial call of this function (let's call it <code>hmat_first</code>). Only in this way, it is valid to restrict this full matrix <code>M</code> to each leaf node of <code>hmat</code>.</b> Hence, this full matrix is just a block of the original global full matrix (the global full matrix is created on the block cluster index set \(I \times J\)). The rank of the far field matrices are predefined fixed values.</p>
<p >During the recursive calling of this function, the source data matrix <code>M</code> is kept intact, which will not be restricted to small matrix blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">bc_node</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">M_tau_index_range</td><td></td></tr>
    <tr><td class="paramname">M_sigma_index_range</td><td></td></tr>
    <tr><td class="paramname">top_hmat_node_property</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Update the matrix dimension of <code>hmat</code>.</p>
<p >When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>. Then we will continue constructing hierarchical submatrices.</p>
<p >Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p >Set the state of the child \(\mathcal{H}\)-matrix, which is the same as its parent.</p>
<p >Set the block type of the child \(\mathcal{H}\)-matrix, which depends on the block type of its parent.</p>
<p >When the current \(\mathcal{H}\)-matrix block is <code>undefined_block</code>, all child \(\mathcal{H}\)-matrices are <code>undefined_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>diagonal_block</code>, the first and fourth child \(\mathcal{H}\)-matrices are <code>diagonal_block</code>, while the second child \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code> and the third child \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>upper_triangular_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>lower_triangular_block</code>.</p>
<p >Set the property of the child \(\mathcal{H}\)-matrix, which depends on the property of its parent.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>general</code>, all of its children have the same property <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>symmetric</code>, only those diagonal submatrices are <code>symmetric</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>hermite_symmetric</code>, only those diagonal submatrices are <code>hermite_symmetric</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>upper_triangular</code>, only those diagonal submatrices are <code>upper_triangular</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>lower_triangular</code>, only those diagonal submatrices are <code>lower_triangular</code>, while the other submatrices are <code>general</code>.</p>
<p >Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p >Set the pointer to the parent \(\mathcal{H}\)-matrix node of the current child \(\mathcal{H}\)-matrix node.</p>
<p >Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, <code>hmat</code> should be represented as a <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>. When the block cluster belongs to the far field, <code>hmat</code> should be represented as an <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the current \(\mathcal{H}\)-matrix.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>general</code> property, all \(\mathcal{H}\)-matrix nodes in the leaf set should be created with allocated memory.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>symmetric</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or lower triangular part of the original \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be a symmetric full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>symmetric</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is symmetric to the corresponding block in the lower triangular part.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>hermite_symmetric</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or lower triangular part of the original \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be an Hermite symmetric full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>hermite_symmetric</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is symmetric to the corresponding block in the lower triangular part.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>lower_triangular</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or lower triangular part in the top level \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be a lower triangular full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>lower_triangular</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is zero-valued.</p>
<p >When the top level \(\mathcal{H}\)-matrix node has the <code>upper_triangular</code> property, only those \(\mathcal{H}\)-matrix nodes in the leaf set that belong to the diagonal or upper triangular part in the top level \(\mathcal{H}\)-matrix will be created with allocated memory.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set is a diagonal block in the top level \(\mathcal{H}\)-matrix, it can only be a upper triangular full matrix. Its memory will be allocated and its <code>LAPACKFullMatrix</code> type will be set to <code>upper_triangular</code>.</p>
<p >Here we make an assertion about the fact that a diagonal \(\mathcal{H}\)-matrix block in the leaf set should belong to the near field.</p>
<p >And we further make an assertion about the fact that the diagonal \(\mathcal{H}\)-matrix block should have the same property as the top level \(\mathcal{H}\)-matrix node.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the upper triangular part in the top level \(\mathcal{H}\)-matrix, it can be either a full matrix or a rank-k matrix. Its memory will be allocated because it contains effective data.</p>
<p >Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >When the current \(\mathcal{H}\)-matrix node in the leaf set belongs to the lower triangular part in the top level \(\mathcal{H}\)-matrix, only set its \(\mathcal{H}\)-matrix type without allocating memory because it is zero-valued.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l07459">7459</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l04289">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="hmatrix_8h_source.html#l04263">HMatrix&lt; spacedim, Number &gt;::property</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04257">HMatrix&lt; spacedim, Number &gt;::state</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="hmatrix_8h_source.html#l04323">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a75ff73627a9480c63bd58514bd4ae598" name="a75ff73627a9480c63bd58514bd4ae598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ff73627a9480c63bd58514bd4ae598">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildren() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Recursively construct the children of an \(\mathcal{H}\)-matrix node with respect to a block cluster tree by starting from a tree node which is associated with the current \(\mathcal{H}\)-matrix node.</p>
<p >The matrices in the leaf set take the data <b>migrated</b> from the leaf set of the given \(\mathcal{H}\)-matrix <code>H</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td>The \(\mathcal{H}\)-matrix node to be associated with the block cluster node <code>bc_node</code>. </td></tr>
    <tr><td class="paramname">bc_node</td><td>The block cluster node to be associated with the \(\mathcal{H}\)-matrix node <code>hmat</code> </td></tr>
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Link <code>hmat</code> with <code>bc_node</code> and remove the <code>const</code> feature <code>bc_node</code> by using <code>const_cast</code>.</p>
<p >Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively..</p>
<p >Update the matrix dimension of <code>hmat</code>.</p>
<p >When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>.</p>
<p >Then we will continue constructing its hierarchical submatrices.</p>
<p >Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p >Set the state of the child \(\mathcal{H}\)-matrix, which is the same as its parent.</p>
<p >Set the block type of the child \(\mathcal{H}\)-matrix, which depends on the block type of its parent.</p>
<p >When the current \(\mathcal{H}\)-matrix block is <code>undefined_block</code>, all child \(\mathcal{H}\)-matrices are <code>undefined_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>diagonal_block</code>, the first and fourth child \(\mathcal{H}\)-matrices are <code>diagonal_block</code>, while the second child \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code> and the third child \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>upper_triangular_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>lower_triangular_block</code>.</p>
<p >Set the property of the child \(\mathcal{H}\)-matrix, which depends on the property of its parent.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>general</code>, all of its children have the same property <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>symmetric</code>, only those diagonal submatrices are <code>symmetric</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>hermite_symmetric</code>, only those diagonal submatrices are <code>hermite_symmetric</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>upper_triangular</code>, only those diagonal submatrices are <code>upper_triangular</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>lower_triangular</code>, only those diagonal submatrices are <code>lower_triangular</code>, while the other submatrices are <code>general</code>.</p>
<p >Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p >Set the pointer to the parent \(\mathcal{H}\)-matrix node of the current child \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is a leaf, migrate the data from the leaf set of <code>H</code> to it.</p>
<p >Shallow copy the found \(\mathcal{H}\)-matrix node in the leaf set to the current \(\mathcal{H}\)-matrix node.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l09189">9189</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l04289">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="hmatrix_8h_source.html#l04263">HMatrix&lt; spacedim, Number &gt;::property</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04257">HMatrix&lt; spacedim, Number &gt;::state</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="hmatrix_8h_source.html#l04323">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="afeb219ba2cfa0060bdd6d4155b884cfd" name="afeb219ba2cfa0060bdd6d4155b884cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb219ba2cfa0060bdd6d4155b884cfd">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildrenWithoutAlloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildrenWithoutAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Recursively construct the children of an \(\mathcal{H}\)-matrix with respect to a block cluster tree by starting from a tree node which is to be associated with the current \(\mathcal{H}\)-matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td>Pointer to the current \(\mathcal{H}\)-matrix node, <b>which has already been created on the heap but with its internal data left empty.</b> </td></tr>
    <tr><td class="paramname">bc_node</td><td>Pointer to a <a class="el" href="classTreeNode.html" title="Class for general tree node.">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree.">BlockClusterTree</a>, which is to be associated with <code>hmat</code>. </td></tr>
  </table>
  </dd>
</dl>
<p >Link <code>hmat</code> with <code>bc_node</code>.</p>
<p >Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively.</p>
<p >Update the matrix dimension of <code>hmat</code>.</p>
<p >When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>.</p>
<p >Then we will continue constructing its hierarchical submatrices.</p>
<p >Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p >Set the state of the child \(\mathcal{H}\)-matrix, which is the same as its parent.</p>
<p >Set the block type of the child \(\mathcal{H}\)-matrix, which depends on the block type of its parent.</p>
<p >When the current \(\mathcal{H}\)-matrix block is <code>undefined_block</code>, all child \(\mathcal{H}\)-matrices are <code>undefined_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>diagonal_block</code>, the first and fourth child \(\mathcal{H}\)-matrices are <code>diagonal_block</code>, while the second child \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code> and the third child \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>upper_triangular_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>lower_triangular_block</code>.</p>
<p >Set the property of the child \(\mathcal{H}\)-matrix, which depends on the property of its parent.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>general</code>, all of its children have the same property <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>symmetric</code>, only those diagonal submatrices are <code>symmetric</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>hermite_symmetric</code>, only those diagonal submatrices are <code>hermite_symmetric</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>upper_triangular</code>, only those diagonal submatrices are <code>upper_triangular</code>, while the other submatrices are <code>general</code>.</p>
<p >When the property of the current \(\mathcal{H}\)-matrix is <code>lower_triangular</code>, only those diagonal submatrices are <code>lower_triangular</code>, while the other submatrices are <code>general</code>.</p>
<p >Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p >Set the pointer to the parent \(\mathcal{H}\)-matrix node of the current child \(\mathcal{H}\)-matrix node.</p>
<p >Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, <code>hmat</code> should be represented as a <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>. When the block cluster belongs to the far field, <code>hmat</code> should be represented as an <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the current \(\mathcal{H}\)-matrix.</p>
<p >Set the full matrix's property according to the current \(\mathcal{H}\)-matrix node property only when the current \(\mathcal{H}\)-matrix node is a diagonal block.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The <code>state</code> of the full matrix will be taken care of by itself, i.e. its state will change accordingly when some specific operation is applied to it.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04621">4621</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04621">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l04289">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="hmatrix_8h_source.html#l04263">HMatrix&lt; spacedim, Number &gt;::property</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04257">HMatrix&lt; spacedim, Number &gt;::state</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="hmatrix_8h_source.html#l04323">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l04621">InitAndCreateHMatrixChildrenWithoutAlloc()</a>.</p>

</div>
</div>
<a id="aadb74a11c32d7078bdff06cd7b7487b5" name="aadb74a11c32d7078bdff06cd7b7487b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb74a11c32d7078bdff06cd7b7487b5">&#9670;&nbsp;</a></span>InitHMatrixWrtBlockClusterNode() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitHMatrixWrtBlockClusterNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initialize an \(\mathcal{H}\)-matrix node with respect to a block cluster node. The list \(\Sigma_b^P\) is set to empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">bc_node</td><td></td></tr>
    <tr><td class="paramname">Sigma_P</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Link <code>hmat</code> with <code>bc_node</code>.</p>
<p >Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively.</p>
<p >Update the matrix dimension of <code>hmat</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04455">4455</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04403">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="hmatrix_8h_source.html#l04391">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, and <a class="el" href="hmatrix_8h_source.html#l04397">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l29207">HMatrix&lt; spacedim, Number &gt;::mmult()</a>.</p>

</div>
</div>
<a id="a964e325e5cb3cd4048622e9687318520" name="a964e325e5cb3cd4048622e9687318520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964e325e5cb3cd4048622e9687318520">&#9670;&nbsp;</a></span>InitHMatrixWrtBlockClusterNode() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitHMatrixWrtBlockClusterNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_pair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initialize an \(\mathcal{H}\)-matrix node with respect to a block cluster node. The given <code>hmat_pair</code> will be appended to the list \(\Sigma_b^P\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">bc_node</td><td></td></tr>
    <tr><td class="paramname">hmat_pair</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Link <code>hmat</code> with <code>bc_node</code>.</p>
<p >Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively.</p>
<p >Update the matrix dimension of <code>hmat</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04566">4566</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04403">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="hmatrix_8h_source.html#l04391">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, and <a class="el" href="hmatrix_8h_source.html#l04397">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>.</p>

</div>
</div>
<a id="a6dafc53598070d5dfaa3e9abb4eaf355" name="a6dafc53598070d5dfaa3e9abb4eaf355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dafc53598070d5dfaa3e9abb4eaf355">&#9670;&nbsp;</a></span>InitHMatrixWrtBlockClusterNode() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitHMatrixWrtBlockClusterNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, typename numbers::NumberTraits&lt; Number &gt;::real_type &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma_P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initialize an \(\mathcal{H}\)-matrix node with respect to a block cluster node. Its member list \(\Sigma_b^P\) will be merged with the given <code>Sigma_P</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">bc_node</td><td></td></tr>
    <tr><td class="paramname">Sigma_P</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Link <code>hmat</code> with <code>bc_node</code>.</p>
<p >Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively.</p>
<p >Update the matrix dimension of <code>hmat</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04507">4507</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04403">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="hmatrix_8h_source.html#l04391">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, and <a class="el" href="hmatrix_8h_source.html#l04397">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>.</p>

</div>
</div>
<a id="a78a2429426558ca0d6982f97b3669bf3" name="a78a2429426558ca0d6982f97b3669bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a2429426558ca0d6982f97b3669bf3">&#9670;&nbsp;</a></span>print_h_h_submatrix_mmult_accessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void print_h_h_submatrix_mmult_accessor </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17562">17562</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="abb67e27b0623d39d9b974fe43b56c349" name="abb67e27b0623d39d9b974fe43b56c349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb67e27b0623d39d9b974fe43b56c349">&#9670;&nbsp;</a></span>print_h_submatrix_accessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void print_h_submatrix_accessor </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17548">17548</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a090df12c1646d637bc390fa6dae55f24" name="a090df12c1646d637bc390fa6dae55f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090df12c1646d637bc390fa6dae55f24">&#9670;&nbsp;</a></span>RefineHMatrixWrtExtendedBlockClusterTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RefineHMatrixWrtExtendedBlockClusterTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>current_hmat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Refine an \(\mathcal{H}\)-matrix node with respect to its associated block cluster tree which has already been extended to be finer than the original tree. The \(\mathcal{H}\)-matrix node should be of either <code>FullMatrixType</code> or <code>RkMatrixType</code>, i.e. it belongs to the leaf set of the block cluster tree before extension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting_hmat</td><td>The pointer to the initial \(\mathcal{H}\)-matrix node from which this recursive function is called for the first time, i.e. the \(\mathcal{H}\)-matrix node from which the refinement begins. </td></tr>
    <tr><td class="paramname">current_hmat</td><td>The pointer to the current \(\mathcal{H}\)-matrix node being handled during the recursion. For the first time of calling this function, <code>current_hmat</code> is the same as <code>starting_hmat</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section">
<dt>Work flow </dt>
<dd><p class="startdd">Because the \(\mathcal{H}\)-matrix node from which the refinement begins belongs to the leaf set of the original block cluster tree, its \(\mathcal{H}\)-matrix type can only be <code>FullMatrixType</code> or <code>RkMatrixType</code>. Therefore, we make an assertion here.</p>
<p class="interdd">Determine the total number of children of the current \(\mathcal{H}\)-matrix node by querying its associated block cluster node. We do it like this is because the block cluster tree has already been extended which contains a set of child node, while the hierarchy of H-matrices has still not been extended yet.</p>
<p class="interdd">If the associated block cluster node of the current \(\mathcal{H}\)-matrix node has children, we firstly update the \(\mathcal{H}\)-matrix type for the current \(\mathcal{H}\)-matrix node as <code>HierarchicalMatrix</code> and this is only performed when the current \(\mathcal{H}\)-matrix node is <b>not</b> the starting \(\mathcal{H}\)-matrix node, because the original matrix type of the starting \(\mathcal{H}\)-matrix node will be used later during restriction operations to the current block cluster. When the whole recursive call of this function <code>RefineHMatrixWrtExtendedBlockClusterTree</code> is complete, the \(\mathcal{H}\)-matrix type of <code>starting_hmat</code> will be corrected if this \(\mathcal{H}\)-matrix node has literally been refined. And this operation should be performed in the caller function of <code>RefineHMatrixWrtExtendedBlockClusterTree</code>, such as <code><a class="el" href="classHMatrix.html#ad2b353962226c78910d6ddb6b5b8e460">HMatrix&lt;spacedim, Number&gt;::refine_to_supertree</a></code>.</p>
<p class="interdd">For each of the children, create an empty \(\mathcal{H}\)-matrix node on the heap and append it to the list of submatrices of the current \(\mathcal{H}\)-matrix.</p>
<p class="interdd">Set the state of the child \(\mathcal{H}\)-matrix, which is the same as its parent.</p>
<p class="interdd">Set the block type of the child \(\mathcal{H}\)-matrix, which depends on the block type of its parent.</p>
<p class="interdd">When the current \(\mathcal{H}\)-matrix block is <code>undefined_block</code>, all child \(\mathcal{H}\)-matrices are <code>undefined_block</code>.</p>
<p class="interdd">When the current \(\mathcal{H}\)-matrix is <code>diagonal_block</code>, the first and fourth child \(\mathcal{H}\)-matrices are <code>diagonal_block</code>, while the second child \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code> and the third child \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>.</p>
<p class="interdd">When the current \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>upper_triangular_block</code>.</p>
<p class="interdd">When the current \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>lower_triangular_block</code>.</p>
<p class="interdd">Set the property of the child \(\mathcal{H}\)-matrix, which depends on the property of its parent.</p>
<p class="interdd">When the property of the current \(\mathcal{H}\)-matrix is <code>general</code>, all of its children have the same property <code>general</code>.</p>
<p class="interdd">When the property of the current \(\mathcal{H}\)-matrix is <code>symmetric</code>, only those diagonal submatrices are <code>symmetric</code>, while the other submatrices are <code>general</code>.</p>
<p class="interdd">When the property of the current \(\mathcal{H}\)-matrix is <code>hermite_symmetric</code>, only those diagonal submatrices are <code>hermite_symmetric</code>, while the other submatrices are <code>general</code>.</p>
<p class="interdd">When the property of the current \(\mathcal{H}\)-matrix is <code>upper_triangular</code>, only those diagonal submatrices are <code>upper_triangular</code>, while the other submatrices are <code>general</code>.</p>
<p class="interdd">When the property of the current \(\mathcal{H}\)-matrix is <code>lower_triangular</code>, only those diagonal submatrices are <code>lower_triangular</code>, while the other submatrices are <code>general</code>.</p>
<p class="interdd">Link the child \(\mathcal{H}\)-matrix node with the corresponding block cluster node.</p>
<p class="interdd">Link row and column indices of the child \(\mathcal{H}\)-matrix node to those index sets stored in clusters.</p>
<p class="interdd">Update the matrix dimension of the child \(\mathcal{H}\)-matrix node.</p>
<p class="interdd">Set the pointer to the parent \(\mathcal{H}\)-matrix node of the current child \(\mathcal{H}\)-matrix node.</p>
<p class="interdd">Recursively call the function.</p>
<p class="interdd">When the current \(\mathcal{H}\)-matrix node has no children, i.e. it belongs to the leaf set of the extended block cluster tree.</p>
<p class="interdd">If the current \(\mathcal{H}\)-matrix node is still the same as the starting \(\mathcal{H}\)-matrix node, there is no actual refinement work to be done.</p>
<p class="interdd">Update the current \(\mathcal{H}\)-matrix node type according to the identity of the block cluster node: when the block cluster belongs to the near field, <code>current_hmat</code> should be represented as a full matrix <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>; when the block cluster belongs to the far field, <code>current_hmat</code> should be represented as a rank-k matrix <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the corresponding field of the current \(\mathcal{H}\)-matrix.</p>
<p class="interdd">Fill the current full matrix with the data extracted from the starting \(\mathcal{H}\)-matrix node. This is actually a restriction of the starting \(\mathcal{H}\)-matrix node to the current \(\mathcal{H}\)-matrix node.</p>
<p class="interdd">Restrict full matrix to full matrix.</p>
<p class="interdd">Restrict rank-k matrix to full matrix.</p>
<p class="interdd">Set the full matrix's property according to the current \(\mathcal{H}\)-matrix node property only when the current \(\mathcal{H}\)-matrix node is a diagonal block.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The <code>state</code> of the full matrix will be taken care of by itself, i.e. its state will change accordingly when some specific operation is applied to it.</dd>
</dl>
<p class="interdd">Fill the current rank-k matrix with the data extracted from the starting \(\mathcal{H}\)-matrix node.</p>
<p class="interdd">Restrict full matrix to rank-k matrix.</p>
<p class="interdd">Restrict rank-k matrix to rank-k matrix.</p>
<p class="enddd"></p>
</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l09483">9483</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l04289">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="hmatrix_8h_source.html#l04263">HMatrix&lt; spacedim, Number &gt;::property</a>, <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04257">HMatrix&lt; spacedim, Number &gt;::state</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="hmatrix_8h_source.html#l04323">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l36093">HMatrix&lt; spacedim, Number &gt;::refine_to_supertree()</a>, and <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>.</p>

</div>
</div>
<a id="af5e90e9592ce3d05bdea99a9b93d7606" name="af5e90e9592ce3d05bdea99a9b93d7606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e90e9592ce3d05bdea99a9b93d7606">&#9670;&nbsp;</a></span>rk_h_mmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rk_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes and the result is scaled by a factor, where the first one <code>M1</code> has <code>RkMatrixType</code> and the result is also a rank-k matrix.</p>
<p >The arithmetic operation to be performed is </p><p class="formulaDsp">
\[
M = \alpha \cdot M_1 \cdot M_2 = \alpha \cdot  (A B^T) M_2 = \alpha \cdot A
(B^T M_2) = \alpha \cdot  A B&#39;^T, \]
</p>
<p> where \(B&#39; = M_2^T B\) is calculated as a series of transposed \(\mathcal{H}\)-matrix/vector multiplications. For details, </p><p class="formulaDsp">
\[
M_2^T B = M_2^T
\begin{bmatrix}
b_{\sigma,1} &amp; \cdots &amp; b_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
M_2^T b_{\sigma,1} &amp; \cdots &amp; M_2^T b_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
b&#39;_{\rho,1} &amp; \cdots &amp; b&#39;_{\rho,r}
\end{bmatrix}.
\]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a temporary <code>Vector</code> storing a column \(b_{\sigma,j}\) in the <code>B</code> component of <code>M1</code> and another <code>Vector</code> \(b&#39;_{\rho,j}\) storing the \(\mathcal{H}\)-matrix/vector product \(M_2^T \cdot b_{\sigma,j}\).</p>
<p >Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M1_rk</code>. Its <code>A</code> component matrix is the same as that of <code>M1_rk</code>.</p>
<p >Then we calculate the <code>B</code> component matrix of <code>M</code>, which is <code>M2^T*M1_rk</code>.B.</p>
<p ><b>Since the following <code>Tvmult</code> will compute \(y = y + M^T x\), <code>result_vect</code> should be reset to zero beforehand.</b></p>
<p >Fill the result vector into the <code>B</code> component matrix of <code>M</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11038">11038</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a5d344d3d2c8db0c93690bf7cbd4a4459" name="a5d344d3d2c8db0c93690bf7cbd4a4459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d344d3d2c8db0c93690bf7cbd4a4459">&#9670;&nbsp;</a></span>rk_h_mmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rk_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the first one <code>M1</code> has <code>RkMatrixType</code> and the result is also a rank-k matrix.</p>
<p >The arithmetic operation to be performed is </p><p class="formulaDsp">
\[
M = M_1 \cdot M_2 = (A B^T) M_2 = A (B^T M_2) = A B&#39;^T,
\]
</p>
<p> where \(B&#39; = M_2^T B\) is calculated as a series of transposed \(\mathcal{H}\)-matrix/vector multiplications. For details, </p><p class="formulaDsp">
\[
M_2^T B = M_2^T
\begin{bmatrix}
b_{\sigma,1} &amp; \cdots &amp; b_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
M_2^T b_{\sigma,1} &amp; \cdots &amp; M_2^T b_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
b&#39;_{\rho,1} &amp; \cdots &amp; b&#39;_{\rho,r}
\end{bmatrix}.
\]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a temporary <code>Vector</code> storing a column \(b_{\sigma,j}\) in the <code>B</code> component of <code>M1</code> and another <code>Vector</code> \(b&#39;_{\rho,j}\) storing the \(\mathcal{H}\)-matrix/vector product \(M_2^T \cdot b_{\sigma,j}\).</p>
<p >Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M1_rk</code>. Its <code>A</code> component matrix is the same as that of <code>M1_rk</code>.</p>
<p >Then we calculate the <code>B</code> component matrix of <code>M</code>, which is <code>M2^T*M1_rk</code>.B.</p>
<p >Fill the result vector into the <code>B</code> component matrix of <code>M</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l10959">10959</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="rkmatrix_8h_source.html#l01140">RkMatrix&lt; Number &gt;::formal_rank</a>, <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="rkmatrix_8h_source.html#l01145">RkMatrix&lt; Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="rkmatrix_8h_source.html#l01150">RkMatrix&lt; Number &gt;::n</a>, <a class="el" href="rkmatrix_8h_source.html#l01134">RkMatrix&lt; Number &gt;::rank</a>, <a class="el" href="rkmatrix_8h_source.html#l02445">RkMatrix&lt; Number &gt;::reinit()</a>, and <a class="el" href="hmatrix_8h_source.html#l23665">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l12175">f_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l16039">h_h_mmult_level_conserving()</a>, and <a class="el" href="hmatrix_8h_source.html#l11411">rk_h_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="a43aef4fd52ce71103baa047f549293c6" name="a43aef4fd52ce71103baa047f549293c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43aef4fd52ce71103baa047f549293c6">&#9670;&nbsp;</a></span>rk_h_mmult_for_h_h_mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rk_h_mmult_for_h_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_M1M2_last_in_M_Sigma_P</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the first one <code>M1</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix. This function is to be called by the matrix-matrix multiplication function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11411">11411</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h_source.html#l36264">HMatrix&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list()</a>, <a class="el" href="hmatrix_8h_source.html#l10959">rk_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04403">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="hmatrix_8h_source.html#l04391">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="hmatrix_8h_source.html#l04397">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l28729">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_reduction()</a>.</p>

</div>
</div>
<a id="ab2eac81199c6e3cdf57242dfae682841" name="ab2eac81199c6e3cdf57242dfae682841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2eac81199c6e3cdf57242dfae682841">&#9670;&nbsp;</a></span>rk_h_mTmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rk_h_mTmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes with the second operand being transposed, where the first operand <code>M1</code> has <code>RkMatrixType</code> and the result is also a rank-k matrix. The result will be scaled by a factor.</p>
<p >The arithmetic operation to be performed is </p><p class="formulaDsp">
\[
M = \alpha \cdot M_1 \cdot M_2^T = \alpha \cdot (A B^T) M_2^T = \alpha
\cdot A (B^T M_2^T) = \alpha \cdot A B&#39;^T, \]
</p>
<p> where \(B&#39; = M_2 B\) is calculated as a series of \(\mathcal{H}\)-matrix/vector multiplications. For details, </p><p class="formulaDsp">
\[
M_2 B = M_2 \begin{bmatrix} b_{\sigma,1} &amp; \cdots &amp; b_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
M_2 b_{\sigma,1} &amp; \cdots &amp; M_2 b_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
b&#39;_{\rho,1} &amp; \cdots &amp; b&#39;_{\rho,r}
\end{bmatrix}.
\]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a temporary <code>Vector</code> storing a column \(b_{\sigma,j}\) in the <code>B</code> component of <code>M1</code> and another <code>Vector</code> \(b&#39;_{\rho,j}\) storing the \(\mathcal{H}\)-matrix/vector product \(M_2 \cdot b_{\sigma,j}\).</p>
<p >Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M1_rk</code>. Its <code>A</code> component matrix is the same as that of <code>M1_rk</code>.</p>
<p >Then we calculate the <code>B</code> component matrix of <code>M</code>, which is <code>M2*M1_rk</code>.B.</p>
<p >Fill the result vector into the <code>B</code> component matrix of <code>M</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11194">11194</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aca19ab9519b7b1aa1b9660dbfa8fe604" name="aca19ab9519b7b1aa1b9660dbfa8fe604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca19ab9519b7b1aa1b9660dbfa8fe604">&#9670;&nbsp;</a></span>rk_h_mTmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rk_h_mTmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes with the second operand being transposed, where the first operand <code>M1</code> has <code>RkMatrixType</code> and the result is also a rank-k matrix.</p>
<p >The arithmetic operation to be performed is </p><p class="formulaDsp">
\[
M = M_1 \cdot M_2^T = (A B^T) M_2^T = A (B^T M_2^T) = A B&#39;^T,
\]
</p>
<p> where \(B&#39; = M_2 B\) is calculated as a series of \(\mathcal{H}\)-matrix/vector multiplications. For details, </p><p class="formulaDsp">
\[ M_2 B = M_2 \begin{bmatrix}
b_{\sigma,1} &amp; \cdots &amp; b_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
M_2 b_{\sigma,1} &amp; \cdots &amp; M_2 b_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
b&#39;_{\rho,1} &amp; \cdots &amp; b&#39;_{\rho,r}
\end{bmatrix}.
\]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a temporary <code>Vector</code> storing a column \(b_{\sigma,j}\) in the <code>B</code> component of <code>M1</code> and another <code>Vector</code> \(b&#39;_{\rho,j}\) storing the \(\mathcal{H}\)-matrix/vector product \(M_2 \cdot b_{\sigma,j}\).</p>
<p >Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M1_rk</code>. Its <code>A</code> component matrix is the same as that of <code>M1_rk</code>.</p>
<p >Then we calculate the <code>B</code> component matrix of <code>M</code>, which is <code>M2*M1_rk</code>.B.</p>
<p >Fill the result vector into the <code>B</code> component matrix of <code>M</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11119">11119</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="rkmatrix_8h_source.html#l01140">RkMatrix&lt; Number &gt;::formal_rank</a>, <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="rkmatrix_8h_source.html#l01145">RkMatrix&lt; Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="rkmatrix_8h_source.html#l01150">RkMatrix&lt; Number &gt;::n</a>, <a class="el" href="rkmatrix_8h_source.html#l01134">RkMatrix&lt; Number &gt;::rank</a>, <a class="el" href="rkmatrix_8h_source.html#l02445">RkMatrix&lt; Number &gt;::reinit()</a>, and <a class="el" href="hmatrix_8h_source.html#l21052">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l12231">f_h_mTmult()</a>, and <a class="el" href="hmatrix_8h_source.html#l16558">h_h_mTmult_level_conserving()</a>.</p>

</div>
</div>
<a id="a96dedeab2f1f9c6e12ee04325863f07d" name="a96dedeab2f1f9c6e12ee04325863f07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96dedeab2f1f9c6e12ee04325863f07d">&#9670;&nbsp;</a></span>rk_h_Tmmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rk_h_Tmmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the scaled product of two \(\mathcal{H}\)-matrix nodes with the first operand being transposed, where the first one <code>M1</code> has <code>RkMatrixType</code> and the result is also a rank-k matrix.</p>
<p >The arithmetic operation to be performed is</p>
<p class="formulaDsp">
\[
M = \alpha M_1^T \cdot M_2 = \alpha (A B^T)^T M_2 = \alpha B (A^T M_2) =
\alpha B A&#39;^T, \]
</p>
<p >where \(A&#39; = M_2^T A\) is calculated as a series of transposed \(\mathcal{H}\)-matrix/vector multiplications. For details, </p><p class="formulaDsp">
\[
M_2^T A = M_2^T
\begin{bmatrix}
a_{\sigma,1} &amp; \cdots &amp; a_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
M_2^T a_{\sigma,1} &amp; \cdots &amp; M_2^T a_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
a&#39;_{\rho,1} &amp; \cdots &amp; a&#39;_{\rho,r}
\end{bmatrix}.
\]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a temporary <code>Vector</code> storing a column \(a_{\sigma,j}\) in the <code>A</code> component of <code>M1</code> and another <code>Vector</code> \(a&#39;_{\rho,j}\) storing the transposed \(\mathcal{H}\)-matrix/vector product \(M_2^T \cdot a_{\sigma,j}\).</p>
<p >Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M1_rk</code>. Its <code>A</code> component matrix is the same as the <code>B</code> component of <code>M1_rk</code>.</p>
<p >Then we calculate the <code>B</code> component matrix of <code>M</code>, which is <code>M2^T*M1_rk</code>.A.</p>
<p >Fill the result vector into the <code>B</code> component matrix of <code>M</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11354">11354</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a6d013f955b2d54b23231f9d4947662fe" name="a6d013f955b2d54b23231f9d4947662fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d013f955b2d54b23231f9d4947662fe">&#9670;&nbsp;</a></span>rk_h_Tmmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rk_h_Tmmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the product of two \(\mathcal{H}\)-matrix nodes with the first operand being transposed, where the first one <code>M1</code> has <code>RkMatrixType</code> and the result is also a rank-k matrix.</p>
<p >The arithmetic operation to be performed is </p><p class="formulaDsp">
\[
M = M_1^T \cdot M_2 = (A B^T)^T M_2 = B (A^T M_2) = B A&#39;^T,
\]
</p>
<p> where \(A&#39; = M_2^T A\) is calculated as a series of transposed \(\mathcal{H}\)-matrix/vector multiplications. For details, </p><p class="formulaDsp">
\[
M_2^T A = M_2^T
\begin{bmatrix}
a_{\sigma,1} &amp; \cdots &amp; a_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
M_2^T a_{\sigma,1} &amp; \cdots &amp; M_2^T a_{\sigma,r}
\end{bmatrix} =
\begin{bmatrix}
a&#39;_{\rho,1} &amp; \cdots &amp; a&#39;_{\rho,r}
\end{bmatrix}.
\]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create a temporary <code>Vector</code> storing a column \(a_{\sigma,j}\) in the <code>A</code> component of <code>M1</code> and another <code>Vector</code> \(a&#39;_{\rho,j}\) storing the transposed \(\mathcal{H}\)-matrix/vector product \(M_2^T \cdot a_{\sigma,j}\).</p>
<p >Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M1_rk</code>. Its <code>A</code> component matrix is the same as the <code>B</code> component of <code>M1_rk</code>.</p>
<p >Then we calculate the <code>B</code> component matrix of <code>M</code>, which is <code>M2^T*M1_rk</code>.A.</p>
<p >Fill the result vector into the <code>B</code> component matrix of <code>M</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l11273">11273</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="rkmatrix_8h_source.html#l01140">RkMatrix&lt; Number &gt;::formal_rank</a>, <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>, <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="rkmatrix_8h_source.html#l01145">RkMatrix&lt; Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="rkmatrix_8h_source.html#l01150">RkMatrix&lt; Number &gt;::n</a>, <a class="el" href="rkmatrix_8h_source.html#l01134">RkMatrix&lt; Number &gt;::rank</a>, <a class="el" href="rkmatrix_8h_source.html#l02445">RkMatrix&lt; Number &gt;::reinit()</a>, and <a class="el" href="hmatrix_8h_source.html#l23665">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l12287">f_h_Tmmult()</a>, and <a class="el" href="hmatrix_8h_source.html#l17073">h_h_Tmmult_level_conserving()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
