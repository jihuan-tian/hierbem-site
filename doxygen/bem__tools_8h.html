<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HierBEM: include/bem/bem_tools.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js", "TeX/AMScd.js.js"],
  jax: ["input/TeX","output/SVG"],
});
MathJax.Hub.Config({
  jax: ["input/TeX", "output/SVG"],
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js", "TeX/AMScd.js"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    skipTags: ["script","noscript","style","textarea","pre","code"],
    processEscapes: false,
    processEnvironments: true,
    preview: "TeX"
  },
  TeX: {
    Macros: {
      intd: "\\,{\\rm d}",
        diff: "{\\rm d}",
        Diff: "{\\rm D}",
        pdiff: "\\partial",
        DD: ["\\frac{\\diff}{\\diff #2}\\left( #1 \\right)", 2],
        Dd: ["\\frac{\\diff #1}{\\diff #2}", 2],
        PD: ["\\frac{\\pdiff}{\\pdiff #2}\\left( #1 \\right)", 2],
        Pd: ["\\frac{\\pdiff #1}{\\pdiff #2}", 2],
        rme: "{\\rm e}",
        rmi: "{\\rm i}",
        rmj: "{\\rm j}",
        vect: ["\\boldsymbol{#1}", 1],
        dform: ["\\overset{\\rightharpoonup}{\\boldsymbol{#1}}", 1],
        cochain: ["\\overset{\\rightharpoonup}{#1}", 1],
        bigabs: ["\\bigg\\lvert#1\\bigg\\rvert", 1],
        Abs: ["\\big\\lvert#1\\big\\rvert", 1],
        abs: ["\\lvert#1\\rvert", 1],
        bignorm: ["\\bigg\\lVert#1\\bigg\\rVert", 1],
        Norm: ["\\big\\lVert#1\\big\\rVert", 1],
        norm: ["\\lVert#1\\rVert", 1],
        normvect: "\\vect{n}",
        ouset: ["\\overset{#3}{\\underset{#2}{#1}}", 3],
        cscript: ["\\;\\; #1", 1],
        suchthat: "\\textit{S.T.\\;}",
        prefstar: "\\ast",
        restrict: "\\big\\vert",
        sgn: "{\\rm sgn}",
        erf: "{\\rm erf}",
        Bd: "{\\rm Bd}",
        Int: "{\\rm Int}",
        dim: "{\\rm dim}",
        rank: "{\\rm rank}",
        range: "{\\rm range}",
        divergence: "{\\rm div}",
        curl: "{\\rm curl}",
        grad: "{\\rm grad}",
        diag: "{\\rm diag}",
        tr: "{\\rm tr}",
        span: "{\\rm span}",
        lhs: "{\\rm LHS}",
        rhs: "{\\rm RHS}",
        argmin: "{\\rm argmin}",
        argmax: "{\\rm argmax}",
        esssup: "{\\rm ess sup}",
        essinf: "{\\rm ess inf}",
        kernel: "{\\rm ker}",
        image: "{\\rm Im}",
        diam: "{\\rm diam}"
    },
    equationNumbers: { autoNumber: "AMS" }
  },
  "HTML-CSS": {
     availableFonts: ["STIX","TeX"],
     preferredFont: "TeX",
     webFont: "TeX",
     imageFont: "TeX",
     showMathMenu: true
  },
  MMLorHTML: {
    prefer: {
      MSIE:    "MML",
      Firefox: "MML",
      Opera:   "HTML",
      other:   "HTML"
    }
  }
});
</script>
<script type="text/javascript" async="async" src="/js/MathJax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">HierBEM<span id="projectnumber">&#160;v1.0.0</span>
   </div>
   <div id="projectbrief">Hierarchical matrix based 3D Galerkin boundary element method (BEM) C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_578470d43e13ad95c6c96d14923f0ef8.html">bem</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">bem_tools.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Introduction of <a class="el" href="bem__tools_8h.html" title="Introduction of bem_tools.h.">bem_tools.h</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;deal.II/base/derivative_form.h&gt;</code><br />
<code>#include &lt;deal.II/base/point.h&gt;</code><br />
<code>#include &lt;deal.II/base/subscriptor.h&gt;</code><br />
<code>#include &lt;deal.II/base/table.h&gt;</code><br />
<code>#include &lt;deal.II/base/table_indices.h&gt;</code><br />
<code>#include &lt;deal.II/base/utilities.h&gt;</code><br />
<code>#include &lt;deal.II/dofs/dof_accessor.h&gt;</code><br />
<code>#include &lt;deal.II/dofs/dof_handler.h&gt;</code><br />
<code>#include &lt;deal.II/fe/fe.h&gt;</code><br />
<code>#include &lt;deal.II/fe/fe_data.h&gt;</code><br />
<code>#include &lt;deal.II/fe/fe_q.h&gt;</code><br />
<code>#include &lt;deal.II/fe/fe_tools.h&gt;</code><br />
<code>#include &lt;deal.II/fe/fe_values.h&gt;</code><br />
<code>#include &lt;deal.II/fe/mapping_q.h&gt;</code><br />
<code>#include &lt;deal.II/grid/tria.h&gt;</code><br />
<code>#include &lt;deal.II/lac/full_matrix.templates.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;array&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="config_8h_source.html">config.h</a>&quot;</code><br />
<code>#include &quot;linear_algebra/lapack_full_matrix_ext.h&quot;</code><br />
<code>#include &quot;<a class="el" href="mapping__q__ext_8h_source.html">mapping/mapping_q_ext.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="generic__functors_8h_source.html">utilities/generic_functors.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for bem_tools.h:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bem__tools_8h__incl.svg" width="4531" height="395"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="bem__tools_8h__dep__incl.svg" width="1611" height="1020"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<p><a href="bem__tools_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac598f13dff89eec0f9a89e14be4c8ce4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ac598f13dff89eec0f9a89e14be4c8ce4">BEMTools::CellNeighboringType</a> { <br />
&#160;&#160;<a class="el" href="bem__tools_8h.html#ac598f13dff89eec0f9a89e14be4c8ce4a351e4010587b7642f235dc8f81091509">BEMTools::SamePanel</a>
, <a class="el" href="bem__tools_8h.html#ac598f13dff89eec0f9a89e14be4c8ce4a3ce0b018d91fa590a3ebf7d7cbd9d00c">BEMTools::CommonEdge</a>
, <a class="el" href="bem__tools_8h.html#ac598f13dff89eec0f9a89e14be4c8ce4ad08555431f2c2393ecd12012ea653fcd">BEMTools::CommonVertex</a>
, <a class="el" href="bem__tools_8h.html#ac598f13dff89eec0f9a89e14be4c8ce4ab36ab01f71e16f479bf03f5afa2f963f">BEMTools::Regular</a>
, <br />
&#160;&#160;<a class="el" href="bem__tools_8h.html#ac598f13dff89eec0f9a89e14be4c8ce4a395bda70f2c3365a36cd288553e8725f">BEMTools::None</a>
<br />
 }</td></tr>
<tr class="separator:ac598f13dff89eec0f9a89e14be4c8ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8e4ecff83e921d0744a9fcc9b60604"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#aae8e4ecff83e921d0744a9fcc9b60604">BEMTools::DetectCellNeighboringTypeMethod</a> { <a class="el" href="bem__tools_8h.html#aae8e4ecff83e921d0744a9fcc9b60604a09b6ea754926fcaa6ce349245a0ca904">BEMTools::SameTriangulations</a>
, <a class="el" href="bem__tools_8h.html#aae8e4ecff83e921d0744a9fcc9b60604ad9dfbabe60b6ddc901fd0f211c9fcce8">BEMTools::DifferentTriangulations</a>
 }</td></tr>
<tr class="separator:aae8e4ecff83e921d0744a9fcc9b60604"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2a1b92caf9f55da16a320124c4e38886"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a2a1b92caf9f55da16a320124c4e38886">BEMTools::cell_neighboring_type_name</a> (CellNeighboringType n)</td></tr>
<tr class="separator:a2a1b92caf9f55da16a320124c4e38886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad703a50befa5a882c080e6993fe99f77"><td class="memTemplParams" colspan="2">template&lt;typename VectorType1 , typename VectorType2 , typename IndexType &gt; </td></tr>
<tr class="memitem:ad703a50befa5a882c080e6993fe99f77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ad703a50befa5a882c080e6993fe99f77">BEMTools::permute_vector</a> (const VectorType1 &amp;input_vector, const std::vector&lt; IndexType &gt; &amp;permutation_indices, VectorType2 &amp;permuted_vector)</td></tr>
<tr class="memdesc:ad703a50befa5a882c080e6993fe99f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute a vector by using the given permutation indices to access its elements.  <a href="bem__tools_8h.html#ad703a50befa5a882c080e6993fe99f77">More...</a><br /></td></tr>
<tr class="separator:ad703a50befa5a882c080e6993fe99f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e6654691a4063ada8dfe404683d01c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:a41e6654691a4063ada8dfe404683d01c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; types::global_dof_index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a41e6654691a4063ada8dfe404683d01c">BEMTools::get_conflict_indices</a> (const typename DoFHandler&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell)</td></tr>
<tr class="separator:a41e6654691a4063ada8dfe404683d01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13078be413d8d93baa0de0704b677a77"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:a13078be413d8d93baa0de0704b677a77"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a13078be413d8d93baa0de0704b677a77">BEMTools::get_vertex_local_index_in_cell</a> (const Point&lt; spacedim &gt; &amp;v, const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;cell)</td></tr>
<tr class="separator:a13078be413d8d93baa0de0704b677a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7945f47146b05efcb2f00d0a9b825ad"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:ac7945f47146b05efcb2f00d0a9b825ad"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ac7945f47146b05efcb2f00d0a9b825ad">BEMTools::get_vertex_local_index_in_cell</a> (const Point&lt; spacedim &gt; &amp;v, const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const double threshold)</td></tr>
<tr class="separator:ac7945f47146b05efcb2f00d0a9b825ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33ac9e7d3357ca7f5a32e295d3aa515"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:af33ac9e7d3357ca7f5a32e295d3aa515"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; types::global_vertex_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#af33ac9e7d3357ca7f5a32e295d3aa515">BEMTools::get_vertex_indices_in_cell</a> (const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;cell)</td></tr>
<tr class="separator:af33ac9e7d3357ca7f5a32e295d3aa515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1485cd0b7cb158e497f54fc616f184b5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:a1485cd0b7cb158e497f54fc616f184b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a1485cd0b7cb158e497f54fc616f184b5">BEMTools::get_vertex_indices_in_cell</a> (const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;cell, std::array&lt; types::global_vertex_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;cell_vertex_indices)</td></tr>
<tr class="separator:a1485cd0b7cb158e497f54fc616f184b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b81f47313e428bf1a24bce156a7d56d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:a7b81f47313e428bf1a24bce156a7d56d"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; types::global_vertex_index, GeometryInfo&lt; dim &gt;::vertices_per_face &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a7b81f47313e428bf1a24bce156a7d56d">BEMTools::get_vertex_indices_in_face</a> (const typename Triangulation&lt; dim, spacedim &gt;::face_iterator &amp;face)</td></tr>
<tr class="separator:a7b81f47313e428bf1a24bce156a7d56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5115df83da745a7b2a10aa1395f5425"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:aa5115df83da745a7b2a10aa1395f5425"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#aa5115df83da745a7b2a10aa1395f5425">BEMTools::get_vertex_indices_in_face</a> (const typename Triangulation&lt; dim, spacedim &gt;::face_iterator &amp;face, std::array&lt; types::global_vertex_index, GeometryInfo&lt; dim &gt;::vertices_per_face &gt; &amp;face_vertex_indices)</td></tr>
<tr class="separator:aa5115df83da745a7b2a10aa1395f5425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e912800f54ad4ac14592bcfc67abaf"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a86e912800f54ad4ac14592bcfc67abaf"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a86e912800f54ad4ac14592bcfc67abaf">BEMTools::cell_distance</a> (const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator first_cell, const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator second_cell)</td></tr>
<tr class="separator:a86e912800f54ad4ac14592bcfc67abaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2768ba2d09997a9c24240126917a4f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:a2a2768ba2d09997a9c24240126917a4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a2a2768ba2d09997a9c24240126917a4f">BEMTools::shape_grad_matrix</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const std::vector&lt; unsigned int &gt; &amp;dof_permutation, const Point&lt; dim &gt; &amp;p)</td></tr>
<tr class="separator:a2a2768ba2d09997a9c24240126917a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73b7932d8c8dfa3ee6a0e2cb953694f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:ae73b7932d8c8dfa3ee6a0e2cb953694f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ae73b7932d8c8dfa3ee6a0e2cb953694f">BEMTools::mappingq_shape_grad_matrix</a> (const typename MappingQ&lt; dim, spacedim &gt;::InternalData &amp;mapping_data, const unsigned int point_no, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; &amp;grad_matrix)</td></tr>
<tr class="separator:ae73b7932d8c8dfa3ee6a0e2cb953694f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484b289338beefb5484dee38a0ffcf33"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:a484b289338beefb5484dee38a0ffcf33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a484b289338beefb5484dee38a0ffcf33">BEMTools::shape_grad_matrix_in_default_dof_order</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const Point&lt; dim &gt; &amp;p)</td></tr>
<tr class="separator:a484b289338beefb5484dee38a0ffcf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51fd05a62ff111a998f9182d3695c7b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:ad51fd05a62ff111a998f9182d3695c7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ad51fd05a62ff111a998f9182d3695c7b">BEMTools::shape_grad_matrix_in_lexicographic_order</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const Point&lt; dim &gt; &amp;p)</td></tr>
<tr class="separator:ad51fd05a62ff111a998f9182d3695c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c2a3eb5663ba13de32db528c29a3df"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:ae0c2a3eb5663ba13de32db528c29a3df"><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; RangeNumberType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ae0c2a3eb5663ba13de32db528c29a3df">BEMTools::shape_values</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const std::vector&lt; unsigned int &gt; &amp;dof_permutation, const Point&lt; dim &gt; &amp;p)</td></tr>
<tr class="separator:ae0c2a3eb5663ba13de32db528c29a3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c781d525abdbe2adfaccd41143b8601"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:a3c781d525abdbe2adfaccd41143b8601"><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; RangeNumberType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a3c781d525abdbe2adfaccd41143b8601">BEMTools::shape_values_in_default_dof_order</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const Point&lt; dim &gt; &amp;p)</td></tr>
<tr class="separator:a3c781d525abdbe2adfaccd41143b8601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af072e86a2bc89a42df13f97d591bd232"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:af072e86a2bc89a42df13f97d591bd232"><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; RangeNumberType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#af072e86a2bc89a42df13f97d591bd232">BEMTools::shape_values_in_lexicographic_order</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const Point&lt; dim &gt; &amp;p)</td></tr>
<tr class="separator:af072e86a2bc89a42df13f97d591bd232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4f7fd9f365a6c67ada7ecfe19eaf55"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:a1b4f7fd9f365a6c67ada7ecfe19eaf55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a1b4f7fd9f365a6c67ada7ecfe19eaf55">BEMTools::collect_two_components_from_point3</a> (const std::vector&lt; Point&lt; spacedim, RangeNumberType &gt; &gt; &amp;points, const unsigned int first_component, const unsigned int second_component)</td></tr>
<tr class="separator:a1b4f7fd9f365a6c67ada7ecfe19eaf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a48195400075d2a710c606820809198"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:a6a48195400075d2a710c606820809198"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a6a48195400075d2a710c606820809198">BEMTools::collect_two_components_from_point3</a> (const std::vector&lt; Point&lt; spacedim, RangeNumberType &gt; &gt; &amp;points, const unsigned int effective_point_num, const unsigned int first_component, const unsigned int second_component)</td></tr>
<tr class="separator:a6a48195400075d2a710c606820809198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c0407609b6e00b0bd8dc4d3b2d44e4"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:ab5c0407609b6e00b0bd8dc4d3b2d44e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ab5c0407609b6e00b0bd8dc4d3b2d44e4">BEMTools::collect_components_from_points</a> (const std::vector&lt; Point&lt; spacedim, RangeNumberType &gt; &gt; &amp;points)</td></tr>
<tr class="separator:ab5c0407609b6e00b0bd8dc4d3b2d44e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ccdbfb2ba8452279ff3f00230aa7c1"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:ab6ccdbfb2ba8452279ff3f00230aa7c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ab6ccdbfb2ba8452279ff3f00230aa7c1">BEMTools::collect_components_from_points</a> (const std::vector&lt; Point&lt; spacedim, RangeNumberType &gt; &gt; &amp;points, const unsigned int point_num)</td></tr>
<tr class="separator:ab6ccdbfb2ba8452279ff3f00230aa7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa978ce647ef955d8489beab14ef69277"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:aa978ce647ef955d8489beab14ef69277"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Point&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#aa978ce647ef955d8489beab14ef69277">BEMTools::get_unit_support_points_with_permutation</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const std::vector&lt; unsigned int &gt; &amp;dof_permutation)</td></tr>
<tr class="separator:aa978ce647ef955d8489beab14ef69277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74958336c126d0cde338d9779947d79f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:a74958336c126d0cde338d9779947d79f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a74958336c126d0cde338d9779947d79f">BEMTools::get_unit_support_points_with_permutation</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const std::vector&lt; unsigned int &gt; &amp;dof_permutation, std::vector&lt; Point&lt; dim &gt; &gt; &amp;permuted_unit_support_points)</td></tr>
<tr class="separator:a74958336c126d0cde338d9779947d79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33884decde7a3f2009c3d88f239ee97"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:aa33884decde7a3f2009c3d88f239ee97"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Point&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#aa33884decde7a3f2009c3d88f239ee97">BEMTools::get_lexicographic_unit_support_points</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe)</td></tr>
<tr class="separator:aa33884decde7a3f2009c3d88f239ee97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa08482472a78ac3f228e8be78b0448d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:afa08482472a78ac3f228e8be78b0448d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#afa08482472a78ac3f228e8be78b0448d">BEMTools::get_lexicographic_unit_support_points</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; Point&lt; dim &gt; &gt; &amp;lexicographic_unit_support_points)</td></tr>
<tr class="separator:afa08482472a78ac3f228e8be78b0448d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13de33f923c12e1234484f3c9f07e857"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:a13de33f923c12e1234484f3c9f07e857"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Point&lt; spacedim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a13de33f923c12e1234484f3c9f07e857">BEMTools::get_support_points_in_real_cell</a> (const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const MappingQ&lt; dim, spacedim &gt; &amp;mapping, const std::vector&lt; unsigned int &gt; &amp;dof_permutation)</td></tr>
<tr class="separator:a13de33f923c12e1234484f3c9f07e857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a6fe3c8cae035a198b247e5a074605"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:ad1a6fe3c8cae035a198b247e5a074605"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ad1a6fe3c8cae035a198b247e5a074605">BEMTools::get_support_points_in_real_cell</a> (const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const MappingQ&lt; dim, spacedim &gt; &amp;mapping, const std::vector&lt; unsigned int &gt; &amp;dof_permutation, std::vector&lt; Point&lt; spacedim &gt; &gt; &amp;support_points_in_real_cell)</td></tr>
<tr class="separator:ad1a6fe3c8cae035a198b247e5a074605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ea7211efc8041a41d3cacae9729a47"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad1ea7211efc8041a41d3cacae9729a47"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Point&lt; spacedim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ad1ea7211efc8041a41d3cacae9729a47">BEMTools::get_support_points_in_default_dof_order_in_real_cell</a> (const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const MappingQ&lt; dim, spacedim &gt; &amp;mapping)</td></tr>
<tr class="separator:ad1ea7211efc8041a41d3cacae9729a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc8cd33010224d89249c98e200fed68"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a2fc8cd33010224d89249c98e200fed68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a2fc8cd33010224d89249c98e200fed68">BEMTools::get_support_points_in_default_dof_order_in_real_cell</a> (const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const MappingQ&lt; dim, spacedim &gt; &amp;mapping, std::vector&lt; Point&lt; spacedim &gt; &gt; &amp;support_points_in_reall_cell)</td></tr>
<tr class="separator:a2fc8cd33010224d89249c98e200fed68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584635f5c9ca0dc37ad7f8efffff918a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a584635f5c9ca0dc37ad7f8efffff918a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Point&lt; spacedim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a584635f5c9ca0dc37ad7f8efffff918a">BEMTools::get_lexicographic_support_points_in_real_cell</a> (const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const MappingQ&lt; dim, spacedim &gt; &amp;mapping)</td></tr>
<tr class="separator:a584635f5c9ca0dc37ad7f8efffff918a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858771b41a3e5403f2dd4ea81d15fc0b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a858771b41a3e5403f2dd4ea81d15fc0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a858771b41a3e5403f2dd4ea81d15fc0b">BEMTools::get_lexicographic_support_points_in_real_cell</a> (const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const MappingQ&lt; dim, spacedim &gt; &amp;mapping, std::vector&lt; Point&lt; spacedim &gt; &gt; &amp;support_points_in_real_cell)</td></tr>
<tr class="separator:a858771b41a3e5403f2dd4ea81d15fc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145e895ba470df9107942b4712c31487"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:a145e895ba470df9107942b4712c31487"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a145e895ba470df9107942b4712c31487">BEMTools::get_dofs_per_face_for_fe</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe)</td></tr>
<tr class="separator:a145e895ba470df9107942b4712c31487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac435f8e40663d510949ec0e686a4d0da"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac435f8e40663d510949ec0e686a4d0da"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; Point&lt; dim &gt;, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ac435f8e40663d510949ec0e686a4d0da">BEMTools::get_vertices_from_lexicographic_unit_support_points</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const bool is_counter_clockwise_ordered=false)</td></tr>
<tr class="separator:ac435f8e40663d510949ec0e686a4d0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2efea26e03b8770008388a5e2e3562d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae2efea26e03b8770008388a5e2e3562d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ae2efea26e03b8770008388a5e2e3562d">BEMTools::get_vertices_from_lexicographic_unit_support_points</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe, std::array&lt; Point&lt; dim &gt;, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;vertices, const bool is_counter_clockwise_ordered=false)</td></tr>
<tr class="separator:ae2efea26e03b8770008388a5e2e3562d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8390f574b7614a43eddacc54c09056c6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8390f574b7614a43eddacc54c09056c6"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; Point&lt; spacedim &gt;, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a8390f574b7614a43eddacc54c09056c6">BEMTools::get_vertices_from_lexicographic_support_points_in_real_cell</a> (const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const Mapping&lt; dim, spacedim &gt; &amp;mapping, const bool is_counter_clockwise_ordered=false)</td></tr>
<tr class="separator:a8390f574b7614a43eddacc54c09056c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97aae746b6f2b9f0460236e7c86fb010"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a97aae746b6f2b9f0460236e7c86fb010"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a97aae746b6f2b9f0460236e7c86fb010">BEMTools::get_vertices_from_lexicographic_support_points_in_real_cell</a> (const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const FiniteElement&lt; dim, spacedim &gt; &amp;fe, const Mapping&lt; dim, spacedim &gt; &amp;mapping, std::array&lt; Point&lt; spacedim &gt;, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;vertices_in_real_cell, const bool is_counter_clockwise_ordered=false)</td></tr>
<tr class="separator:a97aae746b6f2b9f0460236e7c86fb010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707ab3548bbb938d36c842a1be12918b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a707ab3548bbb938d36c842a1be12918b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; types::global_dof_index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a707ab3548bbb938d36c842a1be12918b">BEMTools::get_lexicographic_dof_indices</a> (const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator &amp;cell)</td></tr>
<tr class="separator:a707ab3548bbb938d36c842a1be12918b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d853270a62786b95a7c69a00bde09a6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a2d853270a62786b95a7c69a00bde09a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a2d853270a62786b95a7c69a00bde09a6">BEMTools::get_lexicographic_dof_indices</a> (const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator &amp;cell, std::vector&lt; types::global_dof_index &gt; &amp;lexicographic_dof_indices)</td></tr>
<tr class="separator:a2d853270a62786b95a7c69a00bde09a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158fbe38db043178d2ab25653a6b96dd"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a158fbe38db043178d2ab25653a6b96dd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; types::global_dof_index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a158fbe38db043178d2ab25653a6b96dd">BEMTools::get_vertex_dof_indices_from_lexicographic_dof_indices</a> (const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const bool is_counter_clockwise_ordered=false)</td></tr>
<tr class="separator:a158fbe38db043178d2ab25653a6b96dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ecd357c6a8e71bbc617f41cfe04057"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:a13ecd357c6a8e71bbc617f41cfe04057"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a13ecd357c6a8e71bbc617f41cfe04057">BEMTools::get_vertex_dof_indices_from_lexicographic_dof_indices</a> (const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator &amp;cell, std::array&lt; types::global_dof_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;vertex_dof_indices, const bool is_counter_clockwise_ordered=false)</td></tr>
<tr class="separator:a13ecd357c6a8e71bbc617f41cfe04057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeaa2dd69432dd427d339e692127bdaf"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:adeaa2dd69432dd427d339e692127bdaf"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; types::global_dof_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#adeaa2dd69432dd427d339e692127bdaf">BEMTools::get_vertex_dof_indices_in_cell</a> (const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const Mapping&lt; dim, spacedim &gt; &amp;mapping, const double threshold=1e-12)</td></tr>
<tr class="separator:adeaa2dd69432dd427d339e692127bdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8217a92ffb68d5f2efc493f191a1845"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af8217a92ffb68d5f2efc493f191a1845"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#af8217a92ffb68d5f2efc493f191a1845">BEMTools::get_vertex_dof_indices_in_cell</a> (const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const Mapping&lt; dim, spacedim &gt; &amp;mapping, std::array&lt; types::global_dof_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;cell_vertex_dof_indices, const double threshold=1e-12)</td></tr>
<tr class="separator:af8217a92ffb68d5f2efc493f191a1845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff5cecfcf23c3a4c50813d8124524c8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:afff5cecfcf23c3a4c50813d8124524c8"><td class="memTemplItemLeft" align="right" valign="top">types::global_dof_index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#afff5cecfcf23c3a4c50813d8124524c8">BEMTools::get_dof_index_for_vertex_in_cell</a> (const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const Mapping&lt; dim, spacedim &gt; &amp;mapping, const unsigned int local_vertex_index_in_cell, const double threshold=1e-12)</td></tr>
<tr class="separator:afff5cecfcf23c3a4c50813d8124524c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799b4346d59d685c4c3c0dcfab77f4d7"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a799b4346d59d685c4c3c0dcfab77f4d7"><td class="memTemplItemLeft" align="right" valign="top">CellNeighboringType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a799b4346d59d685c4c3c0dcfab77f4d7">BEMTools::detect_cell_neighboring_type_for_same_triangulations</a> (const std::array&lt; types::global_vertex_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;first_cell_vertex_indices, const std::array&lt; types::global_vertex_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;second_cell_vertex_indices, std::vector&lt; types::global_vertex_index &gt; &amp;common_vertex_indices)</td></tr>
<tr class="separator:a799b4346d59d685c4c3c0dcfab77f4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290bfb641f1d9609b691523086feeaa4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a290bfb641f1d9609b691523086feeaa4"><td class="memTemplItemLeft" align="right" valign="top">CellNeighboringType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a290bfb641f1d9609b691523086feeaa4">BEMTools::detect_cell_neighboring_type_for_same_triangulations</a> (const typename Triangulation&lt; dim, spacedim &gt;::active_cell_iterator &amp;first_cell_iter, const typename Triangulation&lt; dim, spacedim &gt;::active_cell_iterator &amp;second_cell_iter, std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt; &amp;common_vertex_pair_local_indices)</td></tr>
<tr class="separator:a290bfb641f1d9609b691523086feeaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bda426ba151b68f1f1ecdfb78c62087"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:a1bda426ba151b68f1f1ecdfb78c62087"><td class="memTemplItemLeft" align="right" valign="top">CellNeighboringType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a1bda426ba151b68f1f1ecdfb78c62087">BEMTools::detect_cell_neighboring_type_for_same_triangulations</a> (const typename DoFHandler&lt; dim, spacedim &gt;::active_cell_iterator &amp;first_cell_iter, const typename DoFHandler&lt; dim, spacedim &gt;::active_cell_iterator &amp;second_cell_iter, const Mapping&lt; dim, spacedim &gt; &amp;first_cell_mapping, const Mapping&lt; dim, spacedim &gt; &amp;second_cell_mapping, std::vector&lt; std::pair&lt; types::global_dof_index, types::global_dof_index &gt; &gt; &amp;common_vertex_pair_dof_indices, const double threshold=1e-12)</td></tr>
<tr class="separator:a1bda426ba151b68f1f1ecdfb78c62087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c3b7582fa3a94b950d83cb4a7aa70c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad1c3b7582fa3a94b950d83cb4a7aa70c"><td class="memTemplItemLeft" align="right" valign="top">CellNeighboringType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ad1c3b7582fa3a94b950d83cb4a7aa70c">BEMTools::detect_cell_neighboring_type_for_different_triangulations</a> (const typename Triangulation&lt; dim, spacedim &gt;::active_cell_iterator &amp;first_cell_iter, const typename Triangulation&lt; dim, spacedim &gt;::active_cell_iterator &amp;second_cell_iter, const std::map&lt; typename Triangulation&lt; dim, spacedim &gt;::cell_iterator, typename Triangulation&lt; dim+1, spacedim &gt;::face_iterator &gt; &amp;map_from_first_boundary_mesh_to_volume_mesh, const std::map&lt; typename Triangulation&lt; dim, spacedim &gt;::cell_iterator, typename Triangulation&lt; dim+1, spacedim &gt;::face_iterator &gt; &amp;map_from_second_boundary_mesh_to_volume_mesh, std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt; &amp;common_vertex_pair_local_indices)</td></tr>
<tr class="separator:ad1c3b7582fa3a94b950d83cb4a7aa70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1da697fedf1996a826659eb38bb93c8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:ad1da697fedf1996a826659eb38bb93c8"><td class="memTemplItemLeft" align="right" valign="top">CellNeighboringType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ad1da697fedf1996a826659eb38bb93c8">BEMTools::detect_cell_neighboring_type_for_different_triangulations</a> (const typename DoFHandler&lt; dim, spacedim &gt;::active_cell_iterator &amp;first_cell_iter, const typename DoFHandler&lt; dim, spacedim &gt;::active_cell_iterator &amp;second_cell_iter, const Mapping&lt; dim, spacedim &gt; &amp;first_cell_mapping, const Mapping&lt; dim, spacedim &gt; &amp;second_cell_mapping, const std::map&lt; typename Triangulation&lt; dim, spacedim &gt;::cell_iterator, typename Triangulation&lt; dim+1, spacedim &gt;::face_iterator &gt; &amp;map_from_first_boundary_mesh_to_volume_mesh, const std::map&lt; typename Triangulation&lt; dim, spacedim &gt;::cell_iterator, typename Triangulation&lt; dim+1, spacedim &gt;::face_iterator &gt; &amp;map_from_second_boundary_mesh_to_volume_mesh, std::vector&lt; std::pair&lt; types::global_dof_index, types::global_dof_index &gt; &gt; &amp;common_vertex_pair_dof_indices, const double threshold=1e-12)</td></tr>
<tr class="separator:ad1da697fedf1996a826659eb38bb93c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa498e6f98ba5db0fa6e14678fdad077a"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:aa498e6f98ba5db0fa6e14678fdad077a"><td class="memTemplItemLeft" align="right" valign="top">CellNeighboringType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#aa498e6f98ba5db0fa6e14678fdad077a">BEMTools::detect_cell_neighboring_type_for_same_h1_dofhandlers</a> (const std::array&lt; types::global_dof_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;first_cell_vertex_dof_indices, const std::array&lt; types::global_dof_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;second_cell_vertex_dof_indices, std::vector&lt; types::global_dof_index &gt; &amp;vertex_dof_index_intersection)</td></tr>
<tr class="separator:aa498e6f98ba5db0fa6e14678fdad077a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f943a5da0fb2f260e47f09c80a2fd1f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:a0f943a5da0fb2f260e47f09c80a2fd1f"><td class="memTemplItemLeft" align="right" valign="top">CellNeighboringType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a0f943a5da0fb2f260e47f09c80a2fd1f">BEMTools::detect_cell_neighboring_type_for_same_dofhandlers</a> (const typename DoFHandler&lt; dim, spacedim &gt;::active_cell_iterator &amp;first_cell_iter, const typename DoFHandler&lt; dim, spacedim &gt;::active_cell_iterator &amp;second_cell_iter, const Mapping&lt; dim, spacedim &gt; &amp;first_cell_mapping, const Mapping&lt; dim, spacedim &gt; &amp;second_cell_mapping, std::vector&lt; std::pair&lt; types::global_dof_index, types::global_dof_index &gt; &gt; &amp;common_vertex_pair_dof_indices, const double threshold=1e-12)</td></tr>
<tr class="separator:a0f943a5da0fb2f260e47f09c80a2fd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93294840a5dc47509b1b0cd1adf8115"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af93294840a5dc47509b1b0cd1adf8115"><td class="memTemplItemLeft" align="right" valign="top">CellNeighboringType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#af93294840a5dc47509b1b0cd1adf8115">BEMTools::detect_cell_neighboring_type</a> (const DetectCellNeighboringTypeMethod method_for_cell_neighboring_type, const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;first_cell_iter, const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;second_cell_iter, const std::map&lt; typename Triangulation&lt; dim, spacedim &gt;::cell_iterator, typename Triangulation&lt; dim+1, spacedim &gt;::face_iterator &gt; &amp;map_from_first_boundary_mesh_to_volume_mesh, const std::map&lt; typename Triangulation&lt; dim, spacedim &gt;::cell_iterator, typename Triangulation&lt; dim+1, spacedim &gt;::face_iterator &gt; &amp;map_from_second_boundary_mesh_to_volume_mesh, std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt; &amp;common_vertex_pair_local_indices)</td></tr>
<tr class="separator:af93294840a5dc47509b1b0cd1adf8115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540d41c166ed0a7ff6ba14cdcb4f8a12"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a540d41c166ed0a7ff6ba14cdcb4f8a12"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a540d41c166ed0a7ff6ba14cdcb4f8a12">BEMTools::surface_jacobian_det</a> (const unsigned int k3_index, const unsigned int quad_no, const Table&lt; 2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; double &gt; &gt; &amp;shape_grad_matrix_table, const std::vector&lt; Point&lt; spacedim &gt; &gt; &amp;support_points_in_real_cell)</td></tr>
<tr class="separator:a540d41c166ed0a7ff6ba14cdcb4f8a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa673117ada74df9b8c21b85e5cc89523"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:aa673117ada74df9b8c21b85e5cc89523"><td class="memTemplItemLeft" align="right" valign="top">RangeNumberType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#aa673117ada74df9b8c21b85e5cc89523">BEMTools::surface_jacobian_det_and_normal_vector</a> (const unsigned int k3_index, const unsigned int quad_no, const Table&lt; 3, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; &gt; &amp;mapping_shape_grad_matrix_table, const unsigned int mapping_index, const unsigned int mapping_n_shape_functions, const std::vector&lt; Point&lt; spacedim, RangeNumberType &gt; &gt; &amp;support_points_in_real_cell, Tensor&lt; 1, spacedim, RangeNumberType &gt; &amp;normal_vector, const bool is_normal_vector_negated=false)</td></tr>
<tr class="separator:aa673117ada74df9b8c21b85e5cc89523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1736192c10f32e6b8299b3830042967f"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:a1736192c10f32e6b8299b3830042967f"><td class="memTemplItemLeft" align="right" valign="top">RangeNumberType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a1736192c10f32e6b8299b3830042967f">BEMTools::surface_jacobian_det_and_normal_vector</a> (const std::vector&lt; Point&lt; spacedim, RangeNumberType &gt; &gt; &amp;mapping_support_points, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; &amp;mapping_shape_grad_matrix, Tensor&lt; 1, spacedim, RangeNumberType &gt; &amp;normal_vector, const bool is_normal_vector_negated=false)</td></tr>
<tr class="separator:a1736192c10f32e6b8299b3830042967f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa0caa4b0da46471fdd2531013032fe"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:a1fa0caa4b0da46471fdd2531013032fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a1fa0caa4b0da46471fdd2531013032fe">BEMTools::surface_covariant_transformation</a> (const unsigned int k3_index, const unsigned int quad_no, const Table&lt; 3, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; &gt; &amp;mapping_shape_grad_matrix_table, const unsigned int mapping_index, const unsigned int mapping_n_shape_functions, const std::vector&lt; Point&lt; spacedim, RangeNumberType &gt; &gt; &amp;support_points_in_real_cell)</td></tr>
<tr class="separator:a1fa0caa4b0da46471fdd2531013032fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94cf6187cecd1d1f385af48fa618079"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:af94cf6187cecd1d1f385af48fa618079"><td class="memTemplItemLeft" align="right" valign="top">Point&lt; spacedim, RangeNumberType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#af94cf6187cecd1d1f385af48fa618079">BEMTools::transform_quad_point_from_unit_to_permuted_real_cell</a> (const unsigned int k3_index, const unsigned int quad_no, const Table&lt; 4, RangeNumberType &gt; &amp;mapping_shape_value_table, const unsigned int mapping_index, const unsigned int mapping_n_shape_functions, const std::vector&lt; Point&lt; spacedim, RangeNumberType &gt; &gt; &amp;mapping_support_points_in_real_cell)</td></tr>
<tr class="separator:af94cf6187cecd1d1f385af48fa618079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95886a7832060e67dc7d7af0351c539"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad95886a7832060e67dc7d7af0351c539"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ad95886a7832060e67dc7d7af0351c539">BEMTools::generate_forward_dof_permutation</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe, unsigned int starting_corner)</td></tr>
<tr class="separator:ad95886a7832060e67dc7d7af0351c539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a0aebc243f59f4f82de32ae76536e3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a13a0aebc243f59f4f82de32ae76536e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a13a0aebc243f59f4f82de32ae76536e3">BEMTools::generate_forward_dof_permutation</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe, unsigned int starting_corner, std::vector&lt; unsigned int &gt; &amp;dof_permutation)</td></tr>
<tr class="separator:a13a0aebc243f59f4f82de32ae76536e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b416bc990fda99b201e698235f55885"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8b416bc990fda99b201e698235f55885"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a8b416bc990fda99b201e698235f55885">BEMTools::generate_forward_mapping_support_point_permutation</a> (const <a class="el" href="classMappingQExt.html">MappingQExt</a>&lt; dim, spacedim &gt; &amp;mapping, unsigned int starting_corner)</td></tr>
<tr class="separator:a8b416bc990fda99b201e698235f55885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59cbb707dc8607441ae981d9dfc7127"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad59cbb707dc8607441ae981d9dfc7127"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ad59cbb707dc8607441ae981d9dfc7127">BEMTools::generate_forward_mapping_support_point_permutation</a> (const <a class="el" href="classMappingQExt.html">MappingQExt</a>&lt; dim, spacedim &gt; &amp;mapping, unsigned int starting_corner, std::vector&lt; unsigned int &gt; &amp;support_point_permutation)</td></tr>
<tr class="separator:ad59cbb707dc8607441ae981d9dfc7127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8120e883e228151169796eb22267bac4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8120e883e228151169796eb22267bac4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#a8120e883e228151169796eb22267bac4">BEMTools::generate_backward_dof_permutation</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe, unsigned int starting_corner)</td></tr>
<tr class="separator:a8120e883e228151169796eb22267bac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4446369f0c840e5f28c33d791d3635c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aa4446369f0c840e5f28c33d791d3635c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#aa4446369f0c840e5f28c33d791d3635c">BEMTools::generate_backward_dof_permutation</a> (const FiniteElement&lt; dim, spacedim &gt; &amp;fe, unsigned int starting_corner, std::vector&lt; unsigned int &gt; &amp;dof_permutation)</td></tr>
<tr class="separator:aa4446369f0c840e5f28c33d791d3635c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c091154e7bfa400931a59adc5215eb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae5c091154e7bfa400931a59adc5215eb"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ae5c091154e7bfa400931a59adc5215eb">BEMTools::generate_backward_mapping_support_point_permutation</a> (const <a class="el" href="classMappingQExt.html">MappingQExt</a>&lt; dim, spacedim &gt; &amp;mapping, unsigned int starting_corner)</td></tr>
<tr class="separator:ae5c091154e7bfa400931a59adc5215eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11358807b8864a94999ded7ee28ae2d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab11358807b8864a94999ded7ee28ae2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="bem__tools_8h.html#ab11358807b8864a94999ded7ee28ae2d">BEMTools::generate_backward_mapping_support_point_permutation</a> (const <a class="el" href="classMappingQExt.html">MappingQExt</a>&lt; dim, spacedim &gt; &amp;mapping, unsigned int starting_corner, std::vector&lt; unsigned int &gt; &amp;support_point_permutation)</td></tr>
<tr class="separator:ab11358807b8864a94999ded7ee28ae2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Introduction of <a class="el" href="bem__tools_8h.html" title="Introduction of bem_tools.h.">bem_tools.h</a>. </p>
<dl class="section date"><dt>Date</dt><dd>2022-03-03 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jihuan Tian </dd></dl>

<p class="definition">Definition in file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac598f13dff89eec0f9a89e14be4c8ce4" name="ac598f13dff89eec0f9a89e14be4c8ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac598f13dff89eec0f9a89e14be4c8ce4">&#9670;&nbsp;</a></span>CellNeighboringType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bem__tools_8h.html#ac598f13dff89eec0f9a89e14be4c8ce4">BEMTools::CellNeighboringType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Different cell neighboring types </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac598f13dff89eec0f9a89e14be4c8ce4a351e4010587b7642f235dc8f81091509" name="ac598f13dff89eec0f9a89e14be4c8ce4a351e4010587b7642f235dc8f81091509"></a>SamePanel&#160;</td><td class="fielddoc"><p >SamePanel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac598f13dff89eec0f9a89e14be4c8ce4a3ce0b018d91fa590a3ebf7d7cbd9d00c" name="ac598f13dff89eec0f9a89e14be4c8ce4a3ce0b018d91fa590a3ebf7d7cbd9d00c"></a>CommonEdge&#160;</td><td class="fielddoc"><p >CommonEdge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac598f13dff89eec0f9a89e14be4c8ce4ad08555431f2c2393ecd12012ea653fcd" name="ac598f13dff89eec0f9a89e14be4c8ce4ad08555431f2c2393ecd12012ea653fcd"></a>CommonVertex&#160;</td><td class="fielddoc"><p >CommonVertex. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac598f13dff89eec0f9a89e14be4c8ce4ab36ab01f71e16f479bf03f5afa2f963f" name="ac598f13dff89eec0f9a89e14be4c8ce4ab36ab01f71e16f479bf03f5afa2f963f"></a>Regular&#160;</td><td class="fielddoc"><p >Regular. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac598f13dff89eec0f9a89e14be4c8ce4a395bda70f2c3365a36cd288553e8725f" name="ac598f13dff89eec0f9a89e14be4c8ce4a395bda70f2c3365a36cd288553e8725f"></a>None&#160;</td><td class="fielddoc"><p >None. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00065">65</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

</div>
</div>
<a id="aae8e4ecff83e921d0744a9fcc9b60604" name="aae8e4ecff83e921d0744a9fcc9b60604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8e4ecff83e921d0744a9fcc9b60604">&#9670;&nbsp;</a></span>DetectCellNeighboringTypeMethod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bem__tools_8h.html#aae8e4ecff83e921d0744a9fcc9b60604">BEMTools::DetectCellNeighboringTypeMethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Different scenarios for detecting cell neighboring types </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aae8e4ecff83e921d0744a9fcc9b60604a09b6ea754926fcaa6ce349245a0ca904" name="aae8e4ecff83e921d0744a9fcc9b60604a09b6ea754926fcaa6ce349245a0ca904"></a>SameTriangulations&#160;</td><td class="fielddoc"><p >SameTriangulations. </p>
</td></tr>
<tr><td class="fieldname"><a id="aae8e4ecff83e921d0744a9fcc9b60604ad9dfbabe60b6ddc901fd0f211c9fcce8" name="aae8e4ecff83e921d0744a9fcc9b60604ad9dfbabe60b6ddc901fd0f211c9fcce8"></a>DifferentTriangulations&#160;</td><td class="fielddoc"><p >DifferentTriangulations. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00078">78</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a86e912800f54ad4ac14592bcfc67abaf" name="a86e912800f54ad4ac14592bcfc67abaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e912800f54ad4ac14592bcfc67abaf">&#9670;&nbsp;</a></span>cell_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number BEMTools::cell_distance </td>
          <td>(</td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator&#160;</td>
          <td class="paramname"><em>first_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator&#160;</td>
          <td class="paramname"><em>second_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the distance between the centers of two cells.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_cell</td><td></td></tr>
    <tr><td class="paramname">second_cell</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00335">335</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00335">BEMTools::cell_distance()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l00335">BEMTools::cell_distance()</a>.</p>

</div>
</div>
<a id="a2a1b92caf9f55da16a320124c4e38886" name="a2a1b92caf9f55da16a320124c4e38886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1b92caf9f55da16a320124c4e38886">&#9670;&nbsp;</a></span>cell_neighboring_type_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * BEMTools::cell_neighboring_type_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bem__tools_8h.html#ac598f13dff89eec0f9a89e14be4c8ce4">CellNeighboringType</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the string representation of the cell neighboring type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00092">92</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00092">BEMTools::cell_neighboring_type_name()</a>.</p>

<p class="reference">Referenced by <a class="el" href="sauter__quadrature_8hcu_source.html#l04555">CUDAWrappers::SauterQuadratureTaskRingBuffer&lt; capacity, dim, spacedim, RangeNumberType, KernelNumberType &gt;::add_task()</a>, <a class="el" href="bem__tools_8h_source.html#l00092">BEMTools::cell_neighboring_type_name()</a>, and <a class="el" href="sauter__quadrature_8hcu_source.html#l04735">CUDAWrappers::SauterQuadratureTaskRingBuffer&lt; capacity, dim, spacedim, RangeNumberType, KernelNumberType &gt;::fetch_and_process_task_batch()</a>.</p>

</div>
</div>
<a id="ab5c0407609b6e00b0bd8dc4d3b2d44e4" name="ab5c0407609b6e00b0bd8dc4d3b2d44e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c0407609b6e00b0bd8dc4d3b2d44e4">&#9670;&nbsp;</a></span>collect_components_from_points() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; BEMTools::collect_components_from_points </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim, RangeNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Collect coordinate components from the list of points in \(\mathbb{R}^d\). The obtained coordinate matrix has this format: </p><p class="formulaDsp">
\[
\begin{pmatrix}
x_1(1) &amp; \cdots &amp; x_1(k) \\
\vdots &amp; \vdots &amp; \vdots \\
x_d(1) &amp; \cdots &amp; x_d(k)
\end{pmatrix}
\]
</p>
<p> where \(k\) is the number of points and \(x(i)\) is the i-th point in the list.</p>
<dl class="section note">
<dt>Note</dt>
<dd>This function will be used for calculating the Jacobian matrix. Let \(DN\) be the matrix of first order derivatives of shape functions and \(P\) be the resulted coordinate matrix. Then [ J = P \cdot DN ]</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00679">679</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00679">BEMTools::collect_components_from_points()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l00679">BEMTools::collect_components_from_points()</a>, and <a class="el" href="bem__tools_8h_source.html#l03195">BEMTools::surface_covariant_transformation()</a>.</p>

</div>
</div>
<a id="ab6ccdbfb2ba8452279ff3f00230aa7c1" name="ab6ccdbfb2ba8452279ff3f00230aa7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ccdbfb2ba8452279ff3f00230aa7c1">&#9670;&nbsp;</a></span>collect_components_from_points() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; BEMTools::collect_components_from_points </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim, RangeNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>point_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This overloaded function only use the first <code>point_num</code> number of points.</p>
<dl class="section pre"><dt>Precondition</dt><dd></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">spacedim</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td></td></tr>
    <tr><td class="paramname">point_num</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00708">708</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00679">BEMTools::collect_components_from_points()</a>.</p>

</div>
</div>
<a id="a6a48195400075d2a710c606820809198" name="a6a48195400075d2a710c606820809198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a48195400075d2a710c606820809198">&#9670;&nbsp;</a></span>collect_two_components_from_point3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; BEMTools::collect_two_components_from_point3 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim, RangeNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>effective_point_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>first_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>second_component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Collect two coordinate components from the list of points in 3D space. Only the first <code>effective_point_num</code> will be used.</p>
<dl class="section note">
<dt>Note</dt>
<dd>This function is useful in constructing the surface metric tensor or surface normal vector.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>A list of points in 3D space </td></tr>
    <tr><td class="paramname">effective_point_num</td><td>Number of points to be used. </td></tr>
    <tr><td class="paramname">first_component</td><td>Index for the first coordinate component to be collected </td></tr>
    <tr><td class="paramname">second_component</td><td>Index for the second coordinate component to be collected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix storing the two coordinate components for all points. It has a dimension <code>2*points</code>.<a class="el" href="generic__functors_8h.html#add0dd2e12ca1b1712987b071d95d07d8">size()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00631">631</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00593">BEMTools::collect_two_components_from_point3()</a>.</p>

</div>
</div>
<a id="a1b4f7fd9f365a6c67ada7ecfe19eaf55" name="a1b4f7fd9f365a6c67ada7ecfe19eaf55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4f7fd9f365a6c67ada7ecfe19eaf55">&#9670;&nbsp;</a></span>collect_two_components_from_point3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; BEMTools::collect_two_components_from_point3 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim, RangeNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>first_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>second_component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Collect two coordinate components from the list of points in 3D space.</p>
<dl class="section note">
<dt>Note</dt>
<dd>This function is useful in constructing the surface metric tensor or surface normal vector.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>A list of points in 3D space </td></tr>
    <tr><td class="paramname">first_component</td><td>Index for the first coordinate component to be collected </td></tr>
    <tr><td class="paramname">second_component</td><td>Index for the second coordinate component to be collected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix storing the two coordinate components for all points. It has a dimension <code>2*points</code>.<a class="el" href="generic__functors_8h.html#add0dd2e12ca1b1712987b071d95d07d8">size()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00593">593</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00593">BEMTools::collect_two_components_from_point3()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l00593">BEMTools::collect_two_components_from_point3()</a>, <a class="el" href="bem__tools_8h_source.html#l02984">BEMTools::surface_jacobian_det()</a>, and <a class="el" href="bem__tools_8h_source.html#l03043">BEMTools::surface_jacobian_det_and_normal_vector()</a>.</p>

</div>
</div>
<a id="af93294840a5dc47509b1b0cd1adf8115" name="af93294840a5dc47509b1b0cd1adf8115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93294840a5dc47509b1b0cd1adf8115">&#9670;&nbsp;</a></span>detect_cell_neighboring_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CellNeighboringType BEMTools::detect_cell_neighboring_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bem__tools_8h.html#aae8e4ecff83e921d0744a9fcc9b60604">DetectCellNeighboringTypeMethod</a>&#160;</td>
          <td class="paramname"><em>method_for_cell_neighboring_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>first_cell_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>second_cell_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; typename Triangulation&lt; dim, spacedim &gt;::cell_iterator, typename Triangulation&lt; dim+1, spacedim &gt;::face_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>map_from_first_boundary_mesh_to_volume_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; typename Triangulation&lt; dim, spacedim &gt;::cell_iterator, typename Triangulation&lt; dim+1, spacedim &gt;::face_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>map_from_second_boundary_mesh_to_volume_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>common_vertex_pair_local_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Detect the neighboring type of two cells based on their vertex indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method_for_cell_neighboring_type</td><td></td></tr>
    <tr><td class="paramname">first_cell_iter</td><td></td></tr>
    <tr><td class="paramname">second_cell_iter</td><td></td></tr>
    <tr><td class="paramname">map_from_first_boundary_mesh_to_volume_mesh</td><td></td></tr>
    <tr><td class="paramname">map_from_second_boundary_mesh_to_volume_mesh</td><td></td></tr>
    <tr><td class="paramname">common_vertex_pair_local_indices</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l02914">2914</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l02914">BEMTools::detect_cell_neighboring_type()</a>, <a class="el" href="bem__tools_8h_source.html#l02322">BEMTools::detect_cell_neighboring_type_for_different_triangulations()</a>, and <a class="el" href="bem__tools_8h_source.html#l01994">BEMTools::detect_cell_neighboring_type_for_same_triangulations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l02914">BEMTools::detect_cell_neighboring_type()</a>.</p>

</div>
</div>
<a id="ad1da697fedf1996a826659eb38bb93c8" name="ad1da697fedf1996a826659eb38bb93c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1da697fedf1996a826659eb38bb93c8">&#9670;&nbsp;</a></span>detect_cell_neighboring_type_for_different_triangulations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CellNeighboringType BEMTools::detect_cell_neighboring_type_for_different_triangulations </td>
          <td>(</td>
          <td class="paramtype">const typename DoFHandler&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>first_cell_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DoFHandler&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>second_cell_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mapping&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_cell_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mapping&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_cell_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; typename Triangulation&lt; dim, spacedim &gt;::cell_iterator, typename Triangulation&lt; dim+1, spacedim &gt;::face_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>map_from_first_boundary_mesh_to_volume_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; typename Triangulation&lt; dim, spacedim &gt;::cell_iterator, typename Triangulation&lt; dim+1, spacedim &gt;::face_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>map_from_second_boundary_mesh_to_volume_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; types::global_dof_index, types::global_dof_index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>common_vertex_pair_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Detect the cell neighboring type for the two cells pointed by the input cell iterators. This function handles the case when the involved two DoF handlers are different where the finite elements can be either identical or different, but the triangulations are always different.</p>
<p >In this case, neither vertex indices nor DoF indices for the two cells are numbered in a same index system.</p>
<p >These two surface triangulations are constructed respectively from a common volume mesh by specifying a set of boundary ids. Therefore, the map from surface/boundary mesh to volume mesh is needed.</p>
<p ><b>The map from surface/boundary mesh to volume mesh is only for the coarse mesh, due to the behavior of <code>GridGenerator::extract_boundary_mesh</code>.</b></p>
<p ><b>The template parameters <code>dim</code> and <code>spacedim</code> are for the boundary mesh. For the original volume mesh, the corresponding dimensions should be <code>dim+1</code> and <code>spacedim</code>.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_cell_iter</td><td></td></tr>
    <tr><td class="paramname">second_cell_iter</td><td></td></tr>
    <tr><td class="paramname">first_cell_mapping</td><td></td></tr>
    <tr><td class="paramname">second_cell_mapping</td><td></td></tr>
    <tr><td class="paramname">map_from_first_boundary_mesh_to_volume_mesh</td><td></td></tr>
    <tr><td class="paramname">map_from_second_boundary_mesh_to_volume_mesh</td><td></td></tr>
    <tr><td class="paramname">common_vertex_pair_dof_indices</td><td>A vector of pairs of global DoF indices in the corresponding DoF handlers. Each pair corresponds to a common vertex shred by the two cells, if any. The first DoF index in the pair is in the first cell with the first DoF handler, while the second DoF index in the pair is in the second cell with the second DoF handler. </td></tr>
    <tr><td class="paramname">threshold</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cell neighboring type </dd></dl>
<p >Get the iterators to the faces in the original volume triangulation.</p>
<p >Get the vertex indices in each face in the original volume triangulation.</p>
<p >Calculate the intersection of the two faces' vertex indices. This operation is meaningful because the two faces are both pulled back into the original volume triangulation.</p>
<p >According to deal.ii's documentation about <code>extract_boundary_mesh</code>,</p>
<blockquote class="doxtable">
<p >&zwj;The order of vertices of surface cells at the boundary and the </p>
</blockquote>
<p>corresponding volume faces may not match in order to ensure that each surface cell is associated with an outward facing normal. As a consequence, if you want to match quantities on the faces of the domain cells and on the cells of the surface mesh, you may have to translate between vertex locations or quadrature points.</p>
<p >Hence, the local index of each common vertex in its corresponding face in the volume mesh is not the same as its local index in the cell in the surface mesh. Therefore, the correlation mapping between cell vertices in the surface mesh and those in the face in the volume mesh should be constructed by matching vertex coordinates.</p>
<p >Get the coordinates of the current common vertex.</p>
<p >Get the coordinates of the current common vertex. </p><dl class="section note">
<dt>Note</dt>
<dd>The point returned from the member function <code>TriaAccessor::vertex</code> is a reference.</dd>
</dl>
<p >Find the current common vertex in the first boundary cell by coordinate matching.</p>
<p >Get the DoF index associated with the common vertex in the first cell.</p>
<p >Handle the case when the finite element order is 0, i.e. for <code>FE_DGQ</code>. Set the common vertex DoF index to be the DoF in the cell's interior, even though it is not associated to the vertex.</p>
<p >Find the current common vertex in the second boundary cell by coordinates.</p>
<p >Get the DoF index associated with the common vertex in the second cell.</p>
<p >Handle the case when the finite element order is 0, i.e. for <code>FE_DGQ</code>. Set the common vertex DoF index to be the DoF in the cell's interior, even though it is not associated to the vertex.</p>
<p >Add the pair of DoF indices associated with the common vertex in the two boundary cells to the list.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l02483">2483</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00068">BEMTools::CommonEdge</a>, <a class="el" href="bem__tools_8h_source.html#l00069">BEMTools::CommonVertex</a>, <a class="el" href="bem__tools_8h_source.html#l02322">BEMTools::detect_cell_neighboring_type_for_different_triangulations()</a>, <a class="el" href="bem__tools_8h_source.html#l01876">BEMTools::get_dof_index_for_vertex_in_cell()</a>, <a class="el" href="bem__tools_8h_source.html#l00071">BEMTools::None</a>, <a class="el" href="bem__tools_8h_source.html#l00070">BEMTools::Regular</a>, and <a class="el" href="bem__tools_8h_source.html#l00067">BEMTools::SamePanel</a>.</p>

</div>
</div>
<a id="ad1c3b7582fa3a94b950d83cb4a7aa70c" name="ad1c3b7582fa3a94b950d83cb4a7aa70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c3b7582fa3a94b950d83cb4a7aa70c">&#9670;&nbsp;</a></span>detect_cell_neighboring_type_for_different_triangulations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CellNeighboringType BEMTools::detect_cell_neighboring_type_for_different_triangulations </td>
          <td>(</td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>first_cell_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>second_cell_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; typename Triangulation&lt; dim, spacedim &gt;::cell_iterator, typename Triangulation&lt; dim+1, spacedim &gt;::face_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>map_from_first_boundary_mesh_to_volume_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; typename Triangulation&lt; dim, spacedim &gt;::cell_iterator, typename Triangulation&lt; dim+1, spacedim &gt;::face_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>map_from_second_boundary_mesh_to_volume_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>common_vertex_pair_local_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Detect the cell neighboring type for two cells which belong to different surface/boundary triangulations.</p>
<p >These two surface triangulations are constructed respectively from a common volume mesh by specifying a set of boundary ids. Therefore, the map from surface/boundary mesh to volume mesh is needed.</p>
<p ><b>The map from surface/boundary mesh to volume mesh is only for the coarse mesh, due to the behavior of <code>GridGenerator::extract_boundary_mesh</code>.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_cell_iter</td><td></td></tr>
    <tr><td class="paramname">second_cell_iter</td><td></td></tr>
    <tr><td class="paramname">map_from_first_boundary_mesh_to_volume_mesh</td><td></td></tr>
    <tr><td class="paramname">map_from_second_boundary_mesh_to_volume_mesh</td><td></td></tr>
    <tr><td class="paramname">common_vertex_pair_indices</td><td>A vector of pairs of vertex local indices in the two cells in the surface mesh. Each pair corresponds to a common vertex shared by the two cells, if any. The first element in each pair is the local index of the common vertex in the first cell, and the second element is that in the second cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cell neighboring type </dd></dl>
<p >Get the iterators to the faces in the original volume triangulation.</p>
<p >Get the vertex indices in each face in the original volume triangulation.</p>
<p >Calculate the intersection of the two faces' vertex indices. This operation is meaningful because the two faces are both pulled back into the original volume triangulation.</p>
<p >According to deal.ii's documentation about <code>extract_boundary_mesh</code>,</p>
<blockquote class="doxtable">
<p >&zwj;The order of vertices of surface cells at the boundary and the </p>
</blockquote>
<p>corresponding volume faces may not match in order to ensure that each surface cell is associated with an outward facing normal. As a consequence, if you want to match quantities on the faces of the domain cells and on the cells of the surface mesh, you may have to translate between vertex locations or quadrature points.</p>
<p >Hence, the local index of each common vertex in its corresponding face in the volume mesh is not the same as its local index in the cell in the surface mesh. Therefore, the correlation mapping between cell vertices in the surface mesh and those in the face in the volume mesh should be constructed by matching vertex coordinates.</p>
<p >Get the coordinates of the current common vertex. </p><dl class="section note">
<dt>Note</dt>
<dd>The point returned from the member function <code>TriaAccessor::vertex</code> is a reference.</dd>
</dl>
<p >Find the current common vertex in the first cell in the surface mesh by coordinate matching.</p>
<p >Find the current common vertex in the second cell in the surface mesh by coordinate matching.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l02322">2322</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l02322">BEMTools::detect_cell_neighboring_type_for_different_triangulations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l02914">BEMTools::detect_cell_neighboring_type()</a>, and <a class="el" href="bem__tools_8h_source.html#l02322">BEMTools::detect_cell_neighboring_type_for_different_triangulations()</a>.</p>

</div>
</div>
<a id="a0f943a5da0fb2f260e47f09c80a2fd1f" name="a0f943a5da0fb2f260e47f09c80a2fd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f943a5da0fb2f260e47f09c80a2fd1f">&#9670;&nbsp;</a></span>detect_cell_neighboring_type_for_same_dofhandlers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CellNeighboringType BEMTools::detect_cell_neighboring_type_for_same_dofhandlers </td>
          <td>(</td>
          <td class="paramtype">const typename DoFHandler&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>first_cell_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DoFHandler&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>second_cell_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mapping&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_cell_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mapping&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_cell_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; types::global_dof_index, types::global_dof_index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>common_vertex_pair_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Detect the cell neighboring type for the two cells pointed by the input cell iterators. This function handles the case when the involved two DoF handlers are the same, i.e. both the associated finite elements and triangulations are the same.</p>
<p >In this case, the vertex indices for the two cells are numbered in a same index system. Same situation holds for DoF indices for the two cells. Hence, when the finite element is <code>H1</code>, such as <code>FE_Q</code>, in each pair of the returned vector <code>common_vertex_pair_dof_indices</code>, the two elements are the same.</p>
<p >When the finite element type is <code>H1</code>, e.g. <code>FE_Q</code>, we get the common vertex DoF indices by taking the intersection of vertex indices in the two cells.</p>
<p >In principle, we can call the function <code>detect_cell_neighboring_type_for_same_triangulations</code> as what is done for the other case <code>L2</code> element. However, it involves comparison of point coordinates, which is less efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_cell_iter</td><td></td></tr>
    <tr><td class="paramname">second_cell_iter</td><td></td></tr>
    <tr><td class="paramname">first_cell_mapping</td><td></td></tr>
    <tr><td class="paramname">second_cell_mapping</td><td></td></tr>
    <tr><td class="paramname">common_vertex_pair_dof_indices</td><td>A vector of pairs of DoF indices. Each pair corresponds to a common vertex and in each pair, the first DoF index is in the first cell, while the second DoF index is in the second cell. </td></tr>
    <tr><td class="paramname">threshold</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >Get the finite element, which should be the same for the two cell iterators.</p>
<p >Get the list of vertex DoF indices in the two cells</p>
<p >Fill the vector of pairs for <code>common_vertex_dof_indices</code>.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l02808">2808</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00068">BEMTools::CommonEdge</a>, <a class="el" href="bem__tools_8h_source.html#l00069">BEMTools::CommonVertex</a>, <a class="el" href="bem__tools_8h_source.html#l02808">BEMTools::detect_cell_neighboring_type_for_same_dofhandlers()</a>, <a class="el" href="bem__tools_8h_source.html#l01994">BEMTools::detect_cell_neighboring_type_for_same_triangulations()</a>, <a class="el" href="bem__tools_8h_source.html#l01660">BEMTools::get_vertex_dof_indices_in_cell()</a>, <a class="el" href="bem__tools_8h_source.html#l00071">BEMTools::None</a>, <a class="el" href="bem__tools_8h_source.html#l00070">BEMTools::Regular</a>, and <a class="el" href="bem__tools_8h_source.html#l00067">BEMTools::SamePanel</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l02808">BEMTools::detect_cell_neighboring_type_for_same_dofhandlers()</a>.</p>

</div>
</div>
<a id="aa498e6f98ba5db0fa6e14678fdad077a" name="aa498e6f98ba5db0fa6e14678fdad077a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa498e6f98ba5db0fa6e14678fdad077a">&#9670;&nbsp;</a></span>detect_cell_neighboring_type_for_same_h1_dofhandlers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CellNeighboringType BEMTools::detect_cell_neighboring_type_for_same_h1_dofhandlers </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_cell_vertex_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_cell_vertex_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_dof_index_intersection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Detect the cell neighboring type for two cells by checking the intersection of the DoF indices associated with their vertices. Because there are vertex DoFs, the finite elements contained in the DoF handlers should be <code>H1</code>. The intersection of the DoF indices is returned via argument by reference.</p>
<p ><b>Comparison of DoF indices implies that the two cells should belong to a same DoFHandler. Otherwise, there will be two sets of DoF indices, which cannot be compared.</b></p>
<dl class="section note">
<dt>Note</dt>
<dd>N.B. The template argument <code>dim</code> of this function cannot be automatically inducted by the compiler from its input arguments, since even though the template argument <code>GeometryInfo&lt;dim&gt;::vertices_per_cell</code> of the two input arguments <code>first_cell_vertex_dof_indices</code> and <code>second_cell_vertex_dof_indices</code> contains <code>dim</code>, the whole <code>GeometryInfo&lt;dim&gt;::vertices_per_cell</code> will be evaluated into an integer by the compiler, so that <code>dim</code> will be discarded.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_cell_vertex_dof_indices</td><td></td></tr>
    <tr><td class="paramname">second_cell_vertex_dof_indices</td><td></td></tr>
    <tr><td class="paramname">vertex_dof_index_intersection</td><td>Before calling this function, this variable should be cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cell neighboring type </dd></dl>
<p >Calculate the intersection of the two cells' vertex DoF indices.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l02721">2721</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00068">BEMTools::CommonEdge</a>, <a class="el" href="bem__tools_8h_source.html#l00069">BEMTools::CommonVertex</a>, <a class="el" href="bem__tools_8h_source.html#l02721">BEMTools::detect_cell_neighboring_type_for_same_h1_dofhandlers()</a>, <a class="el" href="bem__tools_8h_source.html#l00071">BEMTools::None</a>, <a class="el" href="bem__tools_8h_source.html#l00070">BEMTools::Regular</a>, and <a class="el" href="bem__tools_8h_source.html#l00067">BEMTools::SamePanel</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l02721">BEMTools::detect_cell_neighboring_type_for_same_h1_dofhandlers()</a>.</p>

</div>
</div>
<a id="a799b4346d59d685c4c3c0dcfab77f4d7" name="a799b4346d59d685c4c3c0dcfab77f4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799b4346d59d685c4c3c0dcfab77f4d7">&#9670;&nbsp;</a></span>detect_cell_neighboring_type_for_same_triangulations() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CellNeighboringType BEMTools::detect_cell_neighboring_type_for_same_triangulations </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; types::global_vertex_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_cell_vertex_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_vertex_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_cell_vertex_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; types::global_vertex_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>common_vertex_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Detect the cell neighboring type by checking the intersection of the given two lists of vertex indices. The intersection of the global vertex indices is returned in the argument <code>common_vertex_indices</code> by reference.</p>
<p ><b>Comparison of vertex indices implies that the two cells should belong to a same triangulation. Otherwise, there will be two sets of vertex indices, which cannot be compared.</b></p>
<dl class="section note">
<dt>Note</dt>
<dd>N.B. The template argument <code>dim</code> of this function cannot be automatically inducted by the compiler from its input arguments, since even though the template argument <code>GeometryInfo&lt;dim&gt;::vertices_per_cell</code> of the two input arguments <code>first_cell_vertex_indices</code> and <code>second_cell_vertex_indices</code> contains <code>dim</code>, the whole <code>GeometryInfo&lt;dim&gt;::vertices_per_cell</code> will be evaluated into an integer by the compiler, so that <code>dim</code> will be discarded.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_cell_vertex_indices</td><td></td></tr>
    <tr><td class="paramname">second_cell_vertex_indices</td><td></td></tr>
    <tr><td class="paramname">common_vertex_indices</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >Calculate the intersection of the two cells' vertex indices.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l01994">1994</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00068">BEMTools::CommonEdge</a>, <a class="el" href="bem__tools_8h_source.html#l00069">BEMTools::CommonVertex</a>, <a class="el" href="bem__tools_8h_source.html#l01994">BEMTools::detect_cell_neighboring_type_for_same_triangulations()</a>, <a class="el" href="bem__tools_8h_source.html#l00071">BEMTools::None</a>, <a class="el" href="bem__tools_8h_source.html#l00070">BEMTools::Regular</a>, and <a class="el" href="bem__tools_8h_source.html#l00067">BEMTools::SamePanel</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l02914">BEMTools::detect_cell_neighboring_type()</a>, <a class="el" href="bem__tools_8h_source.html#l02808">BEMTools::detect_cell_neighboring_type_for_same_dofhandlers()</a>, and <a class="el" href="bem__tools_8h_source.html#l01994">BEMTools::detect_cell_neighboring_type_for_same_triangulations()</a>.</p>

</div>
</div>
<a id="a1bda426ba151b68f1f1ecdfb78c62087" name="a1bda426ba151b68f1f1ecdfb78c62087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bda426ba151b68f1f1ecdfb78c62087">&#9670;&nbsp;</a></span>detect_cell_neighboring_type_for_same_triangulations() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CellNeighboringType BEMTools::detect_cell_neighboring_type_for_same_triangulations </td>
          <td>(</td>
          <td class="paramtype">const typename DoFHandler&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>first_cell_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DoFHandler&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>second_cell_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mapping&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_cell_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mapping&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_cell_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; types::global_dof_index, types::global_dof_index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>common_vertex_pair_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Detect the cell neighboring type for the two cells pointed by the input cell iterators. This function handles the case when the involved two DoF handlers are different where the finite elements are different but the triangulations are the same.</p>
<p >In this case, the vertex indices for the two cells are numbered in a same index system. But the DoF indices for the two cells are independently indexed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_cell_iter</td><td></td></tr>
    <tr><td class="paramname">second_cell_iter</td><td></td></tr>
    <tr><td class="paramname">first_cell_mapping</td><td></td></tr>
    <tr><td class="paramname">second_cell_mapping</td><td></td></tr>
    <tr><td class="paramname">common_vertex_pair_dof_indices</td><td>A vector of pairs of DoF indices. Each pair corresponds to a common vertex. In each pair, the first DoF index is in the first cell with the first DoF handler, while the second DoF index is in the second cell with the second DoF handler. @pram threshold </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cell neighboring type </dd></dl>
<p >Get the vertex indices in each cell.</p>
<p >Calculate the intersection of the two cells' vertex indices. This operation is meaningful because the triangulations for the two cells are the same.</p>
<p >Fill the vector of pairs for <code>common_vertex_pair_dof_indices</code>. For each vertex index in the intersection, find the corresponding DoF indices in the two cells respectively.</p>
<p >Find the current common vertex in the list of vertex indices for the first cell.</p>
<p >Handle the case when there is only one DoF in a cell, i.e. <code>FE_DGQ</code> with order 0. Set the common vertex DoF index to be the DoF in the cell's interior, even though it is not associated to the vertex.</p>
<p >Find the current common vertex in the list of vertex indices for the second cell.</p>
<p >Handle the case when the finite element order is 0, i.e. for <code>FE_DGQ</code>. Set the common vertex DoF index to be the DoF in the cell's interior, even though it is not associated to the vertex.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l02145">2145</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00068">BEMTools::CommonEdge</a>, <a class="el" href="bem__tools_8h_source.html#l00069">BEMTools::CommonVertex</a>, <a class="el" href="bem__tools_8h_source.html#l01994">BEMTools::detect_cell_neighboring_type_for_same_triangulations()</a>, <a class="el" href="bem__tools_8h_source.html#l01876">BEMTools::get_dof_index_for_vertex_in_cell()</a>, <a class="el" href="bem__tools_8h_source.html#l00071">BEMTools::None</a>, <a class="el" href="bem__tools_8h_source.html#l00070">BEMTools::Regular</a>, and <a class="el" href="bem__tools_8h_source.html#l00067">BEMTools::SamePanel</a>.</p>

</div>
</div>
<a id="a290bfb641f1d9609b691523086feeaa4" name="a290bfb641f1d9609b691523086feeaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290bfb641f1d9609b691523086feeaa4">&#9670;&nbsp;</a></span>detect_cell_neighboring_type_for_same_triangulations() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CellNeighboringType BEMTools::detect_cell_neighboring_type_for_same_triangulations </td>
          <td>(</td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>first_cell_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>second_cell_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>common_vertex_pair_local_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Detect the cell neighboring type for two cells by checking the intersection of their vertex indices. Each of the common global vertex index is duplicated and made into a pair, then pushed into the result vector.</p>
<p ><b>Comparison of vertex indices implies that the two cells should belong to a same triangulation. Otherwise, there will be two sets of vertex indices, which cannot be compared.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_cell_iter</td><td></td></tr>
    <tr><td class="paramname">second_cell_iter</td><td></td></tr>
    <tr><td class="paramname">common_vertex_pair_indices</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l02064">2064</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l01994">BEMTools::detect_cell_neighboring_type_for_same_triangulations()</a>.</p>

</div>
</div>
<a id="a8120e883e228151169796eb22267bac4" name="a8120e883e228151169796eb22267bac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8120e883e228151169796eb22267bac4">&#9670;&nbsp;</a></span>generate_backward_dof_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; BEMTools::generate_backward_dof_permutation </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>starting_corner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Generate the permutation of the polynomial space inverse numbering by starting from the specified corner in the backward direction. The numbering is returned from this function via the return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">starting_corner</td><td>Index of the starting corner point. Because there are only four corners in a cell, its value belongs to \([0,1,2,3]\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Numbering of the permuted DoFs </dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l03667">3667</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l03667">BEMTools::generate_backward_dof_permutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l03667">BEMTools::generate_backward_dof_permutation()</a>.</p>

</div>
</div>
<a id="aa4446369f0c840e5f28c33d791d3635c" name="aa4446369f0c840e5f28c33d791d3635c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4446369f0c840e5f28c33d791d3635c">&#9670;&nbsp;</a></span>generate_backward_dof_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::generate_backward_dof_permutation </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>starting_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Generate the permutation of the polynomial space inverse numbering by starting from the specified corner in the backward direction. This overloaded version has the returned vector as its argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">starting_corner</td><td>Index of the starting corner point. Because there are only four corners in a cell, its value belongs to \([0,1,2,3]\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dof_permutation Numbering of the permuted DoFs. Its memory should be pre-allocated. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l03771">3771</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l03667">BEMTools::generate_backward_dof_permutation()</a>.</p>

</div>
</div>
<a id="ae5c091154e7bfa400931a59adc5215eb" name="ae5c091154e7bfa400931a59adc5215eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c091154e7bfa400931a59adc5215eb">&#9670;&nbsp;</a></span>generate_backward_mapping_support_point_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; BEMTools::generate_backward_mapping_support_point_permutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMappingQExt.html">MappingQExt</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>starting_corner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l03863">3863</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

</div>
</div>
<a id="ab11358807b8864a94999ded7ee28ae2d" name="ab11358807b8864a94999ded7ee28ae2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11358807b8864a94999ded7ee28ae2d">&#9670;&nbsp;</a></span>generate_backward_mapping_support_point_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::generate_backward_mapping_support_point_permutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMappingQExt.html">MappingQExt</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>starting_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>support_point_permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l03955">3955</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

</div>
</div>
<a id="ad95886a7832060e67dc7d7af0351c539" name="ad95886a7832060e67dc7d7af0351c539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95886a7832060e67dc7d7af0351c539">&#9670;&nbsp;</a></span>generate_forward_dof_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; BEMTools::generate_forward_dof_permutation </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>starting_corner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Generate the permutation of the polynomial space inverse numbering by starting from the specified corner in the forward direction. The numbering is returned from the function as the return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">starting_corner</td><td>Index of the starting corner point. Because there are only four corners in a cell, its value belongs to \([0,1,2,3]\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Numbering of the permuted DoFs </dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l03311">3311</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l03311">BEMTools::generate_forward_dof_permutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l03311">BEMTools::generate_forward_dof_permutation()</a>.</p>

</div>
</div>
<a id="a13a0aebc243f59f4f82de32ae76536e3" name="a13a0aebc243f59f4f82de32ae76536e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a0aebc243f59f4f82de32ae76536e3">&#9670;&nbsp;</a></span>generate_forward_dof_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::generate_forward_dof_permutation </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>starting_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Generate the permutation of the polynomial space inverse numbering by starting from the specified corner in the forward direction. This overloaded version has the returned vector as its argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">starting_corner</td><td>Index of the starting corner point. Because there are only four corners in a cell, its value belongs to \([0,1,2,3]\). </td></tr>
    <tr><td class="paramname">dof_permutation</td><td>Numbering of the permuted DoFs. Its memory should be pre-allocated. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l03407">3407</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l03311">BEMTools::generate_forward_dof_permutation()</a>.</p>

</div>
</div>
<a id="a8b416bc990fda99b201e698235f55885" name="a8b416bc990fda99b201e698235f55885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b416bc990fda99b201e698235f55885">&#9670;&nbsp;</a></span>generate_forward_mapping_support_point_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; BEMTools::generate_forward_mapping_support_point_permutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMappingQExt.html">MappingQExt</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>starting_corner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l03491">3491</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

</div>
</div>
<a id="ad59cbb707dc8607441ae981d9dfc7127" name="ad59cbb707dc8607441ae981d9dfc7127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59cbb707dc8607441ae981d9dfc7127">&#9670;&nbsp;</a></span>generate_forward_mapping_support_point_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::generate_forward_mapping_support_point_permutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMappingQExt.html">MappingQExt</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>starting_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>support_point_permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l03574">3574</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

</div>
</div>
<a id="a41e6654691a4063ada8dfe404683d01c" name="a41e6654691a4063ada8dfe404683d01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e6654691a4063ada8dfe404683d01c">&#9670;&nbsp;</a></span>get_conflict_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; types::global_dof_index &gt; BEMTools::get_conflict_indices </td>
          <td>(</td>
          <td class="paramtype">const typename DoFHandler&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function returns a list of DoF indices in the given cell iterator, which is used for checking if the two cells have interaction. This function is called by <code>GraphColoring::make_graph_coloring</code>.</p>
<p >Reference: <a href="http://localhost/dealii-9.1.1-doc/namespaceGraphColoring.html#a670720d11f544a762592112ae5213876">http://localhost/dealii-9.1.1-doc/namespaceGraphColoring.html#a670720d11f544a762592112ae5213876</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00153">153</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00153">BEMTools::get_conflict_indices()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l00153">BEMTools::get_conflict_indices()</a>.</p>

</div>
</div>
<a id="afff5cecfcf23c3a4c50813d8124524c8" name="afff5cecfcf23c3a4c50813d8124524c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff5cecfcf23c3a4c50813d8124524c8">&#9670;&nbsp;</a></span>get_dof_index_for_vertex_in_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">types::global_dof_index BEMTools::get_dof_index_for_vertex_in_cell </td>
          <td>(</td>
          <td class="paramtype">const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mapping&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>local_vertex_index_in_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the DoF index for the specified vertex in the cell.</p>
<dl class="section note">
<dt>Note</dt>
<dd>When the finite element associated with the cell conforms with <code>H1</code>, this function is the same as <code>DoFAccessor::vertex_dof_index</code>. When the finite element conforms with <code>L2</code>, because there are no DoFs associated with vertices, the matching of support points and vertices should be calculated.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
    <tr><td class="paramname">mapping</td><td></td></tr>
    <tr><td class="paramname">local_vertex_index_in_cell</td><td></td></tr>
    <tr><td class="paramname">threshold</td><td>Threshold for point equality checking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >When the finite element conforms to \(H_1\), e.g. <code>FE_Q</code>, the vertex DoF indices can be directly obtained by calling the member function <code>DoFAccessor::vertex_dof_index</code>.</p>
<p >Assert there is only one DoF associated with each vertex.</p>
<p >Handle the case when the finite element conforms to \(L_2\), e.g. <code>FE_DGQ</code>, where no DoFs are associated with vertices.</p>
<p >Assert there is no DoF associated with each vertex.</p>
<p >Get the list of vertex DoF indices in lexicographic order, which are directly extracted from the list of all DoF indices. N.B. The ordering of this list of vertex DoF indices may not match the ordering of the vertices in the geometry information.</p>
<p >Calculate the list of vertex support point coordinates in the real cell with the help of the mapping object. It will be compared with the vertex coordinates obtained from the cell geometry using the given <code>threshold</code>.</p>
<p >N.B. The ordering of this list of vertex support points corresponds with the ordering of the list of the above vertex DoF indices.</p>
<p >Iterate over each vertex support point and check if it matches the required vertex.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l01876">1876</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l01876">BEMTools::get_dof_index_for_vertex_in_cell()</a>, and <a class="el" href="bem__tools_8h_source.html#l01349">BEMTools::get_vertices_from_lexicographic_support_points_in_real_cell()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l02483">BEMTools::detect_cell_neighboring_type_for_different_triangulations()</a>, <a class="el" href="bem__tools_8h_source.html#l02145">BEMTools::detect_cell_neighboring_type_for_same_triangulations()</a>, and <a class="el" href="bem__tools_8h_source.html#l01876">BEMTools::get_dof_index_for_vertex_in_cell()</a>.</p>

</div>
</div>
<a id="a145e895ba470df9107942b4712c31487" name="a145e895ba470df9107942b4712c31487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145e895ba470df9107942b4712c31487">&#9670;&nbsp;</a></span>get_dofs_per_face_for_fe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int BEMTools::get_dofs_per_face_for_fe </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l01150">1150</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

</div>
</div>
<a id="a707ab3548bbb938d36c842a1be12918b" name="a707ab3548bbb938d36c842a1be12918b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707ab3548bbb938d36c842a1be12918b">&#9670;&nbsp;</a></span>get_lexicographic_dof_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; types::global_dof_index &gt; BEMTools::get_lexicographic_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the list of DoF indices in the current cell. It is obtained via the return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >Extract the list of DoF indices in the current cell.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l01439">1439</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l01439">BEMTools::get_lexicographic_dof_indices()</a>, and <a class="el" href="bem__tools_8h_source.html#l00125">BEMTools::permute_vector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l01439">BEMTools::get_lexicographic_dof_indices()</a>, and <a class="el" href="bem__tools_8h_source.html#l01511">BEMTools::get_vertex_dof_indices_from_lexicographic_dof_indices()</a>.</p>

</div>
</div>
<a id="a2d853270a62786b95a7c69a00bde09a6" name="a2d853270a62786b95a7c69a00bde09a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d853270a62786b95a7c69a00bde09a6">&#9670;&nbsp;</a></span>get_lexicographic_dof_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::get_lexicographic_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>lexicographic_dof_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the list of DoF indices in the current cell. It is obtained via argument by reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
    <tr><td class="paramname">lexicographic_dof_indices</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Extract the list of DoF indices in the current cell.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l01475">1475</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l01439">BEMTools::get_lexicographic_dof_indices()</a>, and <a class="el" href="bem__tools_8h_source.html#l00125">BEMTools::permute_vector()</a>.</p>

</div>
</div>
<a id="a584635f5c9ca0dc37ad7f8efffff918a" name="a584635f5c9ca0dc37ad7f8efffff918a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584635f5c9ca0dc37ad7f8efffff918a">&#9670;&nbsp;</a></span>get_lexicographic_support_points_in_real_cell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Point&lt; spacedim &gt; &gt; BEMTools::get_lexicographic_support_points_in_real_cell </td>
          <td>(</td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MappingQ&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate a list of support points in the real cell in the lexicographic order. The results are obtained via the return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">mapping</td><td>Geometric mapping object used for transforming support points from the unit cell to the real cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of support points in the real cell in the lexicographic order.</dd></dl>
<dl class="section note">
<dt>Note</dt>
<dd>N.B. Each support point in the real cell has the space dimension <code>spacedim</code>, while each support point in the unit cell has the manifold dimension <code>dim</code>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l01089">1089</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l01089">BEMTools::get_lexicographic_support_points_in_real_cell()</a>, and <a class="el" href="bem__tools_8h_source.html#l00894">BEMTools::get_support_points_in_real_cell()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l01089">BEMTools::get_lexicographic_support_points_in_real_cell()</a>.</p>

</div>
</div>
<a id="a858771b41a3e5403f2dd4ea81d15fc0b" name="a858771b41a3e5403f2dd4ea81d15fc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858771b41a3e5403f2dd4ea81d15fc0b">&#9670;&nbsp;</a></span>get_lexicographic_support_points_in_real_cell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::get_lexicographic_support_points_in_real_cell </td>
          <td>(</td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MappingQ&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Point&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points_in_real_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate a list of support points in the real cell in the lexicographic order. The results are obtained via argument by reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">mapping</td><td></td></tr>
    <tr><td class="paramname">support_points_in_real_cell</td><td>Returned list of support points in the lexicographic order in the real cell, the memory of which should be preallocated. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l01125">1125</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l01089">BEMTools::get_lexicographic_support_points_in_real_cell()</a>, and <a class="el" href="bem__tools_8h_source.html#l00894">BEMTools::get_support_points_in_real_cell()</a>.</p>

</div>
</div>
<a id="aa33884decde7a3f2009c3d88f239ee97" name="aa33884decde7a3f2009c3d88f239ee97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33884decde7a3f2009c3d88f239ee97">&#9670;&nbsp;</a></span>get_lexicographic_unit_support_points() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Point&lt; dim &gt; &gt; BEMTools::get_lexicographic_unit_support_points </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the list of unit support points in the lexicographic order in the finite element. The results are obtained via the return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00820">820</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00820">BEMTools::get_lexicographic_unit_support_points()</a>, and <a class="el" href="bem__tools_8h_source.html#l00739">BEMTools::get_unit_support_points_with_permutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l00820">BEMTools::get_lexicographic_unit_support_points()</a>, and <a class="el" href="bem__tools_8h_source.html#l01206">BEMTools::get_vertices_from_lexicographic_unit_support_points()</a>.</p>

</div>
</div>
<a id="afa08482472a78ac3f228e8be78b0448d" name="afa08482472a78ac3f228e8be78b0448d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa08482472a78ac3f228e8be78b0448d">&#9670;&nbsp;</a></span>get_lexicographic_unit_support_points() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::get_lexicographic_unit_support_points </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Point&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>lexicographic_unit_support_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the list of unit support points in the lexicographic order in the finite element. The results are obtained via argument by reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">lexicographic_unit_support_points</td><td>Returned list of unit support points in the lexicographic order, the memory of which should be preallocated. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00852">852</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00820">BEMTools::get_lexicographic_unit_support_points()</a>, and <a class="el" href="bem__tools_8h_source.html#l00739">BEMTools::get_unit_support_points_with_permutation()</a>.</p>

</div>
</div>
<a id="ad1ea7211efc8041a41d3cacae9729a47" name="ad1ea7211efc8041a41d3cacae9729a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ea7211efc8041a41d3cacae9729a47">&#9670;&nbsp;</a></span>get_support_points_in_default_dof_order_in_real_cell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Point&lt; spacedim &gt; &gt; BEMTools::get_support_points_in_default_dof_order_in_real_cell </td>
          <td>(</td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MappingQ&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate a list of support points in the real cell in the default DoF order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">mapping</td><td>Geometric mapping object used for transforming support points from the unit cell to the real cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of support points in the real cell in the default DoF order.</dd></dl>
<dl class="section note">
<dt>Note</dt>
<dd>N.B. Each support point in the real cell has the space dimension <code>spacedim</code>, while each support point in the unit cell has the manifold dimension <code>dim</code>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00995">995</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00995">BEMTools::get_support_points_in_default_dof_order_in_real_cell()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l00995">BEMTools::get_support_points_in_default_dof_order_in_real_cell()</a>.</p>

</div>
</div>
<a id="a2fc8cd33010224d89249c98e200fed68" name="a2fc8cd33010224d89249c98e200fed68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc8cd33010224d89249c98e200fed68">&#9670;&nbsp;</a></span>get_support_points_in_default_dof_order_in_real_cell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::get_support_points_in_default_dof_order_in_real_cell </td>
          <td>(</td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MappingQ&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Point&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points_in_reall_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate a list of support points in the real cell in the default DoF order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">mapping</td><td>Geometric mapping object used for transforming support points from the unit cell to the real cell. </td></tr>
    <tr><td class="paramname">support_points_in_real_cell</td><td>A list of support points in the real cell in the hierarchic order, the memory of which should be preallocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note">
<dt>Note</dt>
<dd>N.B. Each support point in the real cell has the space dimension <code>spacedim</code>, while each support point in the unit cell has the manifold dimension <code>dim</code>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l01041">1041</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00995">BEMTools::get_support_points_in_default_dof_order_in_real_cell()</a>.</p>

</div>
</div>
<a id="a13de33f923c12e1234484f3c9f07e857" name="a13de33f923c12e1234484f3c9f07e857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13de33f923c12e1234484f3c9f07e857">&#9670;&nbsp;</a></span>get_support_points_in_real_cell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Point&lt; spacedim &gt; &gt; BEMTools::get_support_points_in_real_cell </td>
          <td>(</td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MappingQ&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate a list of support points in the real cell in the order specified by <code>dof_permutation</code>. The results are returned via the return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">mapping</td><td>Geometric mapping object used for transforming support points from the unit cell to the real cell. </td></tr>
    <tr><td class="paramname">dof_permutation</td><td>The numbering for accessing the support points in the specified order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of support points in the real cell.</dd></dl>
<dl class="section note">
<dt>Note</dt>
<dd>N.B. Each support point in the real cell has the space dimension <code>spacedim</code>, while each support point in the unit cell has the manifold dimension <code>dim</code>.</dd>
</dl>
<p >Get the list of support points in the unit cell in the default DoF ordering.</p>
<p >Transform the support points from unit cell to real cell via the <code>mapping</code> object. The support points in the original default DoF ordering are permuted according to <code>dof_permutation</code>.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00894">894</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00894">BEMTools::get_support_points_in_real_cell()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l01089">BEMTools::get_lexicographic_support_points_in_real_cell()</a>, and <a class="el" href="bem__tools_8h_source.html#l00894">BEMTools::get_support_points_in_real_cell()</a>.</p>

</div>
</div>
<a id="ad1a6fe3c8cae035a198b247e5a074605" name="ad1a6fe3c8cae035a198b247e5a074605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a6fe3c8cae035a198b247e5a074605">&#9670;&nbsp;</a></span>get_support_points_in_real_cell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::get_support_points_in_real_cell </td>
          <td>(</td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MappingQ&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Point&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points_in_real_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate a list of support points in the real cell in the order specified by <code>dof_permutation</code>. The results are returned via argument by reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">mapping</td><td></td></tr>
    <tr><td class="paramname">dof_permutation</td><td></td></tr>
    <tr><td class="paramname">support_points_in_real_cell</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Get the list of support points in the unit cell in the default DoF ordering.</p>
<p >Transform the support points from unit cell to real cell via the <code>mapping</code> object. The support points in the original default DoF ordering are permuted according to <code>dof_permutation</code>.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00943">943</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00894">BEMTools::get_support_points_in_real_cell()</a>.</p>

</div>
</div>
<a id="aa978ce647ef955d8489beab14ef69277" name="aa978ce647ef955d8489beab14ef69277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa978ce647ef955d8489beab14ef69277">&#9670;&nbsp;</a></span>get_unit_support_points_with_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Point&lt; dim &gt; &gt; BEMTools::get_unit_support_points_with_permutation </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the list of unit support points in the finite element, which is ordered according to the specified permutation. The results are obtained via the return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">dof_permutation</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >Get the list of support points in the unit cell in the default DoF ordering.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00739">739</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00739">BEMTools::get_unit_support_points_with_permutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l00820">BEMTools::get_lexicographic_unit_support_points()</a>, and <a class="el" href="bem__tools_8h_source.html#l00739">BEMTools::get_unit_support_points_with_permutation()</a>.</p>

</div>
</div>
<a id="a74958336c126d0cde338d9779947d79f" name="a74958336c126d0cde338d9779947d79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74958336c126d0cde338d9779947d79f">&#9670;&nbsp;</a></span>get_unit_support_points_with_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::get_unit_support_points_with_permutation </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Point&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>permuted_unit_support_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the list of unit support points in the finite element, which is ordered according to the specified permutation. The results are obtained as argument by reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">dof_permutation</td><td></td></tr>
    <tr><td class="paramname">permuted_unit_support_points</td><td>Returned list of permuted unit support points, the memory of which should be preallocated. </td></tr>
  </table>
  </dd>
</dl>
<p >Get the list of support points in the unit cell in the default DoF ordering.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00782">782</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00739">BEMTools::get_unit_support_points_with_permutation()</a>.</p>

</div>
</div>
<a id="a158fbe38db043178d2ab25653a6b96dd" name="a158fbe38db043178d2ab25653a6b96dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158fbe38db043178d2ab25653a6b96dd">&#9670;&nbsp;</a></span>get_vertex_dof_indices_from_lexicographic_dof_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; types::global_dof_index &gt; BEMTools::get_vertex_dof_indices_from_lexicographic_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_counter_clockwise_ordered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get a list of vertex DoF indices, which are directly extracted from the list of DoF indices in the lexicographic order. The result is obtained in the return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
    <tr><td class="paramname">is_counter_clockwise_ordered</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >Get the list of DoF indices in the lexicographic order.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l01511">1511</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l01439">BEMTools::get_lexicographic_dof_indices()</a>, and <a class="el" href="bem__tools_8h_source.html#l01511">BEMTools::get_vertex_dof_indices_from_lexicographic_dof_indices()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l01511">BEMTools::get_vertex_dof_indices_from_lexicographic_dof_indices()</a>, and <a class="el" href="bem__tools_8h_source.html#l01767">BEMTools::get_vertex_dof_indices_in_cell()</a>.</p>

</div>
</div>
<a id="a13ecd357c6a8e71bbc617f41cfe04057" name="a13ecd357c6a8e71bbc617f41cfe04057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ecd357c6a8e71bbc617f41cfe04057">&#9670;&nbsp;</a></span>get_vertex_dof_indices_from_lexicographic_dof_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::get_vertex_dof_indices_from_lexicographic_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; types::global_dof_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_counter_clockwise_ordered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get a list of vertex DoF indices, which are directly extracted from the list of DoF indices in the lexicographic order. The result is obtained via argument by reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
    <tr><td class="paramname">vertex_dof_indices</td><td></td></tr>
    <tr><td class="paramname">is_counter_clockwise_ordered</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Get the list of DoF indices in the lexicographic order.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l01586">1586</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l01511">BEMTools::get_vertex_dof_indices_from_lexicographic_dof_indices()</a>.</p>

</div>
</div>
<a id="adeaa2dd69432dd427d339e692127bdaf" name="adeaa2dd69432dd427d339e692127bdaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeaa2dd69432dd427d339e692127bdaf">&#9670;&nbsp;</a></span>get_vertex_dof_indices_in_cell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; types::global_dof_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; BEMTools::get_vertex_dof_indices_in_cell </td>
          <td>(</td>
          <td class="paramtype">const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mapping&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return a list of global DoF indices, which are located at the list of vertices in the cell respectively. The result is obtained via the return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
    <tr><td class="paramname">mapping</td><td></td></tr>
    <tr><td class="paramname">threshold</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >When the finite element conforms to \(H_1\), e.g. <code>FE_Q</code>, the vertex DoF indices can be directly obtained by calling the member function <code>DoFAccessor::vertex_dof_index</code>.</p>
<p >Assert there is only one DoF associated with each vertex.</p>
<p >Handle the case when the finite element conforms to \(L_2\), e.g. <code>FE_DGQ</code>, where there are no DoFs associated with vertices.</p>
<p >Assert there is no DoF associated with each vertex.</p>
<p >Get the list of vertex DoF indices which are directly extracted from the list of all DoF indices. N.B. The ordering of this list of vertex DoF indices may not match the ordering of the vertices in the geometry information.</p>
<p >Calculate the list of vertex support point coordinates in the real cell with the help of the mapping object. It will be compared with the vertex coordinates obtained from the cell geometry.</p>
<p >N.B. The ordering of this list of vertex support points corresponds with the ordering of the list of the above vertex DoF indices.</p>
<p >Iterate over each vertex support point and check that to which vertex in the cell it is equal.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l01660">1660</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l01660">BEMTools::get_vertex_dof_indices_in_cell()</a>, and <a class="el" href="bem__tools_8h_source.html#l01349">BEMTools::get_vertices_from_lexicographic_support_points_in_real_cell()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l02808">BEMTools::detect_cell_neighboring_type_for_same_dofhandlers()</a>, and <a class="el" href="bem__tools_8h_source.html#l01660">BEMTools::get_vertex_dof_indices_in_cell()</a>.</p>

</div>
</div>
<a id="af8217a92ffb68d5f2efc493f191a1845" name="af8217a92ffb68d5f2efc493f191a1845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8217a92ffb68d5f2efc493f191a1845">&#9670;&nbsp;</a></span>get_vertex_dof_indices_in_cell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::get_vertex_dof_indices_in_cell </td>
          <td>(</td>
          <td class="paramtype">const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mapping&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; types::global_dof_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_vertex_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return a list of global DoF indices, which are located at the list of vertices in the cell respectively. The result is obtained via argument by reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
    <tr><td class="paramname">mapping</td><td></td></tr>
    <tr><td class="paramname">threshold</td><td></td></tr>
    <tr><td class="paramname">cell_vertex_dof_indices</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >When the finite element conforms to \(H_1\), e.g. <code>FE_Q</code>, the vertex DoF indices can be directly obtained by calling the member function <code>DoFAccessor::vertex_dof_index</code>.</p>
<p >Assert there is only one DoF associated with each vertex.</p>
<p >Handle the case when the finite element conforms to \(L_2\), e.g. <code>FE_DGQ</code>, where there are no DoFs associated with vertices.</p>
<p >Assert there is no DoF associated with each vertex.</p>
<p >Get the list of vertex DoF indices which are directly extracted from the list of all DoF indices. N.B. The ordering of this list of vertex DoF indices may not match the ordering of the vertices in the geometry information.</p>
<p >Calculate the list of vertex support point coordinates in the real cell with the help of the mapping object. It will be compared with the vertex coordinates obtained from the cell geometry.</p>
<p >N.B. The ordering of this list of vertex support points corresponds with the ordering of the list of the above vertex DoF indices.</p>
<p >Iterate over each vertex support point and check that to which vertex in the cell it is equal.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l01767">1767</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l01511">BEMTools::get_vertex_dof_indices_from_lexicographic_dof_indices()</a>, <a class="el" href="bem__tools_8h_source.html#l01660">BEMTools::get_vertex_dof_indices_in_cell()</a>, and <a class="el" href="bem__tools_8h_source.html#l01349">BEMTools::get_vertices_from_lexicographic_support_points_in_real_cell()</a>.</p>

</div>
</div>
<a id="af33ac9e7d3357ca7f5a32e295d3aa515" name="af33ac9e7d3357ca7f5a32e295d3aa515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33ac9e7d3357ca7f5a32e295d3aa515">&#9670;&nbsp;</a></span>get_vertex_indices_in_cell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; types::global_vertex_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; BEMTools::get_vertex_indices_in_cell </td>
          <td>(</td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return a list of global vertex indices for all the vertices in the given cell pointed by the cell iterator obtained from a triangulation. The result is obtained via the return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00238">238</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00238">BEMTools::get_vertex_indices_in_cell()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l00238">BEMTools::get_vertex_indices_in_cell()</a>.</p>

</div>
</div>
<a id="a1485cd0b7cb158e497f54fc616f184b5" name="a1485cd0b7cb158e497f54fc616f184b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1485cd0b7cb158e497f54fc616f184b5">&#9670;&nbsp;</a></span>get_vertex_indices_in_cell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::get_vertex_indices_in_cell </td>
          <td>(</td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; types::global_vertex_index, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_vertex_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return a list of global vertex indices for all the vertices in the given cell pointed by the cell iterator obtained from a triangulation. The result is obtained via argument by reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
    <tr><td class="paramname">cell_vertex_indices</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00263">263</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00238">BEMTools::get_vertex_indices_in_cell()</a>.</p>

</div>
</div>
<a id="a7b81f47313e428bf1a24bce156a7d56d" name="a7b81f47313e428bf1a24bce156a7d56d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b81f47313e428bf1a24bce156a7d56d">&#9670;&nbsp;</a></span>get_vertex_indices_in_face() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; types::global_vertex_index, GeometryInfo&lt; dim &gt;::vertices_per_face &gt; BEMTools::get_vertex_indices_in_face </td>
          <td>(</td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return a list of global vertex indices for all the vertices in the given face pointed by the face iterator obtained from a triangulation. The result is obtained via the return value.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The dimension of the face is <code>dim-1</code>.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00287">287</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00287">BEMTools::get_vertex_indices_in_face()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l00287">BEMTools::get_vertex_indices_in_face()</a>.</p>

</div>
</div>
<a id="aa5115df83da745a7b2a10aa1395f5425" name="aa5115df83da745a7b2a10aa1395f5425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5115df83da745a7b2a10aa1395f5425">&#9670;&nbsp;</a></span>get_vertex_indices_in_face() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::get_vertex_indices_in_face </td>
          <td>(</td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; types::global_vertex_index, GeometryInfo&lt; dim &gt;::vertices_per_face &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return a list of global vertex indices for all the vertices in the given face pointed by the face iterator obtained from a triangulation. The result is obtained via argument by reference.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The dimension of the face is <code>dim-1</code>.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td></td></tr>
    <tr><td class="paramname">face_vertex_indices</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00314">314</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00287">BEMTools::get_vertex_indices_in_face()</a>.</p>

</div>
</div>
<a id="a13078be413d8d93baa0de0704b677a77" name="a13078be413d8d93baa0de0704b677a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13078be413d8d93baa0de0704b677a77">&#9670;&nbsp;</a></span>get_vertex_local_index_in_cell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int BEMTools::get_vertex_local_index_in_cell </td>
          <td>(</td>
          <td class="paramtype">const Point&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the local index of the given vertex in the list of vertices of the cell by raw comparison of vertex coordinates.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The template parameter <code>dim</code> cannot be deduced from the arguments.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td></td></tr>
    <tr><td class="paramname">cell</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00178">178</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00178">BEMTools::get_vertex_local_index_in_cell()</a>, and <a class="el" href="block__cluster_8h_source.html#l01439">is_equal()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l00178">BEMTools::get_vertex_local_index_in_cell()</a>.</p>

</div>
</div>
<a id="ac7945f47146b05efcb2f00d0a9b825ad" name="ac7945f47146b05efcb2f00d0a9b825ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7945f47146b05efcb2f00d0a9b825ad">&#9670;&nbsp;</a></span>get_vertex_local_index_in_cell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int BEMTools::get_vertex_local_index_in_cell </td>
          <td>(</td>
          <td class="paramtype">const Point&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the local index of the given vertex in the list of vertices of the cell by numerical comparison of vertex coordinates.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The template parameter <code>dim</code> cannot be deduced from the arguments.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td></td></tr>
    <tr><td class="paramname">cell</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00210">210</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00178">BEMTools::get_vertex_local_index_in_cell()</a>, and <a class="el" href="block__cluster_8h_source.html#l01439">is_equal()</a>.</p>

</div>
</div>
<a id="a8390f574b7614a43eddacc54c09056c6" name="a8390f574b7614a43eddacc54c09056c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8390f574b7614a43eddacc54c09056c6">&#9670;&nbsp;</a></span>get_vertices_from_lexicographic_support_points_in_real_cell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; Point&lt; spacedim &gt;, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; BEMTools::get_vertices_from_lexicographic_support_points_in_real_cell </td>
          <td>(</td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mapping&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_counter_clockwise_ordered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the list of vertex coordinates from a list of support points in the real cell in the lexicographic order. The results are obtained via the return value.</p>
<p >If <code>is_counter_clockwise_ordered</code> is <code>true</code> when <code>dim==2</code>, the last two vertices will be swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">mapping</td><td></td></tr>
    <tr><td class="paramname">is_counter_clockwise_ordered</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >Extract the list of support points at vertices in the unit cell.</p>
<p >Map the support points from the unit cell to the real cell.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l01349">1349</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l01349">BEMTools::get_vertices_from_lexicographic_support_points_in_real_cell()</a>, and <a class="el" href="bem__tools_8h_source.html#l01206">BEMTools::get_vertices_from_lexicographic_unit_support_points()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l01876">BEMTools::get_dof_index_for_vertex_in_cell()</a>, <a class="el" href="bem__tools_8h_source.html#l01660">BEMTools::get_vertex_dof_indices_in_cell()</a>, and <a class="el" href="bem__tools_8h_source.html#l01349">BEMTools::get_vertices_from_lexicographic_support_points_in_real_cell()</a>.</p>

</div>
</div>
<a id="a97aae746b6f2b9f0460236e7c86fb010" name="a97aae746b6f2b9f0460236e7c86fb010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97aae746b6f2b9f0460236e7c86fb010">&#9670;&nbsp;</a></span>get_vertices_from_lexicographic_support_points_in_real_cell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::get_vertices_from_lexicographic_support_points_in_real_cell </td>
          <td>(</td>
          <td class="paramtype">const typename Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mapping&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Point&lt; spacedim &gt;, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices_in_real_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_counter_clockwise_ordered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the list of vertex coordinates from a list of support points in the real cell in the lexicographic order. The results are obtained via argument by reference.</p>
<p >If <code>is_counter_clockwise_ordered</code> is <code>true</code> when <code>dim==2</code>, the last two vertices will be swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td></td></tr>
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">mapping</td><td></td></tr>
    <tr><td class="paramname">vertices_in_real_cell</td><td></td></tr>
    <tr><td class="paramname">is_counter_clockwise_ordered</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Extract the list of support points at vertices in the unit cell.</p>
<p >Map the support points from the unit cell to the real cell.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l01398">1398</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l01349">BEMTools::get_vertices_from_lexicographic_support_points_in_real_cell()</a>, and <a class="el" href="bem__tools_8h_source.html#l01206">BEMTools::get_vertices_from_lexicographic_unit_support_points()</a>.</p>

</div>
</div>
<a id="ac435f8e40663d510949ec0e686a4d0da" name="ac435f8e40663d510949ec0e686a4d0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac435f8e40663d510949ec0e686a4d0da">&#9670;&nbsp;</a></span>get_vertices_from_lexicographic_unit_support_points() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; Point&lt; dim &gt;, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; BEMTools::get_vertices_from_lexicographic_unit_support_points </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_counter_clockwise_ordered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the list of vertex coordinates from a list of unit support points in the lexicographic order. The results are obtained via the return value.</p>
<p >If <code>is_counter_clockwise_ordered</code> is <code>true</code> when <code>dim==2</code>, the last two vertices will be swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >Get the list of unit support points in the lexicographic order.</p>
<p >Swap the last two vertices so that all the vertices are ordered counter clockwise.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l01206">1206</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00820">BEMTools::get_lexicographic_unit_support_points()</a>, and <a class="el" href="bem__tools_8h_source.html#l01206">BEMTools::get_vertices_from_lexicographic_unit_support_points()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l01349">BEMTools::get_vertices_from_lexicographic_support_points_in_real_cell()</a>, and <a class="el" href="bem__tools_8h_source.html#l01206">BEMTools::get_vertices_from_lexicographic_unit_support_points()</a>.</p>

</div>
</div>
<a id="ae2efea26e03b8770008388a5e2e3562d" name="ae2efea26e03b8770008388a5e2e3562d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2efea26e03b8770008388a5e2e3562d">&#9670;&nbsp;</a></span>get_vertices_from_lexicographic_unit_support_points() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::get_vertices_from_lexicographic_unit_support_points </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Point&lt; dim &gt;, GeometryInfo&lt; dim &gt;::vertices_per_cell &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_counter_clockwise_ordered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the list of vertex coordinates from a list of unit support points in the lexicographic order. The results are obtained via argument by reference.</p>
<p >If <code>is_counter_clockwise_ordered</code> is <code>true</code> when <code>dim==2</code>, the last two vertices will be swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">vertices</td><td></td></tr>
    <tr><td class="paramname">is_counter_clockwise_ordered</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Get the list of unit support points in the lexicographic order.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l01280">1280</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00820">BEMTools::get_lexicographic_unit_support_points()</a>, and <a class="el" href="bem__tools_8h_source.html#l01206">BEMTools::get_vertices_from_lexicographic_unit_support_points()</a>.</p>

</div>
</div>
<a id="ae73b7932d8c8dfa3ee6a0e2cb953694f" name="ae73b7932d8c8dfa3ee6a0e2cb953694f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73b7932d8c8dfa3ee6a0e2cb953694f">&#9670;&nbsp;</a></span>mappingq_shape_grad_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::mappingq_shape_grad_matrix </td>
          <td>(</td>
          <td class="paramtype">const typename MappingQ&lt; dim, spacedim &gt;::InternalData &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Collect the gradient of <code>MappingQ</code> shape functions into a matrix.</p>
<p >The shape functions and their derivatives of the mapping object have been evaluated at a list of points in the unit cell, therefore we need to specify at which point we will collect the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapping_data</td><td>The <code>InternalData</code> within <code>MappingQ</code> . </td></tr>
    <tr><td class="paramname">quad_no</td><td>The index of the point in the unit cell </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00400">400</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00400">BEMTools::mappingq_shape_grad_matrix()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l00400">BEMTools::mappingq_shape_grad_matrix()</a>.</p>

</div>
</div>
<a id="ad703a50befa5a882c080e6993fe99f77" name="ad703a50befa5a882c080e6993fe99f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad703a50befa5a882c080e6993fe99f77">&#9670;&nbsp;</a></span>permute_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType1 , typename VectorType2 , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BEMTools::permute_vector </td>
          <td>(</td>
          <td class="paramtype">const VectorType1 &amp;&#160;</td>
          <td class="paramname"><em>input_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType2 &amp;&#160;</td>
          <td class="paramname"><em>permuted_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permute a vector by using the given permutation indices to access its elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorType1</td><td></td></tr>
    <tr><td class="paramname">VectorType2</td><td></td></tr>
    <tr><td class="paramname">IndexType</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_vector</td><td></td></tr>
    <tr><td class="paramname">permutation_indices</td><td></td></tr>
    <tr><td class="paramname">permuted_vector</td><td>Result vector, whose memory should be allocated before calling this function. Its size should be &gt;= the size of the input vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00125">125</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00125">BEMTools::permute_vector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l01439">BEMTools::get_lexicographic_dof_indices()</a>, and <a class="el" href="bem__tools_8h_source.html#l00125">BEMTools::permute_vector()</a>.</p>

</div>
</div>
<a id="a2a2768ba2d09997a9c24240126917a4f" name="a2a2768ba2d09997a9c24240126917a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2768ba2d09997a9c24240126917a4f">&#9670;&nbsp;</a></span>shape_grad_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; BEMTools::shape_grad_matrix </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculates the matrix which stores shape function gradient values with respect to area coordinates. Each row of the matrix is the gradient of one of the shape functions. The order of the matrix rows corresponding to the shape function gradients is determined by the given numbering <code>dof_permuation</code>.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The support points, shape functions and DoFs in the finite element are enumerated in the hierarchic order for the continuous element <code>FE_Q</code>, while the discontinuous element <code>FE_DGQ</code> adopts the lexicographic order.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">dof_permutation</td><td>The numbering for accessing the shape functions in the specified order. </td></tr>
    <tr><td class="paramname">p</td><td>The area coordinates at which the shape function's gradient is to be evaluated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix storing the gradient of each shape function. Its dimension is <code>dofs_per_cell*dim</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00365">365</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00365">BEMTools::shape_grad_matrix()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l00365">BEMTools::shape_grad_matrix()</a>, and <a class="el" href="bem__tools_8h_source.html#l00441">BEMTools::shape_grad_matrix_in_default_dof_order()</a>.</p>

</div>
</div>
<a id="a484b289338beefb5484dee38a0ffcf33" name="a484b289338beefb5484dee38a0ffcf33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484b289338beefb5484dee38a0ffcf33">&#9670;&nbsp;</a></span>shape_grad_matrix_in_default_dof_order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; BEMTools::shape_grad_matrix_in_default_dof_order </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the matrix which stores shape function gradient values with respect to area coordinates. Each row of the matrix is the gradient of one of the shape functions. The matrix rows corresponding to the shape function gradients are arranged in the default DoF order.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The support points, shape functions and DoFs in the finite element are enumerated in the hierarchic order for the continuous element <code>FE_Q</code>, while the discontinuous element <code>FE_DGQ</code> adopts the lexicographic order.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">p</td><td>The area coordinates at which the shape function's gradient is to be evaluated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix storing the gradient of each shape function. Its dimension is <code>dofs_per_cell*dim</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00441">441</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00365">BEMTools::shape_grad_matrix()</a>, and <a class="el" href="bem__tools_8h_source.html#l00441">BEMTools::shape_grad_matrix_in_default_dof_order()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l00441">BEMTools::shape_grad_matrix_in_default_dof_order()</a>.</p>

</div>
</div>
<a id="ad51fd05a62ff111a998f9182d3695c7b" name="ad51fd05a62ff111a998f9182d3695c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51fd05a62ff111a998f9182d3695c7b">&#9670;&nbsp;</a></span>shape_grad_matrix_in_lexicographic_order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; BEMTools::shape_grad_matrix_in_lexicographic_order </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the matrix which stores shape function gradient values with respect to area coordinates. Each row of the matrix is the gradient of one of the shape functions. The matrix rows corresponding to the shape function gradients are arranged in the lexicographic order.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The support points, shape functions and DoFs in the finite element are enumerated in the hierarchic order for the continuous element <code>FE_Q</code>, while the discontinuous element <code>FE_DGQ</code> adopts the lexicographic order.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">p</td><td>The area coordinates at which the shape function's gradient is to be evaluated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix storing the gradient of each shape function. Its dimension is <code>dofs_per_cell*dim</code> . </dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00480">480</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00480">BEMTools::shape_grad_matrix_in_lexicographic_order()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__values_8hcu_source.html#l01454">BEMValues&lt; dim, spacedim, RangeNumberType &gt;::shape_function_values_regular()</a>, and <a class="el" href="bem__tools_8h_source.html#l00480">BEMTools::shape_grad_matrix_in_lexicographic_order()</a>.</p>

</div>
</div>
<a id="ae0c2a3eb5663ba13de32db528c29a3df" name="ae0c2a3eb5663ba13de32db528c29a3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c2a3eb5663ba13de32db528c29a3df">&#9670;&nbsp;</a></span>shape_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; RangeNumberType &gt; BEMTools::shape_values </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Evaluate a list of shape functions at the specified area coordinates. The shape functions are arranged in the order specified by <code>dof_permutation</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">dof_permutation</td><td>The numbering for accessing the shape functions in the specified order. </td></tr>
    <tr><td class="paramname">p</td><td>The area coordinates at which the shape functions are to be evaluated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of shape function values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00505">505</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00505">BEMTools::shape_values()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l00505">BEMTools::shape_values()</a>.</p>

</div>
</div>
<a id="a3c781d525abdbe2adfaccd41143b8601" name="a3c781d525abdbe2adfaccd41143b8601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c781d525abdbe2adfaccd41143b8601">&#9670;&nbsp;</a></span>shape_values_in_default_dof_order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; RangeNumberType &gt; BEMTools::shape_values_in_default_dof_order </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Evaluate a list of shape functions at the specified area coordinates in the default DoF order.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The support points, shape functions and DoFs in the finite element are enumerated in the hierarchic order for the continuous element <code>FE_Q</code>, while the discontinuous element <code>FE_DGQ</code> adopts the lexicographic order.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">p</td><td>The area coordinates at which the shape functions are to be evaluated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of shape function values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00535">535</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00535">BEMTools::shape_values_in_default_dof_order()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l00535">BEMTools::shape_values_in_default_dof_order()</a>.</p>

</div>
</div>
<a id="af072e86a2bc89a42df13f97d591bd232" name="af072e86a2bc89a42df13f97d591bd232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af072e86a2bc89a42df13f97d591bd232">&#9670;&nbsp;</a></span>shape_values_in_lexicographic_order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; RangeNumberType &gt; BEMTools::shape_values_in_lexicographic_order </td>
          <td>(</td>
          <td class="paramtype">const FiniteElement&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Evaluate a list of shape functions at the specified area coordinates in the lexicographic order.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The support points, shape functions and DoFs in the finite element are enumerated in the hierarchic order for the continuous element <code>FE_Q</code>, while the discontinuous element <code>FE_DGQ</code> adopts the lexicographic order.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td></td></tr>
    <tr><td class="paramname">p</td><td>The area coordinates at which the shape functions are to be evaluated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of shape function values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l00564">564</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00564">BEMTools::shape_values_in_lexicographic_order()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l00564">BEMTools::shape_values_in_lexicographic_order()</a>.</p>

</div>
</div>
<a id="a1fa0caa4b0da46471fdd2531013032fe" name="a1fa0caa4b0da46471fdd2531013032fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa0caa4b0da46471fdd2531013032fe">&#9670;&nbsp;</a></span>surface_covariant_transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; BEMTools::surface_covariant_transformation </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>k3_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quad_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Table&lt; 3, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_shape_grad_matrix_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>mapping_n_shape_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim, RangeNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points_in_real_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the covariant transformation matrix for mapping the gradient in local coordinate chart to global coordinates.</p>
<p >The formula for calculating the covariant transformation matrix: </p><p class="formulaDsp">
\[
J G^{-1} = J (J^T J)^{-1}.
\]
</p>
<p> N.B. \(J\) is the Jacobian matrix in \(\mathbb{R}^{{\rm
spacedim}\times{\rm dim}}\). Therefore, the covariant transformation matrix has the same sizes as \(J\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k3_index</td><td></td></tr>
    <tr><td class="paramname">quad_no</td><td></td></tr>
    <tr><td class="paramname">mapping_shape_grad_matrix_table</td><td></td></tr>
    <tr><td class="paramname">mapping_index</td><td></td></tr>
    <tr><td class="paramname">mapping_n_shape_functions</td><td></td></tr>
    <tr><td class="paramname">support_points_in_real_cell</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >Extract the shape function's gradient matrix under the specified \(k_3\) index and quadrature point, which will then be used for calculating the Jacobian matrix.</p>
<p >Metric tensor</p>
<p >Inverse of the metric tensor</p>
<p >\(G=J^T J\)</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l03195">3195</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00679">BEMTools::collect_components_from_points()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l06541">LAPACKFullMatrixExt&lt; Number &gt;::invert()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l05490">LAPACKFullMatrixExt&lt; Number &gt;::mmult()</a>, <a class="el" href="bem__tools_8h_source.html#l03195">BEMTools::surface_covariant_transformation()</a>, and <a class="el" href="lapack__full__matrix__ext_8h_source.html#l05758">LAPACKFullMatrixExt&lt; Number &gt;::Tmmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l03195">BEMTools::surface_covariant_transformation()</a>.</p>

</div>
</div>
<a id="a540d41c166ed0a7ff6ba14cdcb4f8a12" name="a540d41c166ed0a7ff6ba14cdcb4f8a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540d41c166ed0a7ff6ba14cdcb4f8a12">&#9670;&nbsp;</a></span>surface_jacobian_det()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double BEMTools::surface_jacobian_det </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>k3_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quad_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Table&lt; 2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape_grad_matrix_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points_in_real_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the surface Jacobian determinant at the quadrature point specified by its index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k3_index</td><td>\(k_3\) term index </td></tr>
    <tr><td class="paramname">quad_no</td><td>Quadrature point index </td></tr>
    <tr><td class="paramname">shape_grad_matrix_table</td><td>The data table storing the gradient values of the shape functions. Refer to <code><a class="el" href="classBEMValues.html#a3295e9352cc88ae73ccf8aac95b55b4e">BEMValues::kx_shape_grad_matrix_table_for_same_panel</a></code>. </td></tr>
    <tr><td class="paramname">support_points_in_real_cell</td><td>A list of support points in the real cell in the lexicographic order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Surface Jacobian determinant or surface metric tensor </dd></dl>
<p >Extract the shape function's gradient matrix under the specified \(k_3\) index and quadrature point.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l02984">2984</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00593">BEMTools::collect_two_components_from_point3()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l06514">LAPACKFullMatrixExt&lt; Number &gt;::determinant2x2()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l05490">LAPACKFullMatrixExt&lt; Number &gt;::mmult()</a>, and <a class="el" href="bem__tools_8h_source.html#l02984">BEMTools::surface_jacobian_det()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l02984">BEMTools::surface_jacobian_det()</a>, and <a class="el" href="bem__tools_8h_source.html#l03043">BEMTools::surface_jacobian_det_and_normal_vector()</a>.</p>

</div>
</div>
<a id="a1736192c10f32e6b8299b3830042967f" name="a1736192c10f32e6b8299b3830042967f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1736192c10f32e6b8299b3830042967f">&#9670;&nbsp;</a></span>surface_jacobian_det_and_normal_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RangeNumberType BEMTools::surface_jacobian_det_and_normal_vector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim, RangeNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_shape_grad_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; 1, spacedim, RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_normal_vector_negated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compute the Jacobian determinant and normal vector at a given point in the unit cell.</p>
<p >The point in the unit cell is not explicitly given, but the mapping shape function's gradient matrix provided has been evaluated at this point. </p>
<p >This loop transform the vector \([J_{01}, J_{12}, J_{20}]/\abs{J}\) to \([J_{12}, J_{20}, J_{01}]/\abs{J}\), which is the normal vector.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l03121">3121</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00593">BEMTools::collect_two_components_from_point3()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l06514">LAPACKFullMatrixExt&lt; Number &gt;::determinant2x2()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l05490">LAPACKFullMatrixExt&lt; Number &gt;::mmult()</a>, <a class="el" href="bem__tools_8h_source.html#l02984">BEMTools::surface_jacobian_det()</a>, and <a class="el" href="bem__tools_8h_source.html#l03043">BEMTools::surface_jacobian_det_and_normal_vector()</a>.</p>

</div>
</div>
<a id="aa673117ada74df9b8c21b85e5cc89523" name="aa673117ada74df9b8c21b85e5cc89523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa673117ada74df9b8c21b85e5cc89523">&#9670;&nbsp;</a></span>surface_jacobian_det_and_normal_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RangeNumberType BEMTools::surface_jacobian_det_and_normal_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>k3_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quad_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Table&lt; 3, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_shape_grad_matrix_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>mapping_n_shape_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim, RangeNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points_in_real_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor&lt; 1, spacedim, RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_normal_vector_negated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the surface Jacobian determinant and the normal vector at the quadrature point specified by its index.</p>
<dl class="section note">
<dt>Note</dt>
<dd>N.B. The reversed lexicographic order appears for \(K_y\) when the cell neighboring type is common edge. Then the calculated normal vector \(n_y\) has the opposite direction of the real one, which should be negated in the subsequent calculation.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k3_index</td><td>\(k_3\) term index </td></tr>
    <tr><td class="paramname">quad_no</td><td>Quadrature point index </td></tr>
    <tr><td class="paramname">mapping_shape_grad_matrix_table</td><td>The data table storing the gradient values of the shape functions. Refer to <a class="el" href="classBEMValues.html#a3295e9352cc88ae73ccf8aac95b55b4e">BEMValues::kx_shape_grad_matrix_table_for_same_panel</a>. </td></tr>
    <tr><td class="paramname">mapping_index</td><td>Index to the mapping object for the current cell. </td></tr>
    <tr><td class="paramname">support_points_in_real_cell</td><td>A list of support points in the real cell in the lexicographic order. </td></tr>
    <tr><td class="paramname">normal_vector</td><td></td></tr>
    <tr><td class="paramname">is_normal_vector_negated</td><td>Whether the direction of the computed normal vector should be negated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Surface Jacobian determinant or surface metric tensor </dd></dl>
<p >Extract the shape function's gradient matrix under the specified mapping index, \(k_3\) index and quadrature point index. The first dimension of the gradient matrix is the shape function index and the second dimension is coordinate component index in the unit cell.</p>
<p >This loop transform the vector \([J_{01}, J_{12}, J_{20}]/\abs{J}\) to \([J_{12}, J_{20}, J_{01}]/\abs{J}\), which is the normal vector.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l03043">3043</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l00593">BEMTools::collect_two_components_from_point3()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l06514">LAPACKFullMatrixExt&lt; Number &gt;::determinant2x2()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l05490">LAPACKFullMatrixExt&lt; Number &gt;::mmult()</a>, <a class="el" href="bem__tools_8h_source.html#l02984">BEMTools::surface_jacobian_det()</a>, and <a class="el" href="bem__tools_8h_source.html#l03043">BEMTools::surface_jacobian_det_and_normal_vector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l03043">BEMTools::surface_jacobian_det_and_normal_vector()</a>.</p>

</div>
</div>
<a id="af94cf6187cecd1d1f385af48fa618079" name="af94cf6187cecd1d1f385af48fa618079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94cf6187cecd1d1f385af48fa618079">&#9670;&nbsp;</a></span>transform_quad_point_from_unit_to_permuted_real_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Point&lt; spacedim, RangeNumberType &gt; BEMTools::transform_quad_point_from_unit_to_permuted_real_cell </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>k3_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quad_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Table&lt; 4, RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_shape_value_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>mapping_n_shape_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim, RangeNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_support_points_in_real_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Coordinate transformation of the specified quadrature point in the unit cell to the real cell based on a list of support points in the real cell. This version runs on the host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k3_index</td><td></td></tr>
    <tr><td class="paramname">quad_no</td><td>Quadrature point index </td></tr>
    <tr><td class="paramname">mapping_shape_value_table</td><td>Data table for the mapping shape function values. Refer to <a class="el" href="classBEMValues.html#a101db286fdbe325109848e919c6e237c">BEMValues::kx_shape_value_table_for_same_panel</a>. </td></tr>
    <tr><td class="paramname">mapping_support_points_in_real_cell</td><td>A list of support points in the real cell in the lexicographic order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Point coordinates in the real cell, which has the spatial dimension <code>spacedim</code>. </dd></dl>
<p >Linear combination of support point coordinates and evaluation of mapping shape functions at the specified area coordinates.</p>

<p class="definition">Definition at line <a class="el" href="bem__tools_8h_source.html#l03264">3264</a> of file <a class="el" href="bem__tools_8h_source.html">bem_tools.h</a>.</p>

<p class="reference">References <a class="el" href="bem__tools_8h_source.html#l03264">BEMTools::transform_quad_point_from_unit_to_permuted_real_cell()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bem__tools_8h_source.html#l03264">BEMTools::transform_quad_point_from_unit_to_permuted_real_cell()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
