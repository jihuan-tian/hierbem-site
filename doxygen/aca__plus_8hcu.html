<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HierBEM: include/hmatrix/aca_plus/aca_plus.hcu File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js", "TeX/AMScd.js.js"],
  jax: ["input/TeX","output/SVG"],
});
MathJax.Hub.Config({
  jax: ["input/TeX", "output/SVG"],
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js", "TeX/AMScd.js"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    skipTags: ["script","noscript","style","textarea","pre","code"],
    processEscapes: false,
    processEnvironments: true,
    preview: "TeX"
  },
  TeX: {
    Macros: {
      intd: "\\,{\\rm d}",
        diff: "{\\rm d}",
        Diff: "{\\rm D}",
        pdiff: "\\partial",
        DD: ["\\frac{\\diff}{\\diff #2}\\left( #1 \\right)", 2],
        Dd: ["\\frac{\\diff #1}{\\diff #2}", 2],
        PD: ["\\frac{\\pdiff}{\\pdiff #2}\\left( #1 \\right)", 2],
        Pd: ["\\frac{\\pdiff #1}{\\pdiff #2}", 2],
        rme: "{\\rm e}",
        rmi: "{\\rm i}",
        rmj: "{\\rm j}",
        vect: ["\\boldsymbol{#1}", 1],
        dform: ["\\overset{\\rightharpoonup}{\\boldsymbol{#1}}", 1],
        cochain: ["\\overset{\\rightharpoonup}{#1}", 1],
        bigabs: ["\\bigg\\lvert#1\\bigg\\rvert", 1],
        Abs: ["\\big\\lvert#1\\big\\rvert", 1],
        abs: ["\\lvert#1\\rvert", 1],
        bignorm: ["\\bigg\\lVert#1\\bigg\\rVert", 1],
        Norm: ["\\big\\lVert#1\\big\\rVert", 1],
        norm: ["\\lVert#1\\rVert", 1],
        normvect: "\\vect{n}",
        ouset: ["\\overset{#3}{\\underset{#2}{#1}}", 3],
        cscript: ["\\;\\; #1", 1],
        suchthat: "\\textit{S.T.\\;}",
        prefstar: "\\ast",
        restrict: "\\big\\vert",
        sgn: "{\\rm sgn}",
        erf: "{\\rm erf}",
        Bd: "{\\rm Bd}",
        Int: "{\\rm Int}",
        dim: "{\\rm dim}",
        rank: "{\\rm rank}",
        range: "{\\rm range}",
        divergence: "{\\rm div}",
        curl: "{\\rm curl}",
        grad: "{\\rm grad}",
        diag: "{\\rm diag}",
        tr: "{\\rm tr}",
        span: "{\\rm span}",
        lhs: "{\\rm LHS}",
        rhs: "{\\rm RHS}",
        argmin: "{\\rm argmin}",
        argmax: "{\\rm argmax}",
        esssup: "{\\rm ess sup}",
        essinf: "{\\rm ess inf}",
        kernel: "{\\rm ker}",
        image: "{\\rm Im}",
        diam: "{\\rm diam}"
    },
    equationNumbers: { autoNumber: "AMS" }
  },
  "HTML-CSS": {
     availableFonts: ["STIX","TeX"],
     preferredFont: "TeX",
     webFont: "TeX",
     imageFont: "TeX",
     showMathMenu: true
  },
  MMLorHTML: {
    prefer: {
      MSIE:    "MML",
      Firefox: "MML",
      Opera:   "HTML",
      other:   "HTML"
    }
  }
});
</script>
<script type="text/javascript" async="async" src="/js/MathJax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">HierBEM<span id="projectnumber">&#160;v1.0.0</span>
   </div>
   <div id="projectbrief">Hierarchical matrix based 3D Galerkin boundary element method (BEM) C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_73f6c25ff22e453adb4619599a10d18e.html">hmatrix</a></li><li class="navelem"><a class="el" href="dir_50db20f72054ade877dc0beccaac909a.html">aca_plus</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">aca_plus.hcu File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implement the ACA+ method proposed in Grasedyck, L. 2005. “Adaptive Recompression of \(\mathscr{H}\)-Matrices for BEM.” Computing 74 (3): 205–23.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;deal.II/base/logstream.h&gt;</code><br />
<code>#include &lt;deal.II/base/numbers.h&gt;</code><br />
<code>#include &lt;deal.II/base/parallel.h&gt;</code><br />
<code>#include &lt;deal.II/base/timer.h&gt;</code><br />
<code>#include &lt;deal.II/base/types.h&gt;</code><br />
<code>#include &lt;deal.II/fe/fe_update_flags.h&gt;</code><br />
<code>#include &lt;deal.II/lac/vector.h&gt;</code><br />
<code>#include &lt;cuda_runtime.h&gt;</code><br />
<code>#include &lt;tbb/tbb.h&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;chrono&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;complex&gt;</code><br />
<code>#include &lt;condition_variable&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;forward_list&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;mutex&gt;</code><br />
<code>#include &lt;random&gt;</code><br />
<code>#include &lt;thread&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;bem/bem_kernels.hcu&quot;</code><br />
<code>#include &quot;<a class="el" href="bem__tools_8h_source.html">bem/bem_tools.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cu__bem__values_8hcu_source.html">bem/cu_bem_values.hcu</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="config_8h_source.html">config.h</a>&quot;</code><br />
<code>#include &quot;hmatrix/aca_plus/aca_config.h&quot;</code><br />
<code>#include &quot;<a class="el" href="hmatrix_8h_source.html">hmatrix/hmatrix.h</a>&quot;</code><br />
<code>#include &quot;linear_algebra/cu_table.hcu&quot;</code><br />
<code>#include &quot;linear_algebra/lapack_full_matrix_ext.h&quot;</code><br />
<code>#include &quot;<a class="el" href="linalg_8h_source.html">linear_algebra/linalg.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mapping__info_8h_source.html">mapping/mapping_info.h</a>&quot;</code><br />
<code>#include &quot;quadrature/sauter_quadrature.hcu&quot;</code><br />
<code>#include &quot;sequence_partition/sequence_partition.h&quot;</code><br />
<code>#include &quot;<a class="el" href="debug__tools_8h_source.html">utilities/debug_tools.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="generic__functors_8h_source.html">utilities/generic_functors.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="number__traits_8h_source.html">utilities/number_traits.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="unary__template__arg__containers_8h_source.html">utilities/unary_template_arg_containers.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for aca_plus.hcu:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="aca__plus_8hcu__incl.svg" width="10380" height="827"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="aca__plus_8hcu__dep__incl.svg" width="424" height="514"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<p><a href="aca__plus_8hcu_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a31f3d4d24e52e94ab4a4ad115a04fd0e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> = std::make_unsigned&lt; types::blas_int &gt;::type</td></tr>
<tr class="separator:a31f3d4d24e52e94ab4a4ad115a04fd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a23d6cec6df4fb9da5a4ec004108daffa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a23d6cec6df4fb9da5a4ec004108daffa">generate_random_index</a> (const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> a, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> b)</td></tr>
<tr class="separator:a23d6cec6df4fb9da5a4ec004108daffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3f06ec4db7ede6e771c3bf637854f9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:aba3f06ec4db7ede6e771c3bf637854f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#aba3f06ec4db7ede6e771c3bf637854f9">assemble_kernel_row</a> (Vector&lt; RangeNumberType &gt; &amp;row_vector, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const types::global_dof_index row_dof_index, const std::vector&lt; types::global_dof_index &gt; &amp;column_dof_indices, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;kx_dof_to_cell_topo, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const DoFHandler&lt; dim, spacedim &gt; &amp;kx_dof_handler, const DoFHandler&lt; dim, spacedim &gt; &amp;ky_dof_handler, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;scratch_data_gpu, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:aba3f06ec4db7ede6e771c3bf637854f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2289ded23006142250878af068f94f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:acf2289ded23006142250878af068f94f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#acf2289ded23006142250878af068f94f">assemble_kernel_row</a> (Vector&lt; RangeNumberType &gt; &amp;row_vector, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;mass_vmult_weq, const KernelNumberType stabilization_factor, const types::global_dof_index row_dof_index, const std::vector&lt; types::global_dof_index &gt; &amp;column_dof_indices, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;kx_dof_to_cell_topo, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const DoFHandler&lt; dim, spacedim &gt; &amp;kx_dof_handler, const DoFHandler&lt; dim, spacedim &gt; &amp;ky_dof_handler, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;scratch_data_gpu, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:acf2289ded23006142250878af068f94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c278a79ce34123a62ecf24b708c0a7"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a66c278a79ce34123a62ecf24b708c0a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a66c278a79ce34123a62ecf24b708c0a7">assemble_kernel_row</a> (HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; RangeNumberType &gt;, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;task_buffer, Vector&lt; RangeNumberType &gt; &amp;row_vector, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const types::global_dof_index row_dof_index, const std::vector&lt; types::global_dof_index &gt; &amp;column_dof_indices, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;kx_dof_to_cell_topo, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:a66c278a79ce34123a62ecf24b708c0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d7b3974ab184f8379fa3b7894dc60c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a99d7b3974ab184f8379fa3b7894dc60c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a99d7b3974ab184f8379fa3b7894dc60c">assemble_kernel_row</a> (HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; RangeNumberType &gt;, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;task_buffer, Vector&lt; RangeNumberType &gt; &amp;row_vector, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;mass_vmult_weq, const KernelNumberType stabilization_factor, const types::global_dof_index row_dof_index, const std::vector&lt; types::global_dof_index &gt; &amp;column_dof_indices, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;kx_dof_to_cell_topo, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:a99d7b3974ab184f8379fa3b7894dc60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9653c418c44a4407a7bff50f11e8ed1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:ab9653c418c44a4407a7bff50f11e8ed1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#ab9653c418c44a4407a7bff50f11e8ed1">assemble_kernel_column</a> (Vector&lt; RangeNumberType &gt; &amp;col_vector, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const std::vector&lt; types::global_dof_index &gt; &amp;row_dof_indices, const types::global_dof_index col_dof_index, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;kx_dof_to_cell_topo, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;scratch_data_gpu, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:ab9653c418c44a4407a7bff50f11e8ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2d57d87bc349d4d5390724186a0da8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:aaf2d57d87bc349d4d5390724186a0da8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#aaf2d57d87bc349d4d5390724186a0da8">assemble_kernel_column</a> (Vector&lt; RangeNumberType &gt; &amp;col_vector, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;mass_vmult_weq, const KernelNumberType stabilization_factor, const std::vector&lt; types::global_dof_index &gt; &amp;row_dof_indices, const types::global_dof_index col_dof_index, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;kx_dof_to_cell_topo, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;scratch_data_gpu, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:aaf2d57d87bc349d4d5390724186a0da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f293d8bb18c5df1581da566473be91"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:aa3f293d8bb18c5df1581da566473be91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#aa3f293d8bb18c5df1581da566473be91">assemble_kernel_column</a> (HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; RangeNumberType &gt;, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;task_buffer, Vector&lt; RangeNumberType &gt; &amp;col_vector, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const std::vector&lt; types::global_dof_index &gt; &amp;row_dof_indices, const types::global_dof_index col_dof_index, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;kx_dof_to_cell_topo, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:aa3f293d8bb18c5df1581da566473be91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6a66a2d32b330d4e5d6885ded3692c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a0e6a66a2d32b330d4e5d6885ded3692c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a0e6a66a2d32b330d4e5d6885ded3692c">assemble_kernel_column</a> (HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; RangeNumberType &gt;, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;task_buffer, Vector&lt; RangeNumberType &gt; &amp;col_vector, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;mass_vmult_weq, const KernelNumberType stabilization_factor, const std::vector&lt; types::global_dof_index &gt; &amp;row_dof_indices, const types::global_dof_index col_dof_index, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;kx_dof_to_cell_topo, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:a0e6a66a2d32b330d4e5d6885ded3692c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0f3a023ab06d460cfdff2e98d07851"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a8d0f3a023ab06d460cfdff2e98d07851"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a8d0f3a023ab06d460cfdff2e98d07851">random_select_ref_row</a> (Vector&lt; RangeNumberType &gt; &amp;row_vector, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;remaining_row_indices, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> current_ref_row_index, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> pass_the_end_ref_row_index, const std::vector&lt; types::global_dof_index &gt; &amp;row_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;col_dof_indices, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;kx_dof_to_cell_topo, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;scratch_data_gpu, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:a8d0f3a023ab06d460cfdff2e98d07851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46d46094f18eae92aa37bd3dfea47ac"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:ad46d46094f18eae92aa37bd3dfea47ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#ad46d46094f18eae92aa37bd3dfea47ac">random_select_ref_row</a> (Vector&lt; RangeNumberType &gt; &amp;row_vector, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;mass_vmult_weq, const KernelNumberType stabilization_factor, std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;remaining_row_indices, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> current_ref_row_index, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> pass_the_end_ref_row_index, const std::vector&lt; types::global_dof_index &gt; &amp;row_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;col_dof_indices, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;kx_dof_to_cell_topo, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;scratch_data_gpu, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:ad46d46094f18eae92aa37bd3dfea47ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a80f5c5de151ac045d8037e28c9a6b1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a6a80f5c5de151ac045d8037e28c9a6b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a6a80f5c5de151ac045d8037e28c9a6b1">random_select_ref_row</a> (HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; RangeNumberType &gt;, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;task_buffer, Vector&lt; RangeNumberType &gt; &amp;row_vector, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;remaining_row_indices, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> current_ref_row_index, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> pass_the_end_ref_row_index, const std::vector&lt; types::global_dof_index &gt; &amp;row_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;col_dof_indices, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;kx_dof_to_cell_topo, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:a6a80f5c5de151ac045d8037e28c9a6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8650be3ae227c4631a4d09caaafb82e3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a8650be3ae227c4631a4d09caaafb82e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a8650be3ae227c4631a4d09caaafb82e3">random_select_ref_row</a> (HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; RangeNumberType &gt;, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;task_buffer, Vector&lt; RangeNumberType &gt; &amp;row_vector, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;mass_vmult_weq, const KernelNumberType stabilization_factor, std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;remaining_row_indices, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> current_ref_row_index, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> pass_the_end_ref_row_index, const std::vector&lt; types::global_dof_index &gt; &amp;row_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;col_dof_indices, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;kx_dof_to_cell_topo, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:a8650be3ae227c4631a4d09caaafb82e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7820a45bc029009bf42ff939076a496f"><td class="memTemplParams" colspan="2">template&lt;typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:a7820a45bc029009bf42ff939076a496f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a7820a45bc029009bf42ff939076a496f">random_select_ref_row</a> (Vector&lt; RangeNumberType &gt; &amp;row_vector, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; &amp;A, std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;remaining_row_indices, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> current_ref_row_index, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> pass_the_end_ref_row_index)</td></tr>
<tr class="separator:a7820a45bc029009bf42ff939076a496f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7dd925ab4738ea84e8748ff1aa6434b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:af7dd925ab4738ea84e8748ff1aa6434b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#af7dd925ab4738ea84e8748ff1aa6434b">random_select_ref_column</a> (Vector&lt; RangeNumberType &gt; &amp;col_vector, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; factor, std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;remaining_col_indices, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> current_ref_col_index, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> pass_the_end_ref_col_index, const std::vector&lt; types::global_dof_index &gt; &amp;row_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;col_dof_indices, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;kx_dof_to_cell_topo, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;scratch_data_gpu, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:af7dd925ab4738ea84e8748ff1aa6434b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca0e491f1ae37e8c62ae418d117ba69"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a5ca0e491f1ae37e8c62ae418d117ba69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a5ca0e491f1ae37e8c62ae418d117ba69">random_select_ref_column</a> (Vector&lt; RangeNumberType &gt; &amp;col_vector, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;mass_vmult_weq, const KernelNumberType stabilization_factor, std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;remaining_col_indices, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> current_ref_col_index, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> pass_the_end_ref_col_index, const std::vector&lt; types::global_dof_index &gt; &amp;row_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;col_dof_indices, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;kx_dof_to_cell_topo, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;scratch_data_gpu, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:a5ca0e491f1ae37e8c62ae418d117ba69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2824666c5af180396e5995de2bd2681"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:ac2824666c5af180396e5995de2bd2681"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#ac2824666c5af180396e5995de2bd2681">random_select_ref_column</a> (HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; RangeNumberType &gt;, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;task_buffer, Vector&lt; RangeNumberType &gt; &amp;col_vector, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; factor, std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;remaining_col_indices, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> current_ref_col_index, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> pass_the_end_ref_col_index, const std::vector&lt; types::global_dof_index &gt; &amp;row_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;col_dof_indices, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;kx_dof_to_cell_topo, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:ac2824666c5af180396e5995de2bd2681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d666eae14e96a703762d178d0c2ead"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:ad9d666eae14e96a703762d178d0c2ead"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#ad9d666eae14e96a703762d178d0c2ead">random_select_ref_column</a> (HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; RangeNumberType &gt;, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;task_buffer, Vector&lt; RangeNumberType &gt; &amp;col_vector, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;mass_vmult_weq, const KernelNumberType stabilization_factor, std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;remaining_col_indices, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> current_ref_col_index, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> pass_the_end_ref_col_index, const std::vector&lt; types::global_dof_index &gt; &amp;row_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;col_dof_indices, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;kx_dof_to_cell_topo, const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:ad9d666eae14e96a703762d178d0c2ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655fa5a299f18782100dec66c31d6fdd"><td class="memTemplParams" colspan="2">template&lt;typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:a655fa5a299f18782100dec66c31d6fdd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a655fa5a299f18782100dec66c31d6fdd">random_select_ref_column</a> (Vector&lt; RangeNumberType &gt; &amp;col_vector, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; &amp;A, std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;remaining_col_indices, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> current_ref_col_index, const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> pass_the_end_ref_col_index)</td></tr>
<tr class="separator:a655fa5a299f18782100dec66c31d6fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6428a269e829a9995aa8f2bfc4fa1b6a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a6428a269e829a9995aa8f2bfc4fa1b6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a6428a269e829a9995aa8f2bfc4fa1b6a">aca_plus_parallel_sauter_quad_for_vector_entry</a> (<a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; RangeNumberType &gt; &amp;rkmat, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const std::array&lt; types::global_dof_index, 2 &gt; &amp;row_dof_index_range, const std::array&lt; types::global_dof_index, 2 &gt; &amp;col_dof_index_range, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;scratch_data_gpu, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:a6428a269e829a9995aa8f2bfc4fa1b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3713cd3e5b5a177a3571e01d55ebfe"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:acd3713cd3e5b5a177a3571e01d55ebfe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#acd3713cd3e5b5a177a3571e01d55ebfe">aca_plus_parallel_sauter_quad_for_vector_entry</a> (<a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; RangeNumberType &gt; &amp;rkmat, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, KernelNumberType &gt; &amp;kernel, const KernelNumberType kernel_factor, const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;mass_vmult_weq, const KernelNumberType stabilization_factor, const std::array&lt; types::global_dof_index, 2 &gt; &amp;row_dof_index_range, const std::array&lt; types::global_dof_index, 2 &gt; &amp;col_dof_index_range, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data_gpu, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:acd3713cd3e5b5a177a3571e01d55ebfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dca24726be53cb76756baa595c49a9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a03dca24726be53cb76756baa595c49a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a03dca24726be53cb76756baa595c49a9">aca_plus_parallel_sauter_quad_for_whole_vector</a> (<a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; RangeNumberType &gt; &amp;rkmat, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const std::array&lt; types::global_dof_index, 2 &gt; &amp;row_dof_index_range, const std::array&lt; types::global_dof_index, 2 &gt; &amp;col_dof_index_range, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const <a class="el" href="classBEMValues.html">BEMValues</a>&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:a03dca24726be53cb76756baa595c49a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15190d613396372594d0ae2ed49b748"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:ab15190d613396372594d0ae2ed49b748"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#ab15190d613396372594d0ae2ed49b748">aca_plus_parallel_sauter_quad_for_whole_vector</a> (<a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; RangeNumberType &gt; &amp;rkmat, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, KernelNumberType &gt; &amp;kernel, const KernelNumberType kernel_factor, const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;mass_vmult_weq, const KernelNumberType stabilization_factor, const std::array&lt; types::global_dof_index, 2 &gt; &amp;row_dof_index_range, const std::array&lt; types::global_dof_index, 2 &gt; &amp;col_dof_index_range, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const <a class="el" href="classBEMValues.html">BEMValues</a>&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data)</td></tr>
<tr class="separator:ab15190d613396372594d0ae2ed49b748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c61817f34be4e110bbaa1b478061768"><td class="memTemplParams" colspan="2">template&lt;typename RangeNumberType  = double&gt; </td></tr>
<tr class="memitem:a7c61817f34be4e110bbaa1b478061768"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a7c61817f34be4e110bbaa1b478061768">aca_plus</a> (<a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; RangeNumberType &gt; &amp;rkmat, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; &amp;A)</td></tr>
<tr class="separator:a7c61817f34be4e110bbaa1b478061768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f2b8dc03e9189d238c74eff568abb5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a23f2b8dc03e9189d238c74eff568abb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a23f2b8dc03e9189d238c74eff568abb5">fill_hmatrix_leaf_node_with_aca_plus</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; *leaf_mat, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const DoFHandler&lt; dim, spacedim &gt; &amp;kx_dof_handler, const DoFHandler&lt; dim, spacedim &gt; &amp;ky_dof_handler, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;scratch_data_gpu, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data, const bool enable_build_symmetric_hmat=false)</td></tr>
<tr class="memdesc:a23f2b8dc03e9189d238c74eff568abb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a single leaf node of the \(\mathcal{H}\)-matrix using ACA+. If the matrix type is <code>RkMatrixType</code>, the memory for the full or rank-k matrix in the leaf node has been allocated.  <a href="aca__plus_8hcu.html#a23f2b8dc03e9189d238c74eff568abb5">More...</a><br /></td></tr>
<tr class="separator:a23f2b8dc03e9189d238c74eff568abb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04154c321261ad9f19a9a8fb3839ca56"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a04154c321261ad9f19a9a8fb3839ca56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a04154c321261ad9f19a9a8fb3839ca56">fill_hmatrix_leaf_node_with_aca_plus</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; *leaf_mat, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;mass_vmult_weq, const KernelNumberType stabilization_factor, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const DoFHandler&lt; dim, spacedim &gt; &amp;kx_dof_handler, const DoFHandler&lt; dim, spacedim &gt; &amp;ky_dof_handler, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;scratch_data_gpu, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data, const bool enable_build_symmetric_hmat=false)</td></tr>
<tr class="memdesc:a04154c321261ad9f19a9a8fb3839ca56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a single leaf node of the \(\mathcal{H}\)-matrix using ACA+. If the matrix type is <code>RkMatrixType</code>, the memory for the full or rank-k matrix in the leaf node has been allocated.  <a href="aca__plus_8hcu.html#a04154c321261ad9f19a9a8fb3839ca56">More...</a><br /></td></tr>
<tr class="separator:a04154c321261ad9f19a9a8fb3839ca56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e8176a7f874f6d1c4ef6f6c92e63ec"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a49e8176a7f874f6d1c4ef6f6c92e63ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a49e8176a7f874f6d1c4ef6f6c92e63ec">fill_hmatrix_leaf_node_with_aca_plus</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; *leaf_mat, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type mass_matrix_factor, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const DoFHandler&lt; dim, spacedim &gt; &amp;kx_dof_handler, const DoFHandler&lt; dim, spacedim &gt; &amp;ky_dof_handler, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="structCellWiseScratchDataForMassMatrix.html">CellWiseScratchDataForMassMatrix</a>&lt; dim, spacedim &gt; &amp;mass_matrix_scratch_data, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;scratch_data_gpu, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data, const bool enable_build_symmetric_hmat=false)</td></tr>
<tr class="memdesc:a49e8176a7f874f6d1c4ef6f6c92e63ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a single leaf node of the \(\mathcal{H}\)-matrix using ACA+.  <a href="aca__plus_8hcu.html#a49e8176a7f874f6d1c4ef6f6c92e63ec">More...</a><br /></td></tr>
<tr class="separator:a49e8176a7f874f6d1c4ef6f6c92e63ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31839e1a78b4af0965755292369dad5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:af31839e1a78b4af0965755292369dad5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#af31839e1a78b4af0965755292369dad5">fill_far_field_hmatrix_leaf_node_with_aca_plus</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; *leaf_mat, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const <a class="el" href="classBEMValues.html">BEMValues</a>&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data, const bool enable_build_symmetric_hmat=false)</td></tr>
<tr class="separator:af31839e1a78b4af0965755292369dad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11fe42caf088b89d95fea0143ded9cc"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:ac11fe42caf088b89d95fea0143ded9cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#ac11fe42caf088b89d95fea0143ded9cc">fill_far_field_hmatrix_leaf_node_with_aca_plus</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; *leaf_mat, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;mass_vmult_weq, const KernelNumberType stabilization_factor, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const <a class="el" href="classBEMValues.html">BEMValues</a>&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, <a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;scratch_data, <a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;copy_data, const bool enable_build_symmetric_hmat=false)</td></tr>
<tr class="separator:ac11fe42caf088b89d95fea0143ded9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2498845e560f9756cc662f69926d13"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:aaa2498845e560f9756cc662f69926d13"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#aaa2498845e560f9756cc662f69926d13">fill_far_field_hmatrix_leaf_node_subrange_with_aca_plus</a> (const tbb::blocked_range&lt; typename std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; * &gt;::iterator &gt; &amp;range, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const <a class="el" href="classBEMValues.html">BEMValues</a>&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const DoFHandler&lt; dim, spacedim &gt; &amp;kx_dof_handler, const DoFHandler&lt; dim, spacedim &gt; &amp;ky_dof_handler, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, const bool enable_build_symmetric_hmat=false)</td></tr>
<tr class="separator:aaa2498845e560f9756cc662f69926d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940383642627829f8864ce2695dddddb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a940383642627829f8864ce2695dddddb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a940383642627829f8864ce2695dddddb">fill_far_field_hmatrix_leaf_node_subrange_with_aca_plus</a> (const tbb::blocked_range&lt; typename std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; * &gt;::iterator &gt; &amp;range, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;mass_vmult_weq, const KernelNumberType stabilization_factor, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const <a class="el" href="classBEMValues.html">BEMValues</a>&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values, const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;bem_values_gpu, const DoFHandler&lt; dim, spacedim &gt; &amp;kx_dof_handler, const DoFHandler&lt; dim, spacedim &gt; &amp;ky_dof_handler, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, const bool enable_build_symmetric_hmat=false)</td></tr>
<tr class="separator:a940383642627829f8864ce2695dddddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bbf75055908b5a891d15bb0e165ada"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename RangeNumberType , typename KernelNumberType &gt; </td></tr>
<tr class="memitem:a23bbf75055908b5a891d15bb0e165ada"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a23bbf75055908b5a891d15bb0e165ada">stabilize_near_field_hmatrices_for_hypersingular_kernel</a> (const tbb::blocked_range&lt; typename std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; * &gt;::iterator &gt; &amp;range, const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;mass_vmult_weq, const KernelNumberType stabilization_factor, const bool enable_build_symmetric_hmat=true)</td></tr>
<tr class="separator:a23bbf75055908b5a891d15bb0e165ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b4856a4eec9a8556a30c3917bba821"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:ad8b4856a4eec9a8556a30c3917bba821"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#ad8b4856a4eec9a8556a30c3917bba821">fill_hmatrix_with_aca_plus_serial</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; &amp;hmat, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, KernelNumberType &gt; &amp;kernel, const KernelNumberType kernel_factor, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const <a class="el" href="structSauterQuadratureRule.html">SauterQuadratureRule</a>&lt; dim &gt; &amp;sauter_quad_rule, const DoFHandler&lt; dim, spacedim &gt; &amp;kx_dof_handler, const DoFHandler&lt; dim, spacedim &gt; &amp;ky_dof_handler, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, const bool enable_build_symmetric_hmat=false)</td></tr>
<tr class="memdesc:ad8b4856a4eec9a8556a30c3917bba821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the leaf set of the \(\mathcal{H}\)-matrix using ACA+, where the hierarchical structure of the \(\mathcal{H}\)-matrix has been built with respect to a block cluster tree and the memory for the matrices in the leaf set has been allocated.  <a href="aca__plus_8hcu.html#ad8b4856a4eec9a8556a30c3917bba821">More...</a><br /></td></tr>
<tr class="separator:ad8b4856a4eec9a8556a30c3917bba821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d38137c866826ac06288f167de4ec2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a75d38137c866826ac06288f167de4ec2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a75d38137c866826ac06288f167de4ec2">fill_hmatrix_with_aca_plus_serial</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; &amp;hmat, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, KernelNumberType &gt; &amp;kernel, const KernelNumberType kernel_factor, const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;mass_vmult_weq, const KernelNumberType stabilization_factor, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const <a class="el" href="structSauterQuadratureRule.html">SauterQuadratureRule</a>&lt; dim &gt; &amp;sauter_quad_rule, const DoFHandler&lt; dim, spacedim &gt; &amp;kx_dof_handler, const DoFHandler&lt; dim, spacedim &gt; &amp;ky_dof_handler, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, const bool enable_build_symmetric_hmat=false)</td></tr>
<tr class="memdesc:a75d38137c866826ac06288f167de4ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the leaf set of the \(\mathcal{H}\)-matrix using ACA+, where the hierarchical structure of the \(\mathcal{H}\)-matrix has been built with respect to a block cluster tree and the memory for the matrices in the leaf set has been allocated.  <a href="aca__plus_8hcu.html#a75d38137c866826ac06288f167de4ec2">More...</a><br /></td></tr>
<tr class="separator:a75d38137c866826ac06288f167de4ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05276d9c7b897d5faf8ae7105e840459"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a05276d9c7b897d5faf8ae7105e840459"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a05276d9c7b897d5faf8ae7105e840459">fill_hmatrix_with_aca_plus_serial</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; &amp;hmat, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, KernelNumberType &gt; &amp;kernel, const KernelNumberType kernel_factor, const typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type mass_matrix_factor, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const <a class="el" href="structSauterQuadratureRule.html">SauterQuadratureRule</a>&lt; dim &gt; &amp;sauter_quad_rule, const QGauss&lt; dim &gt; &amp;mass_matrix_quadrature_formula, const DoFHandler&lt; dim, spacedim &gt; &amp;kx_dof_handler, const DoFHandler&lt; dim, spacedim &gt; &amp;ky_dof_handler, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, const bool enable_build_symmetric_hmat=false)</td></tr>
<tr class="memdesc:a05276d9c7b897d5faf8ae7105e840459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the leaf set of the \(\mathcal{H}\)-matrix using ACA+, where the hierarchical structure of the \(\mathcal{H}\)-matrix has been built with respect to a block cluster tree and the memory for the matrices in the leaf set has been allocated.  <a href="aca__plus_8hcu.html#a05276d9c7b897d5faf8ae7105e840459">More...</a><br /></td></tr>
<tr class="separator:a05276d9c7b897d5faf8ae7105e840459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5caeec8d5a4b2c765362954dfdf971"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a5f5caeec8d5a4b2c765362954dfdf971"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a5f5caeec8d5a4b2c765362954dfdf971">fill_hmatrix_with_aca_plus_smp</a> (const unsigned int thread_num, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; &amp;hmat, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const <a class="el" href="structSauterQuadratureRule.html">SauterQuadratureRule</a>&lt; dim &gt; &amp;sauter_quad_rule, const DoFHandler&lt; dim, spacedim &gt; &amp;kx_dof_handler, const DoFHandler&lt; dim, spacedim &gt; &amp;ky_dof_handler, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, const bool enable_build_symmetric_hmat=false)</td></tr>
<tr class="memdesc:a5f5caeec8d5a4b2c765362954dfdf971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the leaf set of the \(\mathcal{H}\)-matrix using ACA+, where the hierarchical structure of the \(\mathcal{H}\)-matrix has been built with respect to a block cluster tree and the memory for the matrices in the leaf set has been allocated.  <a href="aca__plus_8hcu.html#a5f5caeec8d5a4b2c765362954dfdf971">More...</a><br /></td></tr>
<tr class="separator:a5f5caeec8d5a4b2c765362954dfdf971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd2dbd4ad6df605470a2bd027719909"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a1cd2dbd4ad6df605470a2bd027719909"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a1cd2dbd4ad6df605470a2bd027719909">fill_hmatrix_with_aca_plus_smp</a> (const unsigned int thread_num, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; &amp;hmat, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;mass_vmult_weq, const KernelNumberType stabilization_factor, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const <a class="el" href="structSauterQuadratureRule.html">SauterQuadratureRule</a>&lt; dim &gt; &amp;sauter_quad_rule, const DoFHandler&lt; dim, spacedim &gt; &amp;kx_dof_handler, const DoFHandler&lt; dim, spacedim &gt; &amp;ky_dof_handler, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, const bool enable_build_symmetric_hmat=false)</td></tr>
<tr class="memdesc:a1cd2dbd4ad6df605470a2bd027719909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the leaf set of the \(\mathcal{H}\)-matrix using ACA+, where the hierarchical structure of the \(\mathcal{H}\)-matrix has been built with respect to a block cluster tree and the memory for the matrices in the leaf set has been allocated.  <a href="aca__plus_8hcu.html#a1cd2dbd4ad6df605470a2bd027719909">More...</a><br /></td></tr>
<tr class="separator:a1cd2dbd4ad6df605470a2bd027719909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26038651b45700c103ce038766e59775"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </td></tr>
<tr class="memitem:a26038651b45700c103ce038766e59775"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#a26038651b45700c103ce038766e59775">fill_hmatrix_with_aca_plus_smp</a> (const unsigned int thread_num, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; &amp;hmat, const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;aca_config, const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;kernel, const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; kernel_factor, const typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type mass_matrix_factor, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;kx_dof_to_cell_topo, const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;ky_dof_to_cell_topo, const <a class="el" href="structSauterQuadratureRule.html">SauterQuadratureRule</a>&lt; dim &gt; &amp;sauter_quad_rule, const QGauss&lt; dim &gt; &amp;mass_matrix_quadrature_formula, const DoFHandler&lt; dim, spacedim &gt; &amp;kx_dof_handler, const DoFHandler&lt; dim, spacedim &gt; &amp;ky_dof_handler, const std::vector&lt; types::global_dof_index &gt; *kx_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; *ky_map_from_local_to_full_dof_indices, const std::vector&lt; types::global_dof_index &gt; &amp;kx_dof_i2e_numbering, const std::vector&lt; types::global_dof_index &gt; &amp;ky_dof_i2e_numbering, const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;mappings, const std::map&lt; types::material_id, unsigned int &gt; &amp;material_id_to_mapping_index, const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;normal_detector, const bool enable_build_symmetric_hmat=false)</td></tr>
<tr class="memdesc:a26038651b45700c103ce038766e59775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the leaf set of the \(\mathcal{H}\)-matrix using ACA+, where the hierarchical structure of the \(\mathcal{H}\)-matrix has been built with respect to a block cluster tree and the memory for the matrices in the leaf set has been allocated.  <a href="aca__plus_8hcu.html#a26038651b45700c103ce038766e59775">More...</a><br /></td></tr>
<tr class="separator:a26038651b45700c103ce038766e59775"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af80168c5d1672d91c79309bcee22bb56"><td class="memItemLeft" align="right" valign="top">std::mt19937&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="aca__plus_8hcu.html#af80168c5d1672d91c79309bcee22bb56">rand_engine</a></td></tr>
<tr class="separator:af80168c5d1672d91c79309bcee22bb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Implement the ACA+ method proposed in Grasedyck, L. 2005. “Adaptive Recompression of \(\mathscr{H}\)-Matrices for BEM.” Computing 74 (3): 205–23. </p>
<dl class="section date"><dt>Date</dt><dd>2022-03-07 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jihuan Tian </dd></dl>

<p class="definition">Definition in file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a587c6ba5afc1f4c851d0798ce6639179" name="a587c6ba5afc1f4c851d0798ce6639179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587c6ba5afc1f4c851d0798ce6639179">&#9670;&nbsp;</a></span>HIERBEM_INCLUDE_HMATRIX_ACA_PLUS_ACA_PLUS_H_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HIERBEM_INCLUDE_HMATRIX_ACA_PLUS_ACA_PLUS_H_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l00021">21</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a31f3d4d24e52e94ab4a4ad115a04fd0e" name="a31f3d4d24e52e94ab4a4ad115a04fd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f3d4d24e52e94ab4a4ad115a04fd0e">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> =  std::make_unsigned&lt;types::blas_int&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The type used for matrix row and column indices. </p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l00090">90</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7c61817f34be4e110bbaa1b478061768" name="a7c61817f34be4e110bbaa1b478061768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c61817f34be4e110bbaa1b478061768">&#9670;&nbsp;</a></span>aca_plus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void aca_plus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rkmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >ACA+ algorithm for verification purpose. The matrix for the current block is passed in as a full matrix without kernel function evaluation.</p>
<p >Grasedyck, L. 2005. “Adaptive Recompression of \(\mathcal{H}\)-Matrices for BEM.” Computing 74 (3): 205–23.}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rkmat</td><td>The rank-k matrix to be constructed for the current block, the memory of which should be preallocated and the formal rank of which should be the same as the maximum iteration number in <code>aca_config</code>. </td></tr>
    <tr><td class="paramname">aca_config</td><td></td></tr>
    <tr><td class="paramname">A</td><td>The full matrix to be approximated </td></tr>
  </table>
  </dd>
</dl>
<p >Get the size of each dimension of the matrix block to be built.</p>
<p >Create matrix references associated with the component matrices in the rank-k matrix to be returned, which hold the row and column vectors in the selected crosses during the ACA iteration. The number of columns should be the same as the maximum iteration number in <code>aca_config</code>.</p>
<p >Generate two lists for storing remaining row indices and column indices of the matrix block.</p>
<p >Select the initial reference row and column vectors and return their matrix indices.</p>
<p >The absolute values for the reference row and column vectors.</p>
<p >Calculate the absolute values for the reference row and column vectors.</p>
<dl class="section note">
<dt>Note</dt>
<dd>In the following, we use <code>static_cast</code> to explicitly specify which version of <code>std::abs</code> to call.</dd>
</dl>
<p >Row and column indices for the \(k\)'th step. The corresponding row and column vectors comprise the cross.</p>
<p >Temporary row and column vectors for the current step \(k\).</p>
<p >The absolute values for the temporary row and column vectors for the current step \(k\).</p>
<p >Temporary row and column vectors for the previous step \(l\).</p>
<p >Start the ACA+ iteration from \(k=1\).</p>
<p >Select the row index from the maximizer of the reference column.</p>
<p >Select the column index from the maximizer of the reference row.</p>
<p >Select \(i^*\) as the current row index \(i_k\).</p>
<p >Extract the \(i_k\)'th row of \(A\).</p>
<dl class="section note">
<dt>Note</dt>
<dd>Here the counter \(l\) iterates over all the previous steps before \(k\). For each step, the row and column vectors comprising the cross have been stored as column vectors into <code>v_mat</code> and <code>u_mat</code> respectively. Hence, the index for extracting vectors from <code>v_mat</code> or <code>u_mat</code> should be \(l-1\).</dd>
</dl>
<p >Extract the previous cross.</p>
<p >Select the column index from the maximizer of the absolute values of \(\widetilde{v}_k\).</p>
<p >Scale the vector \(\widetilde{v}_k\).</p>
<p >Extract the \(j_k\)'th column from \(A\).</p>
<p >Extract the previous cross.</p>
<p >Select \(j^*\) as the current column index \(j_k\).</p>
<p >Extract the \(j_k\)'th column from the matrix \(A\).</p>
<p >Extract the previous cross.</p>
<p >Select the row index as the maximizer of the absolute values of \(u_k\).</p>
<p >Extract the \(i_k\)'th row from \(A\).</p>
<p >Extract the previous cross.</p>
<p >Scale the vector \(\widetilde{v}_k\).</p>
<p >Update the matrices storing row and column vectors comprising the cross.</p>
<p >When the index of the selected row is the same as that of the reference row, reselect a reference row.</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >Extract the previous cross.</p>
<p >Otherwise, update the values of the reference row vector.</p>
<p >Update the vector of absolute values for <code>vr</code>.</p>
<p >When the index of the selected column is the same as that of the reference column, reselect a reference column.</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >Extract the previous cross.</p>
<p >Otherwise, update the values of the reference column vector.</p>
<p >Update the vector of absolute values for <code>uc</code>.</p>
<p >Check the convergence condition.</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l05432">5432</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="rkmatrix_8h_source.html#l02471">RkMatrix&lt; Number &gt;::get_m()</a>, and <a class="el" href="rkmatrix_8h_source.html#l02479">RkMatrix&lt; Number &gt;::get_n()</a>.</p>

</div>
</div>
<a id="a6428a269e829a9995aa8f2bfc4fa1b6a" name="a6428a269e829a9995aa8f2bfc4fa1b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6428a269e829a9995aa8f2bfc4fa1b6a">&#9670;&nbsp;</a></span>aca_plus_parallel_sauter_quad_for_vector_entry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void aca_plus_parallel_sauter_quad_for_vector_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rkmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_dof_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_dof_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >ACA+ algorithm</p>
<p >Grasedyck, L. 2005. “Adaptive Recompression of \(\mathcal{H}\)-Matrices for BEM.” Computing 74 (3): 205–23.}</p>
<dl class="section note">
<dt>Note</dt>
<dd>At present, the simple convergence condition in this paper is adopted instead of that in Bebendorf's book.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rkmat</td><td>The rank-k matrix to be constructed for the current block, the memory of which should be preallocated and the formal rank of which should be the same as the maximum iteration number in <code>aca_config</code>. </td></tr>
    <tr><td class="paramname">aca_config</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">factor</td><td></td></tr>
    <tr><td class="paramname">row_dof_indices</td><td></td></tr>
    <tr><td class="paramname">col_dof_indices</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">bem_values</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_mapping</td><td></td></tr>
    <tr><td class="paramname">ky_mapping</td><td></td></tr>
    <tr><td class="paramname">scratch_data</td><td></td></tr>
    <tr><td class="paramname">copy_data</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Adjust the maximum ACA+ iteration if is larger than the matrix dimension.</p>
<p >Generate lists of internal DoF indices (internal DoF numbering) from corresponding index ranges.</p>
<p >Create matrix references associated with the component matrices in the rank-k matrix to be returned, which hold the row and column vectors in the selected crosses during the ACA iteration. The number of columns should be the same as the effective maximum iteration number.</p>
<p >Generate two lists for storing remaining row indices and column indices of the matrix block.</p>
<p >Select the initial reference row and column vectors and return their matrix indices.</p>
<p >The absolute values for the reference row and column vectors.</p>
<p >Calculate the absolute values for the reference row and column vectors.</p>
<dl class="section note">
<dt>Note</dt>
<dd>In the following, we use <code>static_cast</code> to explicitly specify which version of <code>std::abs</code> to call.</dd>
</dl>
<p >Row and column indices for the \(k\)'th step. The corresponding row and column vectors comprise the cross.</p>
<p >Temporary row and column vectors for the current step \(k\).</p>
<p >The absolute values for the temporary row and column vectors for the current step \(k\).</p>
<p >Temporary row and column vectors for the previous step \(l\).</p>
<p >The error threshold as the stopping condition.</p>
<p >Start the ACA+ iteration from \(k=1\).</p>
<p >Select the row index from the maximizer of the reference column.</p>
<p >Select the column index from the maximizer of the reference row.</p>
<p >Select \(i^*\) as the current row index \(i_k\).</p>
<p >Extract the \(i_k\)'th row of \(A\).</p>
<dl class="section note">
<dt>Note</dt>
<dd>Here the counter \(l\) iterates over all the previous steps before \(k\). For each step, the row and column vectors comprising the cross have been stored as column vectors into <code>v_mat</code> and <code>u_mat</code> respectively. Hence, the index for extracting vectors from <code>v_mat</code> or <code>u_mat</code> should be \(l-1\).</dd>
</dl>
<p >Extract the previous cross.</p>
<p >Select the column index from the maximizer of the absolute values of \(\widetilde{v}_k\).</p>
<p >Scale the vector \(\widetilde{v}_k\).</p>
<p >Extract the \(j_k\)'th column from \(A\).</p>
<p >Extract the previous cross.</p>
<p >Select \(j^*\) as the current column index \(j_k\).</p>
<p >Extract the \(j_k\)'th column from the matrix \(A\).</p>
<p >Extract the previous cross.</p>
<p >Select the row index as the maximizer of the absolute values of \(u_k\).</p>
<p >Extract the \(i_k\)'th row from \(A\).</p>
<p >Extract the previous cross.</p>
<p >Scale the vector \(\widetilde{v}_k\).</p>
<p >Update the matrices storing row and column vectors comprising the cross.</p>
<p >Calculate the error threshold only in the first step.</p>
<p >When the index of the selected row is the same as that of the reference row, reselect a reference row.</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >Extract the previous cross.</p>
<p >Otherwise, update the values of the reference row vector.</p>
<p >Update the vector of absolute values for <code>vr</code>.</p>
<p >When the index of the selected column is the same as that of the reference column, reselect a reference column.</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >Extract the previous cross.</p>
<p >Otherwise, update the values of the reference column vector.</p>
<p >Update the vector of absolute values for <code>uc</code>.</p>
<p >Check the convergence condition.</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l02483">2483</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">Referenced by <a class="el" href="aca__plus_8hcu_source.html#l05981">fill_hmatrix_leaf_node_with_aca_plus()</a>.</p>

</div>
</div>
<a id="acd3713cd3e5b5a177a3571e01d55ebfe" name="acd3713cd3e5b5a177a3571e01d55ebfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3713cd3e5b5a177a3571e01d55ebfe">&#9670;&nbsp;</a></span>aca_plus_parallel_sauter_quad_for_vector_entry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void aca_plus_parallel_sauter_quad_for_vector_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rkmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_vmult_weq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>stabilization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_dof_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_dof_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >ACA+ algorithm</p>
<p >Grasedyck, L. 2005. “Adaptive Recompression of \(\mathcal{H}\)-Matrices for BEM.” Computing 74 (3): 205–23.}</p>
<dl class="section note">
<dt>Note</dt>
<dd>1. At present, the simple convergence condition in this paper is adopted instead of that in Bebendorf's book.<ol type="1">
<li>This version is especially for assembling the regularized hyper-singular matrix with the stabilization term.</li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rkmat</td><td></td></tr>
    <tr><td class="paramname">aca_config</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">factor</td><td></td></tr>
    <tr><td class="paramname">mass_vmult_weq</td><td></td></tr>
    <tr><td class="paramname">stabilization_factor</td><td></td></tr>
    <tr><td class="paramname">row_dof_index_range</td><td></td></tr>
    <tr><td class="paramname">col_dof_index_range</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">bem_values</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">ky_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">kx_mapping</td><td></td></tr>
    <tr><td class="paramname">ky_mapping</td><td></td></tr>
    <tr><td class="paramname">scratch_data</td><td></td></tr>
    <tr><td class="paramname">copy_data</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Get the size of each dimension of the matrix block to be built.</p>
<p >Adjust the maximum ACA+ iteration if is larger than the matrix dimension.</p>
<p >Generate lists of internal DoF indices (internal DoF numbering) from corresponding index ranges.</p>
<p >Create matrix references associated with the component matrices in the rank-k matrix to be returned, which hold the row and column vectors in the selected crosses during the ACA iteration. The number of columns should be the same as the effective maximum iteration number.</p>
<p >Generate two lists for storing remaining row indices and column indices of the matrix block.</p>
<p >Select the initial reference row and column vectors and return their matrix indices.</p>
<p >The absolute values for the reference row and column vectors.</p>
<p >Calculate the absolute values for the reference row and column vectors.</p>
<dl class="section note">
<dt>Note</dt>
<dd>In the following, we use <code>static_cast</code> to explicitly specify which version of <code>std::abs</code> to call.</dd>
</dl>
<p >Row and column indices for the \(k\)'th step. The corresponding row and column vectors comprise the cross.</p>
<p >Temporary row and column vectors for the current step \(k\).</p>
<p >The absolute values for the temporary row and column vectors for the current step \(k\).</p>
<p >Temporary row and column vectors for the previous step \(l\).</p>
<p >The error threshold as the stopping condition.</p>
<p >Start the ACA+ iteration from \(k=1\).</p>
<p >Select the row index from the maximizer of the reference column.</p>
<p >Select the column index from the maximizer of the reference row.</p>
<p >Select \(i^*\) as the current row index \(i_k\).</p>
<p >Extract the \(i_k\)'th row of \(A\).</p>
<dl class="section note">
<dt>Note</dt>
<dd>Here the counter \(l\) iterates over all the previous steps before \(k\). For each step, the row and column vectors comprising the cross have been stored as column vectors into <code>v_mat</code> and <code>u_mat</code> respectively. Hence, the index for extracting vectors from <code>v_mat</code> or <code>u_mat</code> should be \(l-1\).</dd>
</dl>
<p >Extract the previous cross.</p>
<p >Select the column index from the maximizer of the absolute values of \(\widetilde{v}_k\).</p>
<p >Scale the vector \(\widetilde{v}_k\).</p>
<p >Extract the \(j_k\)'th column from \(A\).</p>
<p >Extract the previous cross.</p>
<p >Select \(j^*\) as the current column index \(j_k\).</p>
<p >Extract the \(j_k\)'th column from the matrix \(A\).</p>
<p >Extract the previous cross.</p>
<p >Select the row index as the maximizer of the absolute values of \(u_k\).</p>
<p >Extract the \(i_k\)'th row from \(A\).</p>
<p >Extract the previous cross.</p>
<p >Scale the vector \(\widetilde{v}_k\).</p>
<p >Update the matrices storing row and column vectors comprising the cross.</p>
<p >Calculate the error threshold only in the first step.</p>
<p >When the index of the selected row is the same as that of the reference row, reselect a reference row.</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >Extract the previous cross.</p>
<p >Otherwise, update the values of the reference row vector.</p>
<p >Update the vector of absolute values for <code>vr</code>.</p>
<p >When the index of the selected column is the same as that of the reference column, reselect a reference column.</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >Extract the previous cross.</p>
<p >Otherwise, update the values of the reference column vector.</p>
<p >Update the vector of absolute values for <code>uc</code>.</p>
<p >Check the convergence condition.</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l03191">3191</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

</div>
</div>
<a id="a03dca24726be53cb76756baa595c49a9" name="a03dca24726be53cb76756baa595c49a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03dca24726be53cb76756baa595c49a9">&#9670;&nbsp;</a></span>aca_plus_parallel_sauter_quad_for_whole_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void aca_plus_parallel_sauter_quad_for_whole_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rkmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_dof_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_dof_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBEMValues.html">BEMValues</a>&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_dof_index_range</td><td>Local DoF index range with internal numbering for the rows of the current matrix block. </td></tr>
    <tr><td class="paramname">col_dof_index_range</td><td>Local DoF index range with internal numbering for the columns of the current matrix block. </td></tr>
  </table>
  </dd>
</dl>
<p >Adjust the maximum ACA+ iteration if is larger than the matrix dimension.</p>
<p >Generate lists of local DoF indices with internal DoF numbering from corresponding index ranges.</p>
<p >Create matrix references associated with the component matrices in the rank-k matrix to be returned, which hold the row and column vectors in the selected crosses during the ACA iteration. The number of columns should be the same as the effective maximum iteration number.</p>
<p >Generate two lists for storing remaining row indices and column indices of the matrix block.</p>
<p >Select the initial reference row and column vectors and return their matrix indices.</p>
<p >The absolute values for the reference row and column vectors.</p>
<p >Calculate the absolute values for the reference row and column vectors.</p>
<dl class="section note">
<dt>Note</dt>
<dd>In the following, we use <code>static_cast</code> to explicitly specify which version of <code>std::abs</code> to call.</dd>
</dl>
<p >Row and column indices for the \(k\)'th step. The corresponding row and column vectors comprise the cross.</p>
<p >Temporary row and column vectors for the current step \(k\).</p>
<p >The absolute values for the temporary row and column vectors for the current step \(k\).</p>
<p >Temporary row and column vectors for the previous step \(l\).</p>
<p >The error threshold as the stopping condition.</p>
<p >Start the ACA+ iteration from \(k=1\).</p>
<p >Select the row index from the maximizer of the reference column.</p>
<p >Select the column index from the maximizer of the reference row.</p>
<p >Select \(i^*\) as the current row index \(i_k\).</p>
<p >Extract the \(i_k\)'th row of \(A\).</p>
<dl class="section note">
<dt>Note</dt>
<dd>Here the counter \(l\) iterates over all the previous steps before \(k\). For each step, the row and column vectors comprising the cross have been stored as column vectors into <code>v_mat</code> and <code>u_mat</code> respectively. Hence, the index for extracting vectors from <code>v_mat</code> or <code>u_mat</code> should be \(l-1\).</dd>
</dl>
<p >Extract the previous cross.</p>
<p >Select the column index from the maximizer of the absolute values of \(\widetilde{v}_k\).</p>
<p >Scale the vector \(\widetilde{v}_k\).</p>
<p >Extract the \(j_k\)'th column from \(A\).</p>
<p >Extract the previous cross.</p>
<p >Select \(j^*\) as the current column index \(j_k\).</p>
<p >Extract the \(j_k\)'th column from the matrix \(A\).</p>
<p >Extract the previous cross.</p>
<p >Select the row index as the maximizer of the absolute values of \(u_k\).</p>
<p >Extract the \(i_k\)'th row from \(A\).</p>
<p >Extract the previous cross.</p>
<p >Scale the vector \(\widetilde{v}_k\).</p>
<p >Update the matrices storing row and column vectors comprising the cross.</p>
<p >Calculate the error threshold only in the first step.</p>
<p >When the index of the selected row is the same as that of the reference row, reselect a reference row.</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >Extract the previous cross.</p>
<p >Otherwise, update the values of the reference row vector.</p>
<p >Update the vector of absolute values for <code>vr</code>.</p>
<p >When the index of the selected column is the same as that of the reference column, reselect a reference column.</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >Extract the previous cross.</p>
<p >Otherwise, update the values of the reference column vector.</p>
<p >Update the vector of absolute values for <code>uc</code>.</p>
<p >Check the convergence condition.</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l03890">3890</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">Referenced by <a class="el" href="aca__plus_8hcu_source.html#l07151">fill_far_field_hmatrix_leaf_node_with_aca_plus()</a>.</p>

</div>
</div>
<a id="ab15190d613396372594d0ae2ed49b748" name="ab15190d613396372594d0ae2ed49b748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15190d613396372594d0ae2ed49b748">&#9670;&nbsp;</a></span>aca_plus_parallel_sauter_quad_for_whole_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void aca_plus_parallel_sauter_quad_for_whole_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rkmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_vmult_weq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>stabilization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_dof_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_dof_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBEMValues.html">BEMValues</a>&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the size of each dimension of the matrix block to be built.</p>
<p >Adjust the maximum ACA+ iteration if is larger than the matrix dimension.</p>
<p >Generate lists of internal DoF indices (internal DoF numbering) from corresponding index ranges.</p>
<p >Create matrix references associated with the component matrices in the rank-k matrix to be returned, which hold the row and column vectors in the selected crosses during the ACA iteration. The number of columns should be the same as the effective maximum iteration number.</p>
<p >Generate two lists for storing remaining row indices and column indices of the matrix block.</p>
<p >Select the initial reference row and column vectors and return their matrix indices.</p>
<p >The absolute values for the reference row and column vectors.</p>
<p >Calculate the absolute values for the reference row and column vectors.</p>
<dl class="section note">
<dt>Note</dt>
<dd>In the following, we use <code>static_cast</code> to explicitly specify which version of <code>std::abs</code> to call.</dd>
</dl>
<p >Row and column indices for the \(k\)'th step. The corresponding row and column vectors comprise the cross.</p>
<p >Temporary row and column vectors for the current step \(k\).</p>
<p >The absolute values for the temporary row and column vectors for the current step \(k\).</p>
<p >Temporary row and column vectors for the previous step \(l\).</p>
<p >The error threshold as the stopping condition.</p>
<p >Start the ACA+ iteration from \(k=1\).</p>
<p >Select the row index from the maximizer of the reference column.</p>
<p >Select the column index from the maximizer of the reference row.</p>
<p >Select \(i^*\) as the current row index \(i_k\).</p>
<p >Extract the \(i_k\)'th row of \(A\).</p>
<dl class="section note">
<dt>Note</dt>
<dd>Here the counter \(l\) iterates over all the previous steps before \(k\). For each step, the row and column vectors comprising the cross have been stored as column vectors into <code>v_mat</code> and <code>u_mat</code> respectively. Hence, the index for extracting vectors from <code>v_mat</code> or <code>u_mat</code> should be \(l-1\).</dd>
</dl>
<p >Extract the previous cross.</p>
<p >Select the column index from the maximizer of the absolute values of \(\widetilde{v}_k\).</p>
<p >Scale the vector \(\widetilde{v}_k\).</p>
<p >Extract the \(j_k\)'th column from \(A\).</p>
<p >Extract the previous cross.</p>
<p >Select \(j^*\) as the current column index \(j_k\).</p>
<p >Extract the \(j_k\)'th column from the matrix \(A\).</p>
<p >Extract the previous cross.</p>
<p >Select the row index as the maximizer of the absolute values of \(u_k\).</p>
<p >Extract the \(i_k\)'th row from \(A\).</p>
<p >Extract the previous cross.</p>
<p >Scale the vector \(\widetilde{v}_k\).</p>
<p >Update the matrices storing row and column vectors comprising the cross.</p>
<p >Calculate the error threshold only in the first step.</p>
<p >When the index of the selected row is the same as that of the reference row, reselect a reference row.</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >Extract the previous cross.</p>
<p >Otherwise, update the values of the reference row vector.</p>
<p >Update the vector of absolute values for <code>vr</code>.</p>
<p >When the index of the selected column is the same as that of the reference column, reselect a reference column.</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >Extract the previous cross.</p>
<p >Otherwise, update the values of the reference column vector.</p>
<p >Update the vector of absolute values for <code>uc</code>.</p>
<p >Check the convergence condition.</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >If the number of ACA+ iterations is less than the allowed maximum value, the <code>rkmat</code> should be truncated to its actual rank.</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>
<p >Apply complex conjugation to the component matrix <code>B</code>, when we're dealing with complex values, because the rank-k matrix should take the form \(M=AB^{\mathrm{H}}\).</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l04649">4649</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

</div>
</div>
<a id="aa3f293d8bb18c5df1581da566473be91" name="aa3f293d8bb18c5df1581da566473be91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f293d8bb18c5df1581da566473be91">&#9670;&nbsp;</a></span>assemble_kernel_column() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void assemble_kernel_column </td>
          <td>(</td>
          <td class="paramtype">HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; RangeNumberType &gt;, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>task_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const types::global_dof_index&#160;</td>
          <td class="paramname"><em>col_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Assemble a column vector by evaluating the Galerkin-BEM double integral with respect to the kernel. This version parallelizes over each vector element. </p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l00765">765</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="bem__values_8hcu_source.html#l01895">PairCellWiseScratchData&lt; dim, spacedim, KernelNumberType &gt;::cuda_stream_handle</a>.</p>

</div>
</div>
<a id="a0e6a66a2d32b330d4e5d6885ded3692c" name="a0e6a66a2d32b330d4e5d6885ded3692c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6a66a2d32b330d4e5d6885ded3692c">&#9670;&nbsp;</a></span>assemble_kernel_column() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void assemble_kernel_column </td>
          <td>(</td>
          <td class="paramtype">HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; RangeNumberType &gt;, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>task_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_vmult_weq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>stabilization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const types::global_dof_index&#160;</td>
          <td class="paramname"><em>col_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Assemble a column vector by evaluating the Galerkin-BEM double integral with respect to the kernel. This version regularizes the kernel and parallelizes over each vector element. </p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l00870">870</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l00557">assemble_kernel_column()</a>.</p>

</div>
</div>
<a id="ab9653c418c44a4407a7bff50f11e8ed1" name="ab9653c418c44a4407a7bff50f11e8ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9653c418c44a4407a7bff50f11e8ed1">&#9670;&nbsp;</a></span>assemble_kernel_column() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void assemble_kernel_column </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const types::global_dof_index&#160;</td>
          <td class="paramname"><em>col_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Assemble a column vector by evaluating the Galerkin-BEM double integral with respect to the kernel.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The memory for <code>col_vector</code> should be preallocated, since inside the function there is no reinitialization of this vector anymore.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col_vector</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">factor</td><td></td></tr>
    <tr><td class="paramname">row_dof_indices</td><td>The list of row DoF indices in the global internal DoF numbering. </td></tr>
    <tr><td class="paramname">col_dof_index</td><td>The column DoF index in the global internal DoF numbering. </td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">bem_values</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">ky_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">kx_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">ky_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">kx_mapping</td><td></td></tr>
    <tr><td class="paramname">ky_mapping</td><td></td></tr>
    <tr><td class="paramname">scratch_data</td><td></td></tr>
    <tr><td class="paramname">copy_data</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Iterate over each row DoF index.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l00557">557</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">Referenced by <a class="el" href="aca__plus_8hcu_source.html#l00870">assemble_kernel_column()</a>, and <a class="el" href="aca__plus_8hcu_source.html#l01733">random_select_ref_column()</a>.</p>

</div>
</div>
<a id="aaf2d57d87bc349d4d5390724186a0da8" name="aaf2d57d87bc349d4d5390724186a0da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2d57d87bc349d4d5390724186a0da8">&#9670;&nbsp;</a></span>assemble_kernel_column() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void assemble_kernel_column </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_vmult_weq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>stabilization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const types::global_dof_index&#160;</td>
          <td class="paramname"><em>col_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Assemble a column vector by evaluating the Galerkin-BEM double integral with respect to the kernel.</p>
<dl class="section note">
<dt>Note</dt>
<dd>1. The memory for <code>col_vector</code> should be preallocated, since inside the function there is no reinitialization of this vector anymore.<ol type="1">
<li>This version is especially for assembling the regularized hyper-singular matrix with the stabilization term.</li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col_vector</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">factor</td><td></td></tr>
    <tr><td class="paramname">mass_vmult_weq</td><td></td></tr>
    <tr><td class="paramname">row_dof_indices</td><td></td></tr>
    <tr><td class="paramname">col_dof_index</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">bem_values</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">ky_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">kx_mapping</td><td></td></tr>
    <tr><td class="paramname">ky_mapping</td><td></td></tr>
    <tr><td class="paramname">scratch_data</td><td></td></tr>
    <tr><td class="paramname">copy_data</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Iterate over each row DoF index.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l00669">669</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

</div>
</div>
<a id="a99d7b3974ab184f8379fa3b7894dc60c" name="a99d7b3974ab184f8379fa3b7894dc60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d7b3974ab184f8379fa3b7894dc60c">&#9670;&nbsp;</a></span>assemble_kernel_row() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void assemble_kernel_row </td>
          <td>(</td>
          <td class="paramtype">HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; RangeNumberType &gt;, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>task_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_vmult_weq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>stabilization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const types::global_dof_index&#160;</td>
          <td class="paramname"><em>row_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Assemble a row vector by evaluating the Galerkin-BEM double integral with respect to the kernel. This version regularizes the kernel and parallelizes over each vector element. </p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l00450">450</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l00125">assemble_kernel_row()</a>.</p>

</div>
</div>
<a id="a66c278a79ce34123a62ecf24b708c0a7" name="a66c278a79ce34123a62ecf24b708c0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c278a79ce34123a62ecf24b708c0a7">&#9670;&nbsp;</a></span>assemble_kernel_row() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void assemble_kernel_row </td>
          <td>(</td>
          <td class="paramtype">HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; RangeNumberType &gt;, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>task_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const types::global_dof_index&#160;</td>
          <td class="paramname"><em>row_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Assemble a row vector by evaluating the Galerkin-BEM double integral with respect to the kernel. This version parallelizes over each vector element. </p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l00341">341</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="bem__values_8hcu_source.html#l01895">PairCellWiseScratchData&lt; dim, spacedim, KernelNumberType &gt;::cuda_stream_handle</a>.</p>

</div>
</div>
<a id="acf2289ded23006142250878af068f94f" name="acf2289ded23006142250878af068f94f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2289ded23006142250878af068f94f">&#9670;&nbsp;</a></span>assemble_kernel_row() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void assemble_kernel_row </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_vmult_weq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>stabilization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const types::global_dof_index&#160;</td>
          <td class="paramname"><em>row_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Assemble a row vector by evaluating the Galerkin-BEM double integral with respect to the kernel.</p>
<dl class="section note">
<dt>Note</dt>
<dd>1. The memory for <code>row_vector</code> should be preallocated, since inside the function there is no reinitialization of this vector anymore.<ol type="1">
<li>This version is especially for assembling the regularized hyper-singular matrix with the stabilization term.</li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_vector</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">kernel_factor</td><td></td></tr>
    <tr><td class="paramname">mass_vmult_weq</td><td></td></tr>
    <tr><td class="paramname">stabilization_factor</td><td></td></tr>
    <tr><td class="paramname">row_dof_index</td><td></td></tr>
    <tr><td class="paramname">column_dof_indices</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">bem_values</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">ky_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">kx_mapping</td><td></td></tr>
    <tr><td class="paramname">ky_mapping</td><td></td></tr>
    <tr><td class="paramname">scratch_data</td><td></td></tr>
    <tr><td class="paramname">copy_data</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Iterate over each column DoF index.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l00242">242</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

</div>
</div>
<a id="aba3f06ec4db7ede6e771c3bf637854f9" name="aba3f06ec4db7ede6e771c3bf637854f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3f06ec4db7ede6e771c3bf637854f9">&#9670;&nbsp;</a></span>assemble_kernel_row() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void assemble_kernel_row </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const types::global_dof_index&#160;</td>
          <td class="paramname"><em>row_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Assemble a row vector by evaluating the Galerkin-BEM double integral with respect to the kernel.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The memory for <code>row_vector</code> should be preallocated, since inside the function there is no reinitialization of this vector anymore.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_vector</td><td>[out] </td></tr>
    <tr><td class="paramname">scratch</td><td></td></tr>
    <tr><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">row_dof_index</td><td>The current row DoF index. </td></tr>
    <tr><td class="paramname">column_dof_indices</td><td>The list of column DoF indices. </td></tr>
  </table>
  </dd>
</dl>
<p >Iterate over each column DoF index.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l00125">125</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">Referenced by <a class="el" href="aca__plus_8hcu_source.html#l00450">assemble_kernel_row()</a>, and <a class="el" href="aca__plus_8hcu_source.html#l00981">random_select_ref_row()</a>.</p>

</div>
</div>
<a id="aaa2498845e560f9756cc662f69926d13" name="aaa2498845e560f9756cc662f69926d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2498845e560f9756cc662f69926d13">&#9670;&nbsp;</a></span>fill_far_field_hmatrix_leaf_node_subrange_with_aca_plus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fill_far_field_hmatrix_leaf_node_subrange_with_aca_plus </td>
          <td>(</td>
          <td class="paramtype">const tbb::blocked_range&lt; typename std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; * &gt;::iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBEMValues.html">BEMValues</a>&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_build_symmetric_hmat</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fill the leaf nodes in a subrange of an \(\mathcal{H}\)-matrix using ACA+.</p>
<dl class="section note">
<dt>Note</dt>
<dd>This function is to be used for TBB parallelization.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td></td></tr>
    <tr><td class="paramname">aca_config</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">kernel_factor</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">bem_values</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_mapping</td><td></td></tr>
    <tr><td class="paramname">ky_mapping</td><td></td></tr>
    <tr><td class="paramname">enable_build_symmetric_hmat</td><td>Flag indicating whether symmetric \(\mathcal{H}\)-matrix will be built when the kernel function is symmetric. </td></tr>
  </table>
  </dd>
</dl>
<p >Define <code><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a></code> and <code><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a></code> which are local to the current working thread. This is mandatory because each current working thread should have its own copy of these data.</p>
<p >Release pair cell wise scratch and copy data.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l07507">7507</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l07151">fill_far_field_hmatrix_leaf_node_with_aca_plus()</a>.</p>

</div>
</div>
<a id="a940383642627829f8864ce2695dddddb" name="a940383642627829f8864ce2695dddddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940383642627829f8864ce2695dddddb">&#9670;&nbsp;</a></span>fill_far_field_hmatrix_leaf_node_subrange_with_aca_plus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fill_far_field_hmatrix_leaf_node_subrange_with_aca_plus </td>
          <td>(</td>
          <td class="paramtype">const tbb::blocked_range&lt; typename std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; * &gt;::iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_vmult_weq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>stabilization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBEMValues.html">BEMValues</a>&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_build_symmetric_hmat</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fill the leaf nodes in a subrange of an \(\mathcal{H}\)-matrix using ACA+.</p>
<dl class="section note">
<dt>Note</dt>
<dd>1. This function is to be used for TBB parallelization.<ol type="1">
<li>This version is especially for assembling the regularized hyper-singular matrix with the stabilization term.</li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td></td></tr>
    <tr><td class="paramname">aca_config</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">kernel_factor</td><td></td></tr>
    <tr><td class="paramname">mass_vmult_weq</td><td></td></tr>
    <tr><td class="paramname">stabilization_factor</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">bem_values</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">ky_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">kx_mapping</td><td></td></tr>
    <tr><td class="paramname">ky_mapping</td><td></td></tr>
    <tr><td class="paramname">enable_build_symmetric_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Define <code><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a></code> and <code><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a></code> which are local to the current working thread. This is mandatory because each current working thread should have its own copy of these data.</p>
<p >Release pair cell wise scratch and copy data.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l07632">7632</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l07151">fill_far_field_hmatrix_leaf_node_with_aca_plus()</a>.</p>

</div>
</div>
<a id="af31839e1a78b4af0965755292369dad5" name="af31839e1a78b4af0965755292369dad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31839e1a78b4af0965755292369dad5">&#9670;&nbsp;</a></span>fill_far_field_hmatrix_leaf_node_with_aca_plus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fill_far_field_hmatrix_leaf_node_with_aca_plus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; *&#160;</td>
          <td class="paramname"><em>leaf_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBEMValues.html">BEMValues</a>&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_build_symmetric_hmat</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >When the \(\mathcal{H}\)-matrix block type is rank-k matrix, when the top level \(\mathcal{H}\)-matrix is symmetric and the flag <code>enable_build_symmetric_hmat</code> is true, only those matrix blocks belong to the lower triangular part will be computed. Otherwise, the rank-k matrix block will always be computed. ACA+ will be used for building the rank-k matrix.</p>
<p >Build the \(\mathcal{H}\)-matrix block when it belongs to the lower triangular part using ACA+.</p>
<p >Do not build \(\mathcal{H}\)-matrix block belonging to the upper triangular part.</p>
<p >An rank-k matrix cannot belong to the diagonal part.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l07151">7151</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l03890">aca_plus_parallel_sauter_quad_for_whole_vector()</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l19656">HMatrix&lt; spacedim, Number &gt;::get_block_type()</a>, <a class="el" href="hmatrix_8h_source.html#l36011">HMatrix&lt; spacedim, Number &gt;::get_col_index_range()</a>, <a class="el" href="hmatrix_8h_source.html#l19772">HMatrix&lt; spacedim, Number &gt;::get_rkmatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l35995">HMatrix&lt; spacedim, Number &gt;::get_row_index_range()</a>, <a class="el" href="hmatrix_8h_source.html#l19052">HMatrix&lt; spacedim, Number &gt;::get_type()</a>, and <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="aca__plus_8hcu_source.html#l07507">fill_far_field_hmatrix_leaf_node_subrange_with_aca_plus()</a>.</p>

</div>
</div>
<a id="ac11fe42caf088b89d95fea0143ded9cc" name="ac11fe42caf088b89d95fea0143ded9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11fe42caf088b89d95fea0143ded9cc">&#9670;&nbsp;</a></span>fill_far_field_hmatrix_leaf_node_with_aca_plus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fill_far_field_hmatrix_leaf_node_with_aca_plus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; *&#160;</td>
          <td class="paramname"><em>leaf_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_vmult_weq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>stabilization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBEMValues.html">BEMValues</a>&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_build_symmetric_hmat</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >When the \(\mathcal{H}\)-matrix block type is rank-k matrix, when the top level \(\mathcal{H}\)-matrix is symmetric and the flag <code>enable_build_symmetric_hmat</code> is true, only those matrix blocks belong to the lower triangular part will be computed. Otherwise, the rank-k matrix block will always be computed. ACA+ will be used for building the rank-k matrix.</p>
<p >Build the \(\mathcal{H}\)-matrix block when it belongs to the lower triangular part using ACA+.</p>
<p >Do not build \(\mathcal{H}\)-matrix block belonging to the upper triangular part.</p>
<p >An rank-k matrix cannot belong to the diagonal part.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l07321">7321</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l03890">aca_plus_parallel_sauter_quad_for_whole_vector()</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l19656">HMatrix&lt; spacedim, Number &gt;::get_block_type()</a>, <a class="el" href="hmatrix_8h_source.html#l36011">HMatrix&lt; spacedim, Number &gt;::get_col_index_range()</a>, <a class="el" href="hmatrix_8h_source.html#l19772">HMatrix&lt; spacedim, Number &gt;::get_rkmatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l35995">HMatrix&lt; spacedim, Number &gt;::get_row_index_range()</a>, <a class="el" href="hmatrix_8h_source.html#l19052">HMatrix&lt; spacedim, Number &gt;::get_type()</a>, and <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

</div>
</div>
<a id="a23f2b8dc03e9189d238c74eff568abb5" name="a23f2b8dc03e9189d238c74eff568abb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f2b8dc03e9189d238c74eff568abb5">&#9670;&nbsp;</a></span>fill_hmatrix_leaf_node_with_aca_plus() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fill_hmatrix_leaf_node_with_aca_plus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; *&#160;</td>
          <td class="paramname"><em>leaf_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_build_symmetric_hmat</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a single leaf node of the \(\mathcal{H}\)-matrix using ACA+. If the matrix type is <code>RkMatrixType</code>, the memory for the full or rank-k matrix in the leaf node has been allocated. </p>
<p >For the near field matrix, full matrices will be built whose elements will be obtained from the evaluation of the double integral in Galerkin-BEM. For the far field admissible matrix, rank-k matrices will be built using ACA+.</p>
<dl class="section note">
<dt>Note</dt>
<dd>1. This is used as the work function for parallel \(\mathcal{H}\)-matrix construction using ACA+.<ol type="1">
<li>For near field matrix assembly, the producer-consumer model is not adopted. GPU parallelization with 2D thread grid is distributed over each quadrature point in the X direction and each k3 term in the Y direction.</li>
</ol>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td></td></tr>
    <tr><td class="paramname">spacedim</td><td></td></tr>
    <tr><td class="paramname">KernelFunctionType</td><td></td></tr>
    <tr><td class="paramname">RangeNumberType</td><td></td></tr>
    <tr><td class="paramname">KernelNumberType</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leaf_mat</td><td></td></tr>
    <tr><td class="paramname">aca_config</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">kernel_factor</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">bem_values_gpu</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">ky_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">kx_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">ky_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">mappings</td><td></td></tr>
    <tr><td class="paramname">material_id_to_mapping_index</td><td></td></tr>
    <tr><td class="paramname">normal_detector</td><td></td></tr>
    <tr><td class="paramname">scratch_data</td><td></td></tr>
    <tr><td class="paramname">scratch_data_gpu</td><td></td></tr>
    <tr><td class="paramname">copy_data</td><td></td></tr>
    <tr><td class="paramname">enable_build_symmetric_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >When the flag <code>enable_build_symmetric_hmat</code> is true and the kernel function is symmetric, try to build a symmetric \(\mathcal{H}\)-matrix. Otherwise, the whole full matrix will be built.</p>
<p >A diagonal \(\mathcal{H}\)-matrix block as well as its associated full matrix should be symmetric.</p>
<p >Only evaluate the diagonal and lower triangular elements in the full matrix.</p>
<p >Do not build \(\mathcal{H}\)-matrix block belonging to the upper triangular part.</p>
<p >When the current \(\mathcal{H}\)-matrix block belongs to the lower triangular part, evaluate all of its elements as usual.</p>
<p >Evaluate the whole full matrix.</p>
<p >When the \(\mathcal{H}\)-matrix block type is rank-k matrix, when the top level \(\mathcal{H}\)-matrix is symmetric and the flag <code>enable_build_symmetric_hmat</code> is true, only those matrix blocks belong to the lower triangular part will be computed. Otherwise, the rank-k matrix block will always be computed. ACA+ will be used for building the rank-k matrix.</p>
<p >Build the \(\mathcal{H}\)-matrix block when it belongs to the lower triangular part using ACA+.</p>
<p >Do not build \(\mathcal{H}\)-matrix block belonging to the upper triangular part.</p>
<p >An rank-k matrix cannot belong to the diagonal part.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l05981">5981</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l02483">aca_plus_parallel_sauter_quad_for_vector_entry()</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l19656">HMatrix&lt; spacedim, Number &gt;::get_block_type()</a>, <a class="el" href="hmatrix_8h_source.html#l36011">HMatrix&lt; spacedim, Number &gt;::get_col_index_range()</a>, <a class="el" href="hmatrix_8h_source.html#l19815">HMatrix&lt; spacedim, Number &gt;::get_fullmatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l06702">LAPACKFullMatrixExt&lt; Number &gt;::get_property()</a>, <a class="el" href="hmatrix_8h_source.html#l19772">HMatrix&lt; spacedim, Number &gt;::get_rkmatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l35995">HMatrix&lt; spacedim, Number &gt;::get_row_index_range()</a>, <a class="el" href="hmatrix_8h_source.html#l19052">HMatrix&lt; spacedim, Number &gt;::get_type()</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, and <a class="el" href="dof__to__cell__topology_8h_source.html#l00035">DoFToCellTopology&lt; dim, spacedim &gt;::topology</a>.</p>

<p class="reference">Referenced by <a class="el" href="aca__plus_8hcu_source.html#l07910">fill_hmatrix_with_aca_plus_serial()</a>.</p>

</div>
</div>
<a id="a04154c321261ad9f19a9a8fb3839ca56" name="a04154c321261ad9f19a9a8fb3839ca56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04154c321261ad9f19a9a8fb3839ca56">&#9670;&nbsp;</a></span>fill_hmatrix_leaf_node_with_aca_plus() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fill_hmatrix_leaf_node_with_aca_plus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; *&#160;</td>
          <td class="paramname"><em>leaf_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_vmult_weq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>stabilization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_build_symmetric_hmat</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a single leaf node of the \(\mathcal{H}\)-matrix using ACA+. If the matrix type is <code>RkMatrixType</code>, the memory for the full or rank-k matrix in the leaf node has been allocated. </p>
<p >For the near field matrix, full matrices will be built whose elements will be obtained from the evaluation of the double integral in Galerkin-BEM. For the far field admissible matrix, rank-k matrices will be built using ACA+.</p>
<dl class="section note">
<dt>Note</dt>
<dd><ol type="1">
<li>This is used as the work function for parallel \(\mathcal{H}\)-matrix construction using ACA+.</li>
<li>For near field matrix assembly, the producer-consumer model is not adopted. GPU parallelization with 2D thread grid is distributed over each quadrature point in the X direction and each k3 term in the Y direction.</li>
<li><p class="startli">This version is especially for assembling the regularized hyper-singular matrix appended with the stabilization term. The stabilization term in the variational equation is </p><p class="formulaDsp">
\[
  \alpha\langle \gamma_0^{\rm ext}u, \omega_{\rm eq} \rangle \cdot \langle
v, \omega_{\rm eq} \rangle_{\Gamma}. \]
</p>
<p class="startli">The stabilization term in the discretized form is </p><p class="formulaDsp">
\[
  \alpha M [\omega_{\rm eq}] \cdot \left[ M [\omega_{\rm eq}] \right]^{\rm
T} \cdot [\gamma_0^{\rm ext}u], \]
</p>
<p> which is actually an outer-product representation. The argument <code>mass_vmult_weq</code> passed to this function is just the vector \(M [\omega_{\rm eq}]\).</p>
</li>
</ol>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td></td></tr>
    <tr><td class="paramname">spacedim</td><td></td></tr>
    <tr><td class="paramname">KernelFunctionType</td><td></td></tr>
    <tr><td class="paramname">RangeNumberType</td><td></td></tr>
    <tr><td class="paramname">KernelNumberType</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leaf_mat</td><td></td></tr>
    <tr><td class="paramname">aca_config</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">kernel_factor</td><td></td></tr>
    <tr><td class="paramname">mass_vmult_weq</td><td>This is the multiplication of the mass matrix and natural density vector. When in the mixed boundary value problem, because it produces an intermediate result, the DoF indices associated with the result vector are the local DoF indices, which does not need the application of the internal-to-external map (which is caused by the renumbering due to cluster tree construction), nor the external local-to-full Dirichlet DoF index map (which is caused by selecting a subset of DoFs from the Dirichlet space.). </td></tr>
    <tr><td class="paramname">stabilization_factor</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">bem_values_gpu</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">ky_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">kx_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">ky_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">mappings</td><td></td></tr>
    <tr><td class="paramname">material_id_to_mapping_index</td><td></td></tr>
    <tr><td class="paramname">normal_detector</td><td></td></tr>
    <tr><td class="paramname">scratch_data</td><td></td></tr>
    <tr><td class="paramname">scratch_data_gpu</td><td></td></tr>
    <tr><td class="paramname">copy_data</td><td></td></tr>
    <tr><td class="paramname">enable_build_symmetric_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >When the flag <code>enable_build_symmetric_hmat</code> is true and the kernel function is symmetric, try to build a symmetric \(\mathcal{H}\)-matrix. Otherwise, the whole full matrix will be built.</p>
<p >A diagonal \(\mathcal{H}\)-matrix block as well as its associated full matrix should be symmetric.</p>
<p >Only evaluate the diagonal and lower triangular elements in the full matrix.</p>
<p >Do not build \(\mathcal{H}\)-matrix block belonging to the upper triangular part.</p>
<p >When the current \(\mathcal{H}\)-matrix block belongs to the lower triangular part, evaluate all of its elements as usual.</p>
<p >Evaluate the whole full matrix.</p>
<p >When the \(\mathcal{H}\)-matrix block type is rank-k matrix, when the top level \(\mathcal{H}\)-matrix is symmetric and the flag <code>enable_build_symmetric_hmat</code> is true, only those matrix blocks belong to the lower triangular part will be computed. Otherwise, the rank-k matrix block will always be computed. ACA+ will be used for building the rank-k matrix.</p>
<p >Build the \(\mathcal{H}\)-matrix block when it belongs to the lower triangular part using ACA+.</p>
<p >Do not build \(\mathcal{H}\)-matrix block belonging to the upper triangular part.</p>
<p >An rank-k matrix cannot belong to the diagonal part.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l06400">6400</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l02483">aca_plus_parallel_sauter_quad_for_vector_entry()</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l19656">HMatrix&lt; spacedim, Number &gt;::get_block_type()</a>, <a class="el" href="hmatrix_8h_source.html#l36011">HMatrix&lt; spacedim, Number &gt;::get_col_index_range()</a>, <a class="el" href="hmatrix_8h_source.html#l19815">HMatrix&lt; spacedim, Number &gt;::get_fullmatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l06702">LAPACKFullMatrixExt&lt; Number &gt;::get_property()</a>, <a class="el" href="hmatrix_8h_source.html#l19772">HMatrix&lt; spacedim, Number &gt;::get_rkmatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l35995">HMatrix&lt; spacedim, Number &gt;::get_row_index_range()</a>, <a class="el" href="hmatrix_8h_source.html#l19052">HMatrix&lt; spacedim, Number &gt;::get_type()</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, and <a class="el" href="dof__to__cell__topology_8h_source.html#l00035">DoFToCellTopology&lt; dim, spacedim &gt;::topology</a>.</p>

</div>
</div>
<a id="a49e8176a7f874f6d1c4ef6f6c92e63ec" name="a49e8176a7f874f6d1c4ef6f6c92e63ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e8176a7f874f6d1c4ef6f6c92e63ec">&#9670;&nbsp;</a></span>fill_hmatrix_leaf_node_with_aca_plus() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fill_hmatrix_leaf_node_with_aca_plus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; *&#160;</td>
          <td class="paramname"><em>leaf_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type&#160;</td>
          <td class="paramname"><em>mass_matrix_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCellWiseScratchDataForMassMatrix.html">CellWiseScratchDataForMassMatrix</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_matrix_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_build_symmetric_hmat</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a single leaf node of the \(\mathcal{H}\)-matrix using ACA+. </p>
<p >In the mean time, the FEM mass matrix multiplied by a factor will be added to the near field matrix block.</p>
<p >If the matrix type is <code>RkMatrixType</code>, the memory for the full or rank-k matrix in the leaf node has been allocated.</p>
<p >For the near field matrix, full matrices will be built whose elements will be obtained from the evaluation of the double integral in Galerkin-BEM. For the far field admissible matrix, rank-k matrices will be built using ACA+.</p>
<dl class="section note">
<dt>Note</dt>
<dd>1. This is used as the work function for parallel \(\mathcal{H}\)-matrix construction using ACA+.<ol type="1">
<li>For near field matrix assembly, the producer-consumer model is not adopted. GPU parallelization with 2D thread grid is distributed over each quadrature point in the X direction and each k3 term in the Y direction.</li>
</ol>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td></td></tr>
    <tr><td class="paramname">spacedim</td><td></td></tr>
    <tr><td class="paramname">KernelFunctionType</td><td></td></tr>
    <tr><td class="paramname">RangeNumberType</td><td></td></tr>
    <tr><td class="paramname">KernelNumberType</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leaf_mat</td><td></td></tr>
    <tr><td class="paramname">aca_config</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">kernel_factor</td><td></td></tr>
    <tr><td class="paramname">mass_matrix_factor</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">bem_values_gpu</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">ky_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">kx_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">ky_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">mappings</td><td></td></tr>
    <tr><td class="paramname">material_id_to_mapping_index</td><td></td></tr>
    <tr><td class="paramname">normal_detector</td><td></td></tr>
    <tr><td class="paramname">mass_matrix_scratch_data</td><td></td></tr>
    <tr><td class="paramname">scratch_data</td><td></td></tr>
    <tr><td class="paramname">scratch_data_gpu</td><td></td></tr>
    <tr><td class="paramname">copy_data</td><td></td></tr>
    <tr><td class="paramname">enable_build_symmetric_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >When the flag <code>enable_build_symmetric_hmat</code> is true and the kernel function is symmetric, try to build a symmetric \(\mathcal{H}\)-matrix. Otherwise, the whole full matrix will be built.</p>
<p >A diagonal \(\mathcal{H}\)-matrix block as well as its associated full matrix should be symmetric.</p>
<p >Only evaluate the diagonal and lower triangular elements in the full matrix.</p>
<p >Do not build \(\mathcal{H}\)-matrix block belonging to the upper triangular part.</p>
<p >When the current \(\mathcal{H}\)-matrix block belongs to the lower triangular part, evaluate all of its elements as usual.</p>
<p >Build the \(\mathcal{H}\)-matrix block when it belongs to the lower triangular part using ACA+.</p>
<p >Do not build \(\mathcal{H}\)-matrix block belonging to the upper triangular part.</p>
<p >An rank-k matrix cannot belong to the diagonal part.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l06817">6817</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l02483">aca_plus_parallel_sauter_quad_for_vector_entry()</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l19656">HMatrix&lt; spacedim, Number &gt;::get_block_type()</a>, <a class="el" href="hmatrix_8h_source.html#l36011">HMatrix&lt; spacedim, Number &gt;::get_col_index_range()</a>, <a class="el" href="hmatrix_8h_source.html#l19815">HMatrix&lt; spacedim, Number &gt;::get_fullmatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l06702">LAPACKFullMatrixExt&lt; Number &gt;::get_property()</a>, <a class="el" href="hmatrix_8h_source.html#l19772">HMatrix&lt; spacedim, Number &gt;::get_rkmatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l35995">HMatrix&lt; spacedim, Number &gt;::get_row_index_range()</a>, <a class="el" href="hmatrix_8h_source.html#l19052">HMatrix&lt; spacedim, Number &gt;::get_type()</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, and <a class="el" href="dof__to__cell__topology_8h_source.html#l00035">DoFToCellTopology&lt; dim, spacedim &gt;::topology</a>.</p>

</div>
</div>
<a id="ad8b4856a4eec9a8556a30c3917bba821" name="ad8b4856a4eec9a8556a30c3917bba821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b4856a4eec9a8556a30c3917bba821">&#9670;&nbsp;</a></span>fill_hmatrix_with_aca_plus_serial() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fill_hmatrix_with_aca_plus_serial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSauterQuadratureRule.html">SauterQuadratureRule</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>sauter_quad_rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_build_symmetric_hmat</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the leaf set of the \(\mathcal{H}\)-matrix using ACA+, where the hierarchical structure of the \(\mathcal{H}\)-matrix has been built with respect to a block cluster tree and the memory for the matrices in the leaf set has been allocated. </p>
<p >For the near field matrices in the leaf set, full matrices will be built whose elements will be obtained from the evaluation of the double integral in Galerkin-BEM. For the far field admissible matrices in the leaf set, rank-k matrices will be built using ACA+.</p>
<dl class="section note">
<dt>Note</dt>
<dd>This version processes each \(\mathcal{H}\)-matrix node in the leaf set one-by-one without partitioning the leaf set using TBB.</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td></td></tr>
    <tr><td class="paramname">spacedim</td><td></td></tr>
    <tr><td class="paramname">KernelFunctionType</td><td></td></tr>
    <tr><td class="paramname">RangeNumberType</td><td></td></tr>
    <tr><td class="paramname">KernelNumberType</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">aca_config</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">kernel_factor</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">sauter_quad_rule</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">ky_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">kx_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">ky_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">mappings</td><td></td></tr>
    <tr><td class="paramname">material_id_to_mapping_index</td><td></td></tr>
    <tr><td class="paramname">normal_detector</td><td></td></tr>
    <tr><td class="paramname">enable_build_symmetric_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Precalculate data tables for shape values at quadrature points.</p>
<dl class="section note">
<dt>Note</dt>
<dd>Precalculate shape function values and their gradient values at each quadrature point. N.B.<ol type="1">
<li>The data tables for shape function values and their gradient values should be calculated for both function space on \(K_x\) and function space on \(K_y\).</li>
<li>Being different from the integral in FEM, the integral in BEM handled by Sauter's quadrature rule has multiple parts of \(k_3\) (except the regular cell neighboring type), each of which should be evaluated at a different set of quadrature points in the unit cell after coordinate transformation from the parametric space. Therefore, a dimension with respect to \(k_3\) term index should be added to the data table compared to the usual FEValues and this brings about the class <code><a class="el" href="classBEMValues.html">BEMValues</a></code>.</li>
</ol>
</dd>
</dl>
<p >Copy the precalculated BEM values to the GPU device.</p>
<p >Define <code><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a></code> and <code><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a></code> which are local to the current working thread. This is mandatory because each current working thread should have its own copy of these data.</p>
<p >Create pair cell wise scratch data and task data on GPU device.</p>
<p >Release BEM values on the GPU device.</p>
<p >Release pair cell wise scratch and copy data on the GPU device.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l07910">7910</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="bem__values_8hcu_source.html#l01895">PairCellWiseScratchData&lt; dim, spacedim, KernelNumberType &gt;::cuda_stream_handle</a>, <a class="el" href="aca__plus_8hcu_source.html#l05981">fill_hmatrix_leaf_node_with_aca_plus()</a>, <a class="el" href="bem__values_8hcu_source.html#l00794">BEMValues&lt; dim, spacedim, RangeNumberType &gt;::fill_shape_function_value_tables()</a>, and <a class="el" href="hmatrix_8h_source.html#l35948">HMatrix&lt; spacedim, Number &gt;::get_leaf_set()</a>.</p>

</div>
</div>
<a id="a75d38137c866826ac06288f167de4ec2" name="a75d38137c866826ac06288f167de4ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d38137c866826ac06288f167de4ec2">&#9670;&nbsp;</a></span>fill_hmatrix_with_aca_plus_serial() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fill_hmatrix_with_aca_plus_serial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_vmult_weq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>stabilization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSauterQuadratureRule.html">SauterQuadratureRule</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>sauter_quad_rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_build_symmetric_hmat</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the leaf set of the \(\mathcal{H}\)-matrix using ACA+, where the hierarchical structure of the \(\mathcal{H}\)-matrix has been built with respect to a block cluster tree and the memory for the matrices in the leaf set has been allocated. </p>
<p >For the near field matrices in the leaf set, full matrices will be built whose elements will be obtained from the evaluation of the double integral in Galerkin-BEM. For the far field admissible matrices in the leaf set, rank-k matrices will be built using ACA+.</p>
<dl class="section note">
<dt>Note</dt>
<dd><ol type="1">
<li>This version processes each \(\mathcal{H}\)-matrix node in the leaf set one-by-one without partitioning the leaf set using TBB.</li>
<li><p class="startli">This version is especially for assembling the regularized hyper-singular matrix appended with the stabilization term. The stabilization term in the variational equation is </p><p class="formulaDsp">
\[
  \alpha\langle \gamma_0^{\rm ext}u, \omega_{\rm eq} \rangle \cdot \langle
v, \omega_{\rm eq} \rangle_{\Gamma}. \]
</p>
<p class="startli">The stabilization term in the discretized form is </p><p class="formulaDsp">
\[
  \alpha M [\omega_{\rm eq}] \cdot \left[ M [\omega_{\rm eq}] \right]^{\rm
T} \cdot [\gamma_0^{\rm ext}u], \]
</p>
<p> which is actually an outer-product representation. The argument <code>mass_vmult_weq</code> passed to this function is just the vector \(M [\omega_{\rm eq}]\).</p>
</li>
</ol>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td></td></tr>
    <tr><td class="paramname">spacedim</td><td></td></tr>
    <tr><td class="paramname">KernelFunctionType</td><td></td></tr>
    <tr><td class="paramname">RangeNumberType</td><td></td></tr>
    <tr><td class="paramname">KernelNumberType</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">aca_config</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">kernel_factor</td><td></td></tr>
    <tr><td class="paramname">mass_vmult_weq</td><td></td></tr>
    <tr><td class="paramname">stabilization_factor</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">sauter_quad_rule</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">ky_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">kx_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">ky_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">mappings</td><td></td></tr>
    <tr><td class="paramname">material_id_to_mapping_index</td><td></td></tr>
    <tr><td class="paramname">normal_detector</td><td></td></tr>
    <tr><td class="paramname">enable_build_symmetric_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Precalculate data tables for shape values at quadrature points.</p>
<dl class="section note">
<dt>Note</dt>
<dd>Precalculate shape function values and their gradient values at each quadrature point. N.B.<ol type="1">
<li>The data tables for shape function values and their gradient values should be calculated for both function space on \(K_x\) and function space on \(K_y\).</li>
<li>Being different from the integral in FEM, the integral in BEM handled by Sauter's quadrature rule has multiple parts of \(k_3\) (except the regular cell neighboring type), each of which should be evaluated at a different set of quadrature points in the unit cell after coordinate transformation from the parametric space. Therefore, a dimension with respect to \(k_3\) term index should be added to the data table compared to the usual FEValues and this brings about the class <code><a class="el" href="classBEMValues.html">BEMValues</a></code>.</li>
</ol>
</dd>
</dl>
<p >Copy the precalculated BEM values to the GPU device.</p>
<p >Define <code><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a></code> and <code><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a></code> which are local to the current working thread. This is mandatory because each current working thread should have its own copy of these data.</p>
<p >Create pair cell wise scratch data and task data on GPU device.</p>
<p >Release BEM values on the GPU device.</p>
<p >Release pair cell wise scratch and copy data.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l08093">8093</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="bem__values_8hcu_source.html#l01895">PairCellWiseScratchData&lt; dim, spacedim, KernelNumberType &gt;::cuda_stream_handle</a>, <a class="el" href="aca__plus_8hcu_source.html#l05981">fill_hmatrix_leaf_node_with_aca_plus()</a>, <a class="el" href="bem__values_8hcu_source.html#l00794">BEMValues&lt; dim, spacedim, RangeNumberType &gt;::fill_shape_function_value_tables()</a>, and <a class="el" href="hmatrix_8h_source.html#l35948">HMatrix&lt; spacedim, Number &gt;::get_leaf_set()</a>.</p>

</div>
</div>
<a id="a05276d9c7b897d5faf8ae7105e840459" name="a05276d9c7b897d5faf8ae7105e840459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05276d9c7b897d5faf8ae7105e840459">&#9670;&nbsp;</a></span>fill_hmatrix_with_aca_plus_serial() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fill_hmatrix_with_aca_plus_serial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type&#160;</td>
          <td class="paramname"><em>mass_matrix_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSauterQuadratureRule.html">SauterQuadratureRule</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>sauter_quad_rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QGauss&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_matrix_quadrature_formula</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_build_symmetric_hmat</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the leaf set of the \(\mathcal{H}\)-matrix using ACA+, where the hierarchical structure of the \(\mathcal{H}\)-matrix has been built with respect to a block cluster tree and the memory for the matrices in the leaf set has been allocated. </p>
<p >For the near field matrices in the leaf set, full matrices will be built whose elements will be obtained from the evaluation of the double integral in Galerkin-BEM. For the far field admissible matrices in the leaf set, rank-k matrices will be built using ACA+.</p>
<dl class="section note">
<dt>Note</dt>
<dd>1. This version processes each \(\mathcal{H}\)-matrix node in the leaf set one-by-one without partitioning the leaf set using TBB.<ol type="1">
<li>The mass matrix scaled with a factor is appended to the near field leaf node.</li>
</ol>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td></td></tr>
    <tr><td class="paramname">spacedim</td><td></td></tr>
    <tr><td class="paramname">KernelFunctionType</td><td></td></tr>
    <tr><td class="paramname">RangeNumberType</td><td></td></tr>
    <tr><td class="paramname">KernelNumberType</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">aca_config</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">kernel_factor</td><td></td></tr>
    <tr><td class="paramname">mass_matrix_factor</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">sauter_quad_rule</td><td></td></tr>
    <tr><td class="paramname">mass_matrix_quadrature_formula</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">ky_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">kx_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">ky_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">mappings</td><td></td></tr>
    <tr><td class="paramname">material_id_to_mapping_index</td><td></td></tr>
    <tr><td class="paramname">normal_detector</td><td></td></tr>
    <tr><td class="paramname">enable_build_symmetric_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Precalculate data tables for shape values at quadrature points.</p>
<dl class="section note">
<dt>Note</dt>
<dd>Precalculate shape function values and their gradient values at each quadrature point. N.B.<ol type="1">
<li>The data tables for shape function values and their gradient values should be calculated for both function space on \(K_x\) and function space on \(K_y\).</li>
<li>Being different from the integral in FEM, the integral in BEM handled by Sauter's quadrature rule has multiple parts of \(k_3\) (except the regular cell neighboring type), each of which should be evaluated at a different set of quadrature points in the unit cell after coordinate transformation from the parametric space. Therefore, a dimension with respect to \(k_3\) term index should be added to the data table compared to the usual FEValues and this brings about the class <code><a class="el" href="classBEMValues.html">BEMValues</a></code>.</li>
</ol>
</dd>
</dl>
<p >Copy the precalculated BEM values to the GPU device.</p>
<p >Define <code><a class="el" href="structCellWiseScratchDataForMassMatrix.html">CellWiseScratchDataForMassMatrix</a></code> which is local to current working thread.</p>
<p >Define <code><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a></code> and <code><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a></code> which are local to the current working thread. This is mandatory because each current working thread should have its own copy of these data.</p>
<p >Create pair cell wise scratch data and task data on GPU device.</p>
<p >Release BEM values on the GPU device.</p>
<p >Release pair cell wise scratch and copy data.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l08267">8267</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="bem__values_8hcu_source.html#l01895">PairCellWiseScratchData&lt; dim, spacedim, KernelNumberType &gt;::cuda_stream_handle</a>, <a class="el" href="aca__plus_8hcu_source.html#l05981">fill_hmatrix_leaf_node_with_aca_plus()</a>, <a class="el" href="bem__values_8hcu_source.html#l00794">BEMValues&lt; dim, spacedim, RangeNumberType &gt;::fill_shape_function_value_tables()</a>, and <a class="el" href="hmatrix_8h_source.html#l35948">HMatrix&lt; spacedim, Number &gt;::get_leaf_set()</a>.</p>

</div>
</div>
<a id="a5f5caeec8d5a4b2c765362954dfdf971" name="a5f5caeec8d5a4b2c765362954dfdf971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5caeec8d5a4b2c765362954dfdf971">&#9670;&nbsp;</a></span>fill_hmatrix_with_aca_plus_smp() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fill_hmatrix_with_aca_plus_smp </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>thread_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSauterQuadratureRule.html">SauterQuadratureRule</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>sauter_quad_rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_build_symmetric_hmat</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the leaf set of the \(\mathcal{H}\)-matrix using ACA+, where the hierarchical structure of the \(\mathcal{H}\)-matrix has been built with respect to a block cluster tree and the memory for the matrices in the leaf set has been allocated. </p>
<p >For the near field matrices in the leaf set, full matrices will be built whose elements will be obtained from the evaluation of the double integral in Galerkin-BEM. For the far field admissible matrices in the leaf set, rank-k matrices will be built using ACA+.</p>
<dl class="section note">
<dt>Note</dt>
<dd><ol type="1">
<li>For the near field leaf set, GPU parallelization is realized in a producer-consumer model. GPU 1D thread grid is distributed over each Sauter quadrature task in the ring buffer.</li>
<li>For the far field leaf set, GPU 2D thread grid is distributed over each Sauter quadrature task in the X direction and each quadrature point in the Y direction. The quadrature tasks collected in the buffer are used to build a row or column vector.</li>
</ol>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td></td></tr>
    <tr><td class="paramname">spacedim</td><td></td></tr>
    <tr><td class="paramname">KernelFunctionType</td><td></td></tr>
    <tr><td class="paramname">RangeNumberType</td><td></td></tr>
    <tr><td class="paramname">KernelNumberType</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_num</td><td></td></tr>
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">aca_config</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">kernel_factor</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">sauter_quad_rule</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">ky_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">kx_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">ky_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">mappings</td><td></td></tr>
    <tr><td class="paramname">material_id_to_mapping_index</td><td></td></tr>
    <tr><td class="paramname">normal_detector</td><td></td></tr>
    <tr><td class="paramname">enable_build_symmetric_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Precalculate shape function values and their gradient values at each quadrature point.</p>
<ol type="1">
<li>The data tables for shape function values and their gradient values should be calculated for both function space on \(K_x\) and function space on \(K_y\).</li>
<li>Being different from the integral in FEM, the integral in BEM handled by Sauter's quadrature rule has multiple parts of \(k_3\) (except the regular cell neighboring type), each of which should be evaluated at a different set of quadrature points in the unit cell after coordinate transformation from the parametric space. Therefore, a dimension with respect to \(k_3\) term index should be added to the data table compared to the usual FEValues and this brings about the class <code><a class="el" href="classBEMValues.html">BEMValues</a></code>.}</li>
</ol>
<p >Copy the precalculated BEM values to the GPU device.</p>
<p >Release BEM values on the GPU device.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l08455">8455</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l34835">HMatrix&lt; spacedim, Number &gt;::compute_near_field_leaf_set_assembly_task_costs()</a>, <a class="el" href="bem__values_8hcu_source.html#l00794">BEMValues&lt; dim, spacedim, RangeNumberType &gt;::fill_shape_function_value_tables()</a>, and <a class="el" href="debug__tools_8h.html#abc4b513edfba014605e6259429800db3">print_wall_time()</a>.</p>

<p class="reference">Referenced by <a class="el" href="laplace__bem_8priv_8hcu_source.html#l01250">LaplaceBEM&lt; dim, spacedim, RangeNumberType, KernelNumberType &gt;::Priv::compute_stabilization_terms_for_D1_hmat()</a>.</p>

</div>
</div>
<a id="a1cd2dbd4ad6df605470a2bd027719909" name="a1cd2dbd4ad6df605470a2bd027719909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd2dbd4ad6df605470a2bd027719909">&#9670;&nbsp;</a></span>fill_hmatrix_with_aca_plus_smp() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fill_hmatrix_with_aca_plus_smp </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>thread_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_vmult_weq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>stabilization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSauterQuadratureRule.html">SauterQuadratureRule</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>sauter_quad_rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_build_symmetric_hmat</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the leaf set of the \(\mathcal{H}\)-matrix using ACA+, where the hierarchical structure of the \(\mathcal{H}\)-matrix has been built with respect to a block cluster tree and the memory for the matrices in the leaf set has been allocated. </p>
<p >For the near field matrices in the leaf set, full matrices will be built whose elements will be obtained from the evaluation of the double integral in Galerkin-BEM. For the far field admissible matrices in the leaf set, rank-k matrices will be built using ACA+.</p>
<p >This version is used for assembling the regularized hyper-singular matrix with the stabilization term.</p>
<dl class="section note">
<dt>Note</dt>
<dd><ol type="1">
<li>For the near field leaf set, GPU parallelization is realized in a producer-consumer model. GPU 1D thread grid is distributed over each Sauter quadrature task in the ring buffer.</li>
<li>For the far field leaf set, GPU 2D thread grid is distributed over each Sauter quadrature task in the X direction and each quadrature point in the Y direction. The quadrature tasks collected in the buffer are used to build a row or column vector.</li>
</ol>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td></td></tr>
    <tr><td class="paramname">spacedim</td><td></td></tr>
    <tr><td class="paramname">KernelFunctionType</td><td></td></tr>
    <tr><td class="paramname">RangeNumberType</td><td></td></tr>
    <tr><td class="paramname">KernelNumberType</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_num</td><td></td></tr>
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">aca_config</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">kernel_factor</td><td></td></tr>
    <tr><td class="paramname">mass_vmult_weq</td><td></td></tr>
    <tr><td class="paramname">stabilization_factor</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">sauter_quad_rule</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">ky_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">kx_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">ky_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">mappings</td><td></td></tr>
    <tr><td class="paramname">material_id_to_mapping_index</td><td></td></tr>
    <tr><td class="paramname">normal_detector</td><td></td></tr>
    <tr><td class="paramname">enable_build_symmetric_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Precalculate data tables for shape values at quadrature points.</p>
<dl class="section note">
<dt>Note</dt>
<dd>Precalculate shape function values and their gradient values at each quadrature point. N.B.<ol type="1">
<li>The data tables for shape function values and their gradient values should be calculated for both function space on \(K_x\) and function space on \(K_y\).</li>
<li>Being different from the integral in FEM, the integral in BEM handled by Sauter's quadrature rule has multiple parts of \(k_3\) (except the regular cell neighboring type), each of which should be evaluated at a different set of quadrature points in the unit cell after coordinate transformation from the parametric space. Therefore, a dimension with respect to \(k_3\) term index should be added to the data table compared to the usual FEValues and this brings about the class <code><a class="el" href="classBEMValues.html">BEMValues</a></code>.</li>
</ol>
</dd>
</dl>
<p >Copy the precalculated BEM values to the GPU device.</p>
<p >Release BEM values on the GPU device.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l08871">8871</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l34835">HMatrix&lt; spacedim, Number &gt;::compute_near_field_leaf_set_assembly_task_costs()</a>, <a class="el" href="bem__values_8hcu_source.html#l00794">BEMValues&lt; dim, spacedim, RangeNumberType &gt;::fill_shape_function_value_tables()</a>, and <a class="el" href="debug__tools_8h.html#abc4b513edfba014605e6259429800db3">print_wall_time()</a>.</p>

</div>
</div>
<a id="a26038651b45700c103ce038766e59775" name="a26038651b45700c103ce038766e59775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26038651b45700c103ce038766e59775">&#9670;&nbsp;</a></span>fill_hmatrix_with_aca_plus_smp() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fill_hmatrix_with_aca_plus_smp </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>thread_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structACAConfig.html">ACAConfig</a>&lt; typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>aca_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type&#160;</td>
          <td class="paramname"><em>mass_matrix_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFToCellTopology.html">DoFToCellTopology</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSauterQuadratureRule.html">SauterQuadratureRule</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>sauter_quad_rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QGauss&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_matrix_quadrature_formula</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandler&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_build_symmetric_hmat</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the leaf set of the \(\mathcal{H}\)-matrix using ACA+, where the hierarchical structure of the \(\mathcal{H}\)-matrix has been built with respect to a block cluster tree and the memory for the matrices in the leaf set has been allocated. </p>
<p >In the mean time, the FEM mass matrix multiplied by a factor will be added to the near field matrix block.</p>
<p >For the near field matrices in the leaf set, full matrices will be built whose elements will be obtained from the evaluation of the double integral in Galerkin-BEM. For the far field admissible matrices in the leaf set, rank-k matrices will be built using ACA+.</p>
<dl class="section note">
<dt>Note</dt>
<dd><ol type="1">
<li>For the near field leaf set, GPU parallelization is realized in a producer-consumer model. GPU 1D thread grid is distributed over each Sauter quadrature task in the ring buffer.</li>
<li>For the far field leaf set, GPU 2D thread grid is distributed over each Sauter quadrature task in the X direction and each quadrature point in the Y direction. The quadrature tasks collected in the buffer are used to build a row or column vector.</li>
</ol>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td></td></tr>
    <tr><td class="paramname">spacedim</td><td></td></tr>
    <tr><td class="paramname">KernelFunctionType</td><td></td></tr>
    <tr><td class="paramname">RangeNumberType</td><td></td></tr>
    <tr><td class="paramname">KernelNumberType</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_num</td><td></td></tr>
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">aca_config</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">kernel_factor</td><td></td></tr>
    <tr><td class="paramname">mass_matrix_factor</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">sauter_quad_rule</td><td></td></tr>
    <tr><td class="paramname">mass_matrix_quadrature_formula</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">ky_map_from_local_to_full_dof_indices</td><td></td></tr>
    <tr><td class="paramname">kx_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">ky_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">mappings</td><td></td></tr>
    <tr><td class="paramname">material_id_to_mapping_index</td><td></td></tr>
    <tr><td class="paramname">normal_detector</td><td></td></tr>
    <tr><td class="paramname">enable_build_symmetric_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Precalculate data tables for shape values at quadrature points.</p>
<dl class="section note">
<dt>Note</dt>
<dd>Precalculate shape function values and their gradient values at each quadrature point. N.B.<ol type="1">
<li>The data tables for shape function values and their gradient values should be calculated for both function space on \(K_x\) and function space on \(K_y\).</li>
<li>Being different from the integral in FEM, the integral in BEM handled by Sauter's quadrature rule has multiple parts of \(k_3\) (except the regular cell neighboring type), each of which should be evaluated at a different set of quadrature points in the unit cell after coordinate transformation from the parametric space. Therefore, a dimension with respect to \(k_3\) term index should be added to the data table compared to the usual FEValues and this brings about the class <code><a class="el" href="classBEMValues.html">BEMValues</a></code>.</li>
</ol>
</dd>
</dl>
<p >Copy the precalculated BEM values to the GPU device.</p>
<p >Release BEM values on the GPU device.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l09318">9318</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l34835">HMatrix&lt; spacedim, Number &gt;::compute_near_field_leaf_set_assembly_task_costs()</a>, <a class="el" href="bem__values_8hcu_source.html#l00794">BEMValues&lt; dim, spacedim, RangeNumberType &gt;::fill_shape_function_value_tables()</a>, and <a class="el" href="debug__tools_8h.html#abc4b513edfba014605e6259429800db3">print_wall_time()</a>.</p>

</div>
</div>
<a id="a23d6cec6df4fb9da5a4ec004108daffa" name="a23d6cec6df4fb9da5a4ec004108daffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d6cec6df4fb9da5a4ec004108daffa">&#9670;&nbsp;</a></span>generate_random_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> generate_random_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Generate a random non-negative integer in the specified range \([a,b]\) using the global random number engine <code>rand_engine</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="aca__plus_8cu_source.html#l00043">43</a> of file <a class="el" href="aca__plus_8cu_source.html">aca_plus.cu</a>.</p>

<p class="reference">Referenced by <a class="el" href="aca__plus_8hcu_source.html#l01733">random_select_ref_column()</a>, and <a class="el" href="aca__plus_8hcu_source.html#l00981">random_select_ref_row()</a>.</p>

</div>
</div>
<a id="ac2824666c5af180396e5995de2bd2681" name="ac2824666c5af180396e5995de2bd2681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2824666c5af180396e5995de2bd2681">&#9670;&nbsp;</a></span>random_select_ref_column() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> random_select_ref_column </td>
          <td>(</td>
          <td class="paramtype">HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; RangeNumberType &gt;, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>task_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>remaining_col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>current_ref_col_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>pass_the_end_ref_col_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The array index used to access the <code>std::forward_list</code> <code>remaining_col_indices</code>.</p>
<p >The reference column index to be selected for the next ACA step.</p>
<p >The column DoF index corresponding to the selected reference column index for the next ACA step.</p>
<p >Get the <code>next_ref_col_index'th</code> column from the kernel evaluation.</p>
<p >When the extracted column vector is zero-valued, remove the corresponding column index from the <code>remaining_col_indices</code> and continue another try.</p>
<p >When the extracted column vector is not zero-valued, it is a valid choice. Hence, return the selected column index.</p>
<p >If there is only one column index left, there is no reference column can be selected. Then return the invalid reference column index.</p>
<p >Because the selected column for the next step is the same as the current reference column, try another valid selection.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l02065">2065</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l00557">assemble_kernel_column()</a>, <a class="el" href="generic__functors_8h_source.html#l00192">erase_at()</a>, <a class="el" href="aca__plus_8cu_source.html#l00043">generate_random_index()</a>, <a class="el" href="generic__functors_8h_source.html#l00142">size()</a>, and <a class="el" href="generic__functors_8h_source.html#l00157">value_at()</a>.</p>

</div>
</div>
<a id="ad9d666eae14e96a703762d178d0c2ead" name="ad9d666eae14e96a703762d178d0c2ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d666eae14e96a703762d178d0c2ead">&#9670;&nbsp;</a></span>random_select_ref_column() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> random_select_ref_column </td>
          <td>(</td>
          <td class="paramtype">HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; RangeNumberType &gt;, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>task_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_vmult_weq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>stabilization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>remaining_col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>current_ref_col_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>pass_the_end_ref_col_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The array index used to access the <code>std::forward_list</code> <code>remaining_col_indices</code>.</p>
<p >The reference column index to be selected for the next ACA step.</p>
<p >The column DoF index corresponding to the selected reference column index for the next ACA step.</p>
<p >Get the <code>next_ref_col_index'th</code> column from the kernel evaluation.</p>
<p >When the extracted column vector is zero-valued, remove the corresponding column index from the <code>remaining_col_indices</code> and continue another try.</p>
<p >When the extracted column vector is not zero-valued, it is a valid choice. Hence, return the selected column index.</p>
<p >If there is only one column index left, there is no reference column can be selected. Then return the invalid reference column index.</p>
<p >Because the selected column for the next step is the same as the current reference column, try another valid selection.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l02213">2213</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l00557">assemble_kernel_column()</a>, <a class="el" href="generic__functors_8h_source.html#l00192">erase_at()</a>, <a class="el" href="aca__plus_8cu_source.html#l00043">generate_random_index()</a>, <a class="el" href="generic__functors_8h_source.html#l00142">size()</a>, and <a class="el" href="generic__functors_8h_source.html#l00157">value_at()</a>.</p>

</div>
</div>
<a id="af7dd925ab4738ea84e8748ff1aa6434b" name="af7dd925ab4738ea84e8748ff1aa6434b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7dd925ab4738ea84e8748ff1aa6434b">&#9670;&nbsp;</a></span>random_select_ref_column() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> random_select_ref_column </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>remaining_col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>current_ref_col_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>pass_the_end_ref_col_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Randomly select a reference column index from the remaining column indices for the next ACA step.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The data type for DoF index is <code>types::global_dof_index</code>, while the data type for matrix row or column index is <code>size_type</code>, which is the unsigned version of <code>blas::int</code>.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col_vector</td><td>The selected reference column vector, the memory of which should be preallocated in order to reduce the number of times for memory allocation and releasing. </td></tr>
    <tr><td class="paramname">scratch</td><td></td></tr>
    <tr><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">remaining_col_indices</td><td>Remaining column indices to be checked and selected from, which are stored in a <code>std::forward_list</code>. </td></tr>
    <tr><td class="paramname">current_ref_col_index</td><td>The current reference column index </td></tr>
    <tr><td class="paramname">pass_the_end_ref_col_index</td><td>When this function cannot select a new reference column, return this invalid index. </td></tr>
    <tr><td class="paramname">row_dof_indices</td><td>The list of DoF indices corresponding to the matrix rows </td></tr>
    <tr><td class="paramname">col_dof_indices</td><td>The list of DoF indices corresponding to the matrix columns </td></tr>
    <tr><td class="paramname">dof_to_cell_topo</td><td>DoF-to-cell topology </td></tr>
    <tr><td class="paramname">bem_values</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_mapping</td><td></td></tr>
    <tr><td class="paramname">ky_mapping</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The selected reference column index </dd></dl>
<p >The array index used to access the <code>std::forward_list</code> <code>remaining_col_indices</code>.</p>
<p >The reference column index to be selected for the next ACA step.</p>
<p >The column DoF index corresponding to the selected reference column index for the next ACA step.</p>
<p >Get the <code>next_ref_col_index'th</code> column from the kernel evaluation.</p>
<p >When the extracted column vector is zero-valued, remove the corresponding column index from the <code>remaining_col_indices</code> and continue another try.</p>
<p >When the extracted column vector is not zero-valued, it is a valid choice. Hence, return the selected column index.</p>
<p >If there is only one column index left, there is no reference column can be selected. Then return the invalid reference column index.</p>
<p >Because the selected column for the next step is the same as the current reference column, try another valid selection.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l01733">1733</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l00557">assemble_kernel_column()</a>, <a class="el" href="generic__functors_8h_source.html#l00192">erase_at()</a>, <a class="el" href="aca__plus_8cu_source.html#l00043">generate_random_index()</a>, <a class="el" href="generic__functors_8h_source.html#l00142">size()</a>, and <a class="el" href="generic__functors_8h_source.html#l00157">value_at()</a>.</p>

</div>
</div>
<a id="a5ca0e491f1ae37e8c62ae418d117ba69" name="a5ca0e491f1ae37e8c62ae418d117ba69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca0e491f1ae37e8c62ae418d117ba69">&#9670;&nbsp;</a></span>random_select_ref_column() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> random_select_ref_column </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_vmult_weq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>stabilization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>remaining_col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>current_ref_col_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>pass_the_end_ref_col_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Randomly select a reference column index from the remaining column indices for the next ACA step.</p>
<dl class="section note">
<dt>Note</dt>
<dd>1. The data type for DoF index is <code>types::global_dof_index</code>, while the data type for matrix row or column index is <code>size_type</code>, which is the unsigned version of <code>blas::int</code>.<ol type="1">
<li>This version is especially for assembling the regularized hyper-singular matrix with the stabilization term.</li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col_vector</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">kernel_factor</td><td></td></tr>
    <tr><td class="paramname">mass_vmult_weq</td><td></td></tr>
    <tr><td class="paramname">stabilization_factor</td><td></td></tr>
    <tr><td class="paramname">remaining_col_indices</td><td></td></tr>
    <tr><td class="paramname">current_ref_col_index</td><td></td></tr>
    <tr><td class="paramname">pass_the_end_ref_col_index</td><td>When this function cannot select a new reference column, return this invalid index. </td></tr>
    <tr><td class="paramname">row_dof_indices</td><td></td></tr>
    <tr><td class="paramname">col_dof_indices</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">bem_values</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">ky_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">kx_mapping</td><td></td></tr>
    <tr><td class="paramname">ky_mapping</td><td></td></tr>
    <tr><td class="paramname">scratch_data</td><td></td></tr>
    <tr><td class="paramname">copy_data</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >The array index used to access the <code>std::forward_list</code> <code>remaining_col_indices</code>.</p>
<p >The reference column index to be selected for the next ACA step.</p>
<p >The column DoF index corresponding to the selected reference column index for the next ACA step.</p>
<p >Get the <code>next_ref_col_index'th</code> column from the kernel evaluation.</p>
<p >When the extracted column vector is zero-valued, remove the corresponding column index from the <code>remaining_col_indices</code> and continue another try.</p>
<p >When the extracted column vector is not zero-valued, it is a valid choice. Hence, return the selected column index.</p>
<p >If there is only one column index left, there is no reference column can be selected. Then return the invalid reference column index.</p>
<p >Because the selected column for the next step is the same as the current reference column, try another valid selection.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l01914">1914</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l00557">assemble_kernel_column()</a>, <a class="el" href="generic__functors_8h_source.html#l00192">erase_at()</a>, <a class="el" href="aca__plus_8cu_source.html#l00043">generate_random_index()</a>, <a class="el" href="generic__functors_8h_source.html#l00142">size()</a>, and <a class="el" href="generic__functors_8h_source.html#l00157">value_at()</a>.</p>

</div>
</div>
<a id="a655fa5a299f18782100dec66c31d6fdd" name="a655fa5a299f18782100dec66c31d6fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655fa5a299f18782100dec66c31d6fdd">&#9670;&nbsp;</a></span>random_select_ref_column() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> random_select_ref_column </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>remaining_col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>current_ref_col_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>pass_the_end_ref_col_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >For debugging purpose: randomly select a reference column index from the remaining column indices for the next ACA step.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col_vector</td><td>The extracted column vector, the memory of which should be preallocated </td></tr>
    <tr><td class="paramname">A</td><td>The full matrix for the current block, the rows of which are extracted </td></tr>
    <tr><td class="paramname">remaining_col_indices</td><td></td></tr>
    <tr><td class="paramname">current_ref_col_index</td><td></td></tr>
    <tr><td class="paramname">pass_the_end_ref_col_index</td><td>When this function cannot select a new reference column, return this invalid index. </td></tr>
    <tr><td class="paramname">row_dof_indices</td><td></td></tr>
    <tr><td class="paramname">col_dof_indices</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >The array index used to access the <code>std::forward_list</code> <code>remaining_col_indices</code>.</p>
<p >The reference column index to be selected for the next ACA step.</p>
<p >When the extracted column vector is zero-valued, remove the corresponding column index from the <code>remaining_col_indices</code> and continue another try.</p>
<p >When the extracted column vector is not zero-valued, it is a valid choice. Hence, return the selected column index.</p>
<p >If there is only one column index left, there is no reference column can be selected. Then return the invalid reference column index.</p>
<p >Because the selected column for the next step is the same as the current reference column, try another valid selection.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l02375">2375</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="generic__functors_8h_source.html#l00192">erase_at()</a>, <a class="el" href="aca__plus_8cu_source.html#l00043">generate_random_index()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l02958">LAPACKFullMatrixExt&lt; Number &gt;::get_column()</a>, <a class="el" href="generic__functors_8h_source.html#l00142">size()</a>, and <a class="el" href="generic__functors_8h_source.html#l00157">value_at()</a>.</p>

</div>
</div>
<a id="a8650be3ae227c4631a4d09caaafb82e3" name="a8650be3ae227c4631a4d09caaafb82e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8650be3ae227c4631a4d09caaafb82e3">&#9670;&nbsp;</a></span>random_select_ref_row() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> random_select_ref_row </td>
          <td>(</td>
          <td class="paramtype">HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; RangeNumberType &gt;, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>task_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_vmult_weq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>stabilization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>remaining_row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>current_ref_row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>pass_the_end_ref_row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The array index used to access the <code>std::forward_list</code> <code>remaining_row_indices</code>.</p>
<p >The reference row index to be selected for the next ACA step.</p>
<p >The row DoF index corresponding to the selected reference row index for the next ACA step.</p>
<p >Get the <code>next_ref_row_index'th</code> row from the kernel evaluation.</p>
<p >When the extracted row vector is zero-valued, remove the corresponding row index from the <code>remaining_row_indices</code> and continue another try.</p>
<p >When the extracted row vector is not zero-valued, it is a valid choice. Hence, return the selected row index.</p>
<p >If there is only one row index left, there is no reference row can be selected. Then return the invalid reference row index.</p>
<p >Because the selected row for the next step is the same as the current reference row, try another valid selection.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l01459">1459</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l00125">assemble_kernel_row()</a>, <a class="el" href="generic__functors_8h_source.html#l00192">erase_at()</a>, <a class="el" href="aca__plus_8cu_source.html#l00043">generate_random_index()</a>, <a class="el" href="generic__functors_8h_source.html#l00142">size()</a>, and <a class="el" href="generic__functors_8h_source.html#l00157">value_at()</a>.</p>

</div>
</div>
<a id="a6a80f5c5de151ac045d8037e28c9a6b1" name="a6a80f5c5de151ac045d8037e28c9a6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a80f5c5de151ac045d8037e28c9a6b1">&#9670;&nbsp;</a></span>random_select_ref_row() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> random_select_ref_row </td>
          <td>(</td>
          <td class="paramtype">HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; RangeNumberType &gt;, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>task_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>remaining_row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>current_ref_row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>pass_the_end_ref_row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The array index used to access the <code>std::forward_list</code> <code>remaining_row_indices</code>.</p>
<p >The reference row index to be selected for the next ACA step.</p>
<p >The row DoF index corresponding to the selected reference row index for the next ACA step.</p>
<p >Get the <code>next_ref_row_index'th</code> row from the kernel evaluation.</p>
<p >When the extracted row vector is zero-valued, remove the corresponding row index from the <code>remaining_row_indices</code> and continue another try.</p>
<p >When the extracted row vector is not zero-valued, it is a valid choice. Hence, return the selected row index.</p>
<p >If there is only one row index left, there is no reference row can be selected. Then return the invalid reference row index.</p>
<p >Because the selected row for the next step is the same as the current reference row, try another valid selection.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l01312">1312</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l00125">assemble_kernel_row()</a>, <a class="el" href="generic__functors_8h_source.html#l00192">erase_at()</a>, <a class="el" href="aca__plus_8cu_source.html#l00043">generate_random_index()</a>, <a class="el" href="generic__functors_8h_source.html#l00142">size()</a>, and <a class="el" href="generic__functors_8h_source.html#l00157">value_at()</a>.</p>

</div>
</div>
<a id="ad46d46094f18eae92aa37bd3dfea47ac" name="ad46d46094f18eae92aa37bd3dfea47ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46d46094f18eae92aa37bd3dfea47ac">&#9670;&nbsp;</a></span>random_select_ref_row() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> random_select_ref_row </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_vmult_weq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>stabilization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>remaining_row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>current_ref_row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>pass_the_end_ref_row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Randomly select a reference row index from the remaining row indices for the next ACA step.</p>
<dl class="section note">
<dt>Note</dt>
<dd>1. The data type for DoF index is <code>types::global_dof_index</code>, while the data type for matrix row or column index is <code>size_type</code>, which is the unsigned version of <code>blas::int</code>.<ol type="1">
<li>This version is especially for assembling the regularized hyper-singular matrix with the stabilization term.</li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_vector</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">kernel_factor</td><td></td></tr>
    <tr><td class="paramname">mass_vmult_weq</td><td></td></tr>
    <tr><td class="paramname">stabilization_factor</td><td></td></tr>
    <tr><td class="paramname">remaining_row_indices</td><td></td></tr>
    <tr><td class="paramname">current_ref_row_index</td><td></td></tr>
    <tr><td class="paramname">pass_the_end_ref_row_index</td><td>When this function cannot select a new reference row, return this invalid index. </td></tr>
    <tr><td class="paramname">row_dof_indices</td><td></td></tr>
    <tr><td class="paramname">col_dof_indices</td><td></td></tr>
    <tr><td class="paramname">kx_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">ky_dof_to_cell_topo</td><td></td></tr>
    <tr><td class="paramname">bem_values</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">ky_dof_i2e_numbering</td><td></td></tr>
    <tr><td class="paramname">kx_mapping</td><td></td></tr>
    <tr><td class="paramname">ky_mapping</td><td></td></tr>
    <tr><td class="paramname">scratch_data</td><td></td></tr>
    <tr><td class="paramname">copy_data</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The selected reference row index with respect to the matrix block, i.e. matrix block index. </dd></dl>
<p >The array index used to access the <code>std::forward_list</code> <code>remaining_row_indices</code>.</p>
<p >The reference row index to be selected for the next ACA step.</p>
<p >The row DoF index corresponding to the selected reference row index for the next ACA step.</p>
<p >Get the <code>next_ref_row_index'th</code> row from the kernel evaluation.</p>
<p >When the extracted row vector is zero-valued, remove the corresponding row index from the <code>remaining_row_indices</code> and continue another try.</p>
<p >When the extracted row vector is not zero-valued, it is a valid choice. Hence, return the selected row index.</p>
<p >If there is only one row index left, there is no reference row can be selected. Then return the invalid reference row index.</p>
<p >Because the selected row for the next step is the same as the current reference row, try another valid selection.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l01162">1162</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l00125">assemble_kernel_row()</a>, <a class="el" href="generic__functors_8h_source.html#l00192">erase_at()</a>, <a class="el" href="aca__plus_8cu_source.html#l00043">generate_random_index()</a>, <a class="el" href="generic__functors_8h_source.html#l00142">size()</a>, and <a class="el" href="generic__functors_8h_source.html#l00157">value_at()</a>.</p>

</div>
</div>
<a id="a8d0f3a023ab06d460cfdff2e98d07851" name="a8d0f3a023ab06d460cfdff2e98d07851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0f3a023ab06d460cfdff2e98d07851">&#9670;&nbsp;</a></span>random_select_ref_row() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, typename &gt; typename KernelFunctionType, typename RangeNumberType , typename KernelNumberType , typename <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> random_select_ref_row </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelFunctionType&lt; spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt;&#160;</td>
          <td class="paramname"><em>kernel_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>remaining_row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>current_ref_row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>pass_the_end_ref_row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; const typename DoFHandler&lt; dim, spacedim &gt;::cell_iterator * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_to_cell_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HierBEM::CUDAWrappers::CUDABEMValues&lt; dim, spacedim, typename numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bem_values_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>kx_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; *&#160;</td>
          <td class="paramname"><em>ky_map_from_local_to_full_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>kx_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>ky_dof_i2e_numbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMappingInfo.html">MappingInfo</a>&lt; dim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::material_id, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id_to_mapping_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSurfaceNormalDetector.html">SurfaceNormalDetector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWiseScratchData.html">PairCellWiseScratchData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData&lt; dim, spacedim, <a class="el" href="number__traits_8h.html#ab896ee1703adea3163468de8e5a71152">DeviceNumberType</a>&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPairCellWisePerTaskData.html">PairCellWisePerTaskData</a>&lt; dim, spacedim, KernelNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Randomly select a reference row index from the remaining row indices for the next ACA step.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The data type for DoF index is <code>types::global_dof_index</code>, while the data type for matrix row or column index is <code>size_type</code>, which is the unsigned version of <code>blas::int</code>.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_vector</td><td>The selected reference row vector, the memory of which should be preallocated in order to reduce the number of times for memory allocation and releasing. </td></tr>
    <tr><td class="paramname">scratch</td><td></td></tr>
    <tr><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramname">kernel</td><td></td></tr>
    <tr><td class="paramname">remaining_row_indices</td><td>Remaining row indices to be checked and selected from, which are stored in a <code>std::forward_list</code>. </td></tr>
    <tr><td class="paramname">current_ref_row_index</td><td>The current reference row index </td></tr>
    <tr><td class="paramname">pass_the_end_ref_row_index</td><td>When this function cannot select a new reference row, return this invalid index. </td></tr>
    <tr><td class="paramname">row_dof_indices</td><td>The list of DoF indices corresponding to the matrix rows </td></tr>
    <tr><td class="paramname">col_dof_indices</td><td>The list of DoF indices corresponding to the matrix columns </td></tr>
    <tr><td class="paramname">dof_to_cell_topo</td><td>DoF-to-cell topology </td></tr>
    <tr><td class="paramname">bem_values</td><td></td></tr>
    <tr><td class="paramname">kx_dof_handler</td><td></td></tr>
    <tr><td class="paramname">ky_dof_handler</td><td></td></tr>
    <tr><td class="paramname">kx_mapping</td><td></td></tr>
    <tr><td class="paramname">ky_mapping</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The selected reference row index with respect to the matrix block, i.e. matrix block index. </dd></dl>
<p >The array index used to access the <code>std::forward_list</code> <code>remaining_row_indices</code>.</p>
<p >The reference row index to be selected for the next ACA step.</p>
<p >The row DoF index corresponding to the selected reference row index for the next ACA step.</p>
<p >Get the <code>next_ref_row_index'th</code> row from the kernel evaluation.</p>
<p >When the extracted row vector is zero-valued, remove the corresponding row index from the <code>remaining_row_indices</code> and continue another try.</p>
<p >When the extracted row vector is not zero-valued, it is a valid choice. Hence, return the selected row index.</p>
<p >If there is only one row index left, there is no reference row can be selected. Then return the invalid reference row index.</p>
<p >Because the selected row for the next step is the same as the current reference row, try another valid selection.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l00981">981</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="aca__plus_8hcu_source.html#l00125">assemble_kernel_row()</a>, <a class="el" href="generic__functors_8h_source.html#l00192">erase_at()</a>, <a class="el" href="aca__plus_8cu_source.html#l00043">generate_random_index()</a>, <a class="el" href="generic__functors_8h_source.html#l00142">size()</a>, and <a class="el" href="generic__functors_8h_source.html#l00157">value_at()</a>.</p>

</div>
</div>
<a id="a7820a45bc029009bf42ff939076a496f" name="a7820a45bc029009bf42ff939076a496f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7820a45bc029009bf42ff939076a496f">&#9670;&nbsp;</a></span>random_select_ref_row() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeNumberType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> random_select_ref_row </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>remaining_row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>current_ref_row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">size_type</a>&#160;</td>
          <td class="paramname"><em>pass_the_end_ref_row_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >For debugging purpose: randomly select a reference row index from the remaining row indices for the next ACA step.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_vector</td><td>The extracted row vector, the memory of which should be preallocated </td></tr>
    <tr><td class="paramname">A</td><td>The full matrix for the current block, the rows of which are extracted </td></tr>
    <tr><td class="paramname">remaining_row_indices</td><td></td></tr>
    <tr><td class="paramname">current_ref_row_index</td><td></td></tr>
    <tr><td class="paramname">pass_the_end_ref_row_index</td><td>When this function cannot select a new reference row, return this invalid index. </td></tr>
    <tr><td class="paramname">row_dof_indices</td><td></td></tr>
    <tr><td class="paramname">col_dof_indices</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The row index with respect to the matrix block, i.e. matrix block index. </dd></dl>
<p >The array index used to access the <code>std::forward_list</code> <code>remaining_row_indices</code>.</p>
<p >The reference row index to be selected for the next ACA step.</p>
<p >When the extracted row vector is zero-valued, remove the corresponding row index from the <code>remaining_row_indices</code> and continue another try.</p>
<p >When the extracted row vector is not zero-valued, it is a valid choice. Hence, return the selected row index.</p>
<p >If there is only one row index left, there is no reference row can be selected. Then return the invalid reference row index.</p>
<p >Because the selected row for the next step is the same as the current reference row, try another valid selection.</p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l01621">1621</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="generic__functors_8h_source.html#l00192">erase_at()</a>, <a class="el" href="aca__plus_8cu_source.html#l00043">generate_random_index()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l02940">LAPACKFullMatrixExt&lt; Number &gt;::get_row()</a>, <a class="el" href="generic__functors_8h_source.html#l00142">size()</a>, and <a class="el" href="generic__functors_8h_source.html#l00157">value_at()</a>.</p>

</div>
</div>
<a id="a23bbf75055908b5a891d15bb0e165ada" name="a23bbf75055908b5a891d15bb0e165ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bbf75055908b5a891d15bb0e165ada">&#9670;&nbsp;</a></span>stabilize_near_field_hmatrices_for_hypersingular_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename RangeNumberType , typename KernelNumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stabilize_near_field_hmatrices_for_hypersingular_kernel </td>
          <td>(</td>
          <td class="paramtype">const tbb::blocked_range&lt; typename std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, RangeNumberType &gt; * &gt;::iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vector&lt; KernelNumberType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass_vmult_weq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KernelNumberType&#160;</td>
          <td class="paramname"><em>stabilization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_build_symmetric_hmat</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add the stabilization matrix for the bilinear form of the hyper-singular kernel to the range of near field matrices. The stabilization matrix is \(\alpha a a^T\), where \(a = M w_{\rm eq}\) as a column vector is the multiplication of FEM mass matrix and the natural density.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">spacedim</td><td></td></tr>
    <tr><td class="paramname">RangeNumberType</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td></td></tr>
    <tr><td class="paramname">mass_vmult_weq</td><td></td></tr>
    <tr><td class="paramname">stabilization_factor</td><td></td></tr>
    <tr><td class="paramname">enable_build_symmetric_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="aca__plus_8hcu_source.html#l07744">7744</a> of file <a class="el" href="aca__plus_8hcu_source.html">aca_plus.hcu</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l19656">HMatrix&lt; spacedim, Number &gt;::get_block_type()</a>, <a class="el" href="hmatrix_8h_source.html#l36011">HMatrix&lt; spacedim, Number &gt;::get_col_index_range()</a>, <a class="el" href="hmatrix_8h_source.html#l19815">HMatrix&lt; spacedim, Number &gt;::get_fullmatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l19121">HMatrix&lt; spacedim, Number &gt;::get_property()</a>, <a class="el" href="lapack__full__matrix__ext_8h_source.html#l06702">LAPACKFullMatrixExt&lt; Number &gt;::get_property()</a>, <a class="el" href="hmatrix_8h_source.html#l35995">HMatrix&lt; spacedim, Number &gt;::get_row_index_range()</a>, and <a class="el" href="hmatrix_8h_source.html#l19052">HMatrix&lt; spacedim, Number &gt;::get_type()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af80168c5d1672d91c79309bcee22bb56" name="af80168c5d1672d91c79309bcee22bb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80168c5d1672d91c79309bcee22bb56">&#9670;&nbsp;</a></span>rand_engine</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mt19937 rand_engine</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Global declaration of the random number device and engine. </p>

<p class="definition">Definition at line <a class="el" href="aca__plus_8cu_source.html#l00038">38</a> of file <a class="el" href="aca__plus_8cu_source.html">aca_plus.cu</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
