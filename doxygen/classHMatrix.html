<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HierBEM: HMatrix&lt; spacedim, Number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js", "TeX/AMScd.js.js"],
  jax: ["input/TeX","output/SVG"],
});
MathJax.Hub.Config({
  jax: ["input/TeX", "output/SVG"],
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js", "TeX/AMScd.js"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    skipTags: ["script","noscript","style","textarea","pre","code"],
    processEscapes: false,
    processEnvironments: true,
    preview: "TeX"
  },
  TeX: {
    Macros: {
      intd: "\\,{\\rm d}",
        diff: "{\\rm d}",
        Diff: "{\\rm D}",
        pdiff: "\\partial",
        DD: ["\\frac{\\diff}{\\diff #2}\\left( #1 \\right)", 2],
        Dd: ["\\frac{\\diff #1}{\\diff #2}", 2],
        PD: ["\\frac{\\pdiff}{\\pdiff #2}\\left( #1 \\right)", 2],
        Pd: ["\\frac{\\pdiff #1}{\\pdiff #2}", 2],
        rme: "{\\rm e}",
        rmi: "{\\rm i}",
        rmj: "{\\rm j}",
        vect: ["\\boldsymbol{#1}", 1],
        dform: ["\\overset{\\rightharpoonup}{\\boldsymbol{#1}}", 1],
        cochain: ["\\overset{\\rightharpoonup}{#1}", 1],
        bigabs: ["\\bigg\\lvert#1\\bigg\\rvert", 1],
        Abs: ["\\big\\lvert#1\\big\\rvert", 1],
        abs: ["\\lvert#1\\rvert", 1],
        bignorm: ["\\bigg\\lVert#1\\bigg\\rVert", 1],
        Norm: ["\\big\\lVert#1\\big\\rVert", 1],
        norm: ["\\lVert#1\\rVert", 1],
        normvect: "\\vect{n}",
        ouset: ["\\overset{#3}{\\underset{#2}{#1}}", 3],
        cscript: ["\\;\\; #1", 1],
        suchthat: "\\textit{S.T.\\;}",
        prefstar: "\\ast",
        restrict: "\\big\\vert",
        sgn: "{\\rm sgn}",
        erf: "{\\rm erf}",
        Bd: "{\\rm Bd}",
        Int: "{\\rm Int}",
        dim: "{\\rm dim}",
        rank: "{\\rm rank}",
        range: "{\\rm range}",
        divergence: "{\\rm div}",
        curl: "{\\rm curl}",
        grad: "{\\rm grad}",
        diag: "{\\rm diag}",
        tr: "{\\rm tr}",
        span: "{\\rm span}",
        lhs: "{\\rm LHS}",
        rhs: "{\\rm RHS}",
        argmin: "{\\rm argmin}",
        argmax: "{\\rm argmax}",
        esssup: "{\\rm ess sup}",
        essinf: "{\\rm ess inf}",
        kernel: "{\\rm ker}",
        image: "{\\rm Im}",
        diam: "{\\rm diam}"
    },
    equationNumbers: { autoNumber: "AMS" }
  },
  "HTML-CSS": {
     availableFonts: ["STIX","TeX"],
     preferredFont: "TeX",
     webFont: "TeX",
     imageFont: "TeX",
     showMathMenu: true
  },
  MMLorHTML: {
    prefer: {
      MSIE:    "MML",
      Firefox: "MML",
      Opera:   "HTML",
      other:   "HTML"
    }
  }
});
</script>
<script type="text/javascript" async="async" src="https://jihuan-tian.github.io/hierbem-site/js/MathJax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">HierBEM<span id="projectnumber">&#160;v1.0.0</span>
   </div>
   <div id="projectbrief">Hierarchical matrix based 3D Galerkin boundary element method (BEM) C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classHMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">HMatrix&lt; spacedim, Number &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix_1_1UpdateTaskNodeForLUOrCholesky.html">UpdateTaskNodeForLUOrCholesky</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHMatrix_1_1VmultOrTvmultThreadData.html">VmultOrTvmultThreadData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2b67e35d653ab864ae89c137ea3c8615"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615">SpaceFillingCurveType</a> { <a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615a28de0ca7ea61d1edea9a803db4c0fa34">Z</a>
, <a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615ae616dc6bd2559757065bcab8df46f355">Hilbert</a>
 }</td></tr>
<tr class="separator:a2b67e35d653ab864ae89c137ea3c8615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaff6be3787ae9ecebd8cb53868ae65b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#afaff6be3787ae9ecebd8cb53868ae65b">HilbertBlockType</a> { <b>A</b>
, <b>B</b>
, <b>C</b>
, <b>D</b>
 }</td></tr>
<tr class="separator:afaff6be3787ae9ecebd8cb53868ae65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca8dc549783d38371a01ecd621ecb34"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> = std::make_unsigned&lt; types::blas_int &gt;<a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">::type</a></td></tr>
<tr class="separator:a5ca8dc549783d38371a01ecd621ecb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2580f4a72dc08c758be692a4e904952"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa2580f4a72dc08c758be692a4e904952">value_type</a> = Number</td></tr>
<tr class="separator:aa2580f4a72dc08c758be692a4e904952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9caa0d8f5c4d73364969feea0de137"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a1a9caa0d8f5c4d73364969feea0de137">real_type</a> = typename numbers::NumberTraits&lt; Number &gt;::real_type</td></tr>
<tr class="separator:a1a9caa0d8f5c4d73364969feea0de137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d96bca39ce2ce666ae5e997f2cc32d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8d96bca39ce2ce666ae5e997f2cc32d5">TaskNode</a> = tbb::flow::continue_node&lt; tbb::flow::continue_msg &gt;</td></tr>
<tr class="separator:a8d96bca39ce2ce666ae5e997f2cc32d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cc9da38a1c6ef145ea4f5f6624e1dd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a39cc9da38a1c6ef145ea4f5f6624e1dd">TaskNodePtr</a> = std::shared_ptr&lt; <a class="el" href="classHMatrix.html#a8d96bca39ce2ce666ae5e997f2cc32d5">TaskNode</a> &gt;</td></tr>
<tr class="separator:a39cc9da38a1c6ef145ea4f5f6624e1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae3dc35e1aefee2580d27ad2d65c906de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae3dc35e1aefee2580d27ad2d65c906de">HMatrix</a> ()</td></tr>
<tr class="separator:ae3dc35e1aefee2580d27ad2d65c906de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194ec72be8c3b078f90e528422cc5ca8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a194ec72be8c3b078f90e528422cc5ca8">HMatrix</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;bct, const unsigned int fixed_rank_k=1, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> <a class="el" href="classHMatrix.html#afef60ed63bd5b247116ce42cbb74e9b4">property</a>=HMatrixSupport::Property::general, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> <a class="el" href="classHMatrix.html#a6d2930c9ef5832e01cc98b3cb03b9a91">block_type</a>=HMatrixSupport::BlockType::undefined_block)</td></tr>
<tr class="separator:a194ec72be8c3b078f90e528422cc5ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ec7c9a264e5c91d1d2e1c8e9afa829"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a64ec7c9a264e5c91d1d2e1c8e9afa829">HMatrix</a> (typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#acc153ec757cd8fecdeca2274e1ed5a27">bc_node</a>, const unsigned int fixed_rank_k=1, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> <a class="el" href="classHMatrix.html#afef60ed63bd5b247116ce42cbb74e9b4">property</a>=HMatrixSupport::Property::general, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> <a class="el" href="classHMatrix.html#a6d2930c9ef5832e01cc98b3cb03b9a91">block_type</a>=HMatrixSupport::BlockType::undefined_block)</td></tr>
<tr class="separator:a64ec7c9a264e5c91d1d2e1c8e9afa829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08639151120336201d0a1df4e011b54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa08639151120336201d0a1df4e011b54">HMatrix</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;bct, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, const unsigned int fixed_rank_k, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> <a class="el" href="classHMatrix.html#a6d2930c9ef5832e01cc98b3cb03b9a91">block_type</a>=HMatrixSupport::BlockType::diagonal_block)</td></tr>
<tr class="separator:aa08639151120336201d0a1df4e011b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611361b83bdcc32acc5872587a3b1706"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a611361b83bdcc32acc5872587a3b1706">HMatrix</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;bct, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> <a class="el" href="classHMatrix.html#a6d2930c9ef5832e01cc98b3cb03b9a91">block_type</a>=HMatrixSupport::BlockType::diagonal_block)</td></tr>
<tr class="separator:a611361b83bdcc32acc5872587a3b1706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813e1de9fb112e29f95875c7eb942fd8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a813e1de9fb112e29f95875c7eb942fd8">HMatrix</a> (typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#acc153ec757cd8fecdeca2274e1ed5a27">bc_node</a>, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, const unsigned int fixed_rank_k, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> <a class="el" href="classHMatrix.html#afef60ed63bd5b247116ce42cbb74e9b4">property</a>=HMatrixSupport::Property::general, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> <a class="el" href="classHMatrix.html#a6d2930c9ef5832e01cc98b3cb03b9a91">block_type</a>=HMatrixSupport::BlockType::undefined_block)</td></tr>
<tr class="separator:a813e1de9fb112e29f95875c7eb942fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff43c2b8b2880094c3c2e85299cb5555"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aff43c2b8b2880094c3c2e85299cb5555">HMatrix</a> (typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#acc153ec757cd8fecdeca2274e1ed5a27">bc_node</a>, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> <a class="el" href="classHMatrix.html#afef60ed63bd5b247116ce42cbb74e9b4">property</a>=HMatrixSupport::Property::general, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> <a class="el" href="classHMatrix.html#a6d2930c9ef5832e01cc98b3cb03b9a91">block_type</a>=HMatrixSupport::BlockType::undefined_block)</td></tr>
<tr class="separator:aff43c2b8b2880094c3c2e85299cb5555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2456ea4b70ec915a821c5385b523beec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a2456ea4b70ec915a821c5385b523beec">HMatrix</a> (typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#acc153ec757cd8fecdeca2274e1ed5a27">bc_node</a>, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;H, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> <a class="el" href="classHMatrix.html#afef60ed63bd5b247116ce42cbb74e9b4">property</a>=HMatrixSupport::Property::general, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> <a class="el" href="classHMatrix.html#a6d2930c9ef5832e01cc98b3cb03b9a91">block_type</a>=HMatrixSupport::BlockType::undefined_block)</td></tr>
<tr class="separator:a2456ea4b70ec915a821c5385b523beec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557c894192e6191e8db7837222229beb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a557c894192e6191e8db7837222229beb">HMatrix</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;bct, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;H, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> <a class="el" href="classHMatrix.html#afef60ed63bd5b247116ce42cbb74e9b4">property</a>=HMatrixSupport::Property::general, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> <a class="el" href="classHMatrix.html#a6d2930c9ef5832e01cc98b3cb03b9a91">block_type</a>=HMatrixSupport::BlockType::diagonal_block)</td></tr>
<tr class="separator:a557c894192e6191e8db7837222229beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5227e35290f6c9fba1e8948e9a29c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a0b5227e35290f6c9fba1e8948e9a29c3">HMatrix</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;H)</td></tr>
<tr class="separator:a0b5227e35290f6c9fba1e8948e9a29c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ceaa51b9b52d22e79558dfc22470855"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a1ceaa51b9b52d22e79558dfc22470855">HMatrix</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;H) noexcept</td></tr>
<tr class="separator:a1ceaa51b9b52d22e79558dfc22470855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8b3b5ffd2e97045467baab87652dd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a3d8b3b5ffd2e97045467baab87652dd2">reinit</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;bct, const unsigned int fixed_rank_k=1, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> <a class="el" href="classHMatrix.html#afef60ed63bd5b247116ce42cbb74e9b4">property</a>=HMatrixSupport::Property::general, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> <a class="el" href="classHMatrix.html#a6d2930c9ef5832e01cc98b3cb03b9a91">block_type</a>=HMatrixSupport::BlockType::diagonal_block)</td></tr>
<tr class="separator:a3d8b3b5ffd2e97045467baab87652dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f9bf00d44b3a39d10b9d9812333820"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a51f9bf00d44b3a39d10b9d9812333820">reinit</a> (typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#acc153ec757cd8fecdeca2274e1ed5a27">bc_node</a>, const unsigned int fixed_rank_k=1, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> <a class="el" href="classHMatrix.html#afef60ed63bd5b247116ce42cbb74e9b4">property</a>=HMatrixSupport::Property::general, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> <a class="el" href="classHMatrix.html#a6d2930c9ef5832e01cc98b3cb03b9a91">block_type</a>=HMatrixSupport::BlockType::undefined_block)</td></tr>
<tr class="separator:a51f9bf00d44b3a39d10b9d9812333820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8fe1da532131cb665bf2f3e15f5edf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6a8fe1da532131cb665bf2f3e15f5edf">operator=</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;H) noexcept</td></tr>
<tr class="separator:a6a8fe1da532131cb665bf2f3e15f5edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83958971f40409b3b2a192b71eae1513"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a83958971f40409b3b2a192b71eae1513">operator=</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;H)</td></tr>
<tr class="separator:a83958971f40409b3b2a192b71eae1513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bdd40f7fcf5c912c34c427df518300"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a00bdd40f7fcf5c912c34c427df518300"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a00bdd40f7fcf5c912c34c427df518300">convertToFullMatrix</a> (MatrixType &amp;M) const</td></tr>
<tr class="separator:a00bdd40f7fcf5c912c34c427df518300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812e8276888b2ad866edf7ce9b286839"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">release</a> ()</td></tr>
<tr class="separator:a812e8276888b2ad866edf7ce9b286839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55bd45587b895bfdb977e7cbea46519"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae55bd45587b895bfdb977e7cbea46519">clear</a> ()</td></tr>
<tr class="separator:ae55bd45587b895bfdb977e7cbea46519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0815bc9c3654391bb2b3095383e6cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">clear_hmat_node</a> ()</td></tr>
<tr class="separator:aec0815bc9c3654391bb2b3095383e6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccb82bba509fd20ba0e457e740b3fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a5ccb82bba509fd20ba0e457e740b3fb6">clear_lu_or_cholesky_task_nodes</a> ()</td></tr>
<tr class="separator:a5ccb82bba509fd20ba0e457e740b3fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54406262b0d059c179343ec094d16a72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a54406262b0d059c179343ec094d16a72">clear_lu_or_cholesky_task_nodes_in_hmat</a> ()</td></tr>
<tr class="separator:a54406262b0d059c179343ec094d16a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16c956c1b22eb307e9f360a83f4fa75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae16c956c1b22eb307e9f360a83f4fa75">~HMatrix</a> ()</td></tr>
<tr class="separator:ae16c956c1b22eb307e9f360a83f4fa75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadea9fa59f420d22b3b1c939f6b573cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aadea9fa59f420d22b3b1c939f6b573cc">get_type</a> () const</td></tr>
<tr class="separator:aadea9fa59f420d22b3b1c939f6b573cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcc86e342c590738ee7ad92e1a102ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8bcc86e342c590738ee7ad92e1a102ce">is_root</a> () const</td></tr>
<tr class="separator:a8bcc86e342c590738ee7ad92e1a102ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b1f5aa80236d23aa948e05d6c8676d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af2b1f5aa80236d23aa948e05d6c8676d">is_near_field</a> () const</td></tr>
<tr class="separator:af2b1f5aa80236d23aa948e05d6c8676d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dcfe1628d551c13f2f54f850f748df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac1dcfe1628d551c13f2f54f850f748df">is_far_field</a> () const</td></tr>
<tr class="separator:ac1dcfe1628d551c13f2f54f850f748df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5463a24b07333c9820c1e0aa37ab65eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a5463a24b07333c9820c1e0aa37ab65eb">is_leaf</a> () const</td></tr>
<tr class="separator:a5463a24b07333c9820c1e0aa37ab65eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe735f7712a10ba5325ff116f8ca1c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aabe735f7712a10ba5325ff116f8ca1c7">get_m</a> () const</td></tr>
<tr class="separator:aabe735f7712a10ba5325ff116f8ca1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347c22d4965e748b9778d853ab72ef68"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a347c22d4965e748b9778d853ab72ef68">get_n_row_blocks</a> () const</td></tr>
<tr class="separator:a347c22d4965e748b9778d853ab72ef68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20e7d0b58512976e355e4bd617696cb"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab20e7d0b58512976e355e4bd617696cb">get_n_col_blocks</a> () const</td></tr>
<tr class="separator:ab20e7d0b58512976e355e4bd617696cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f60ad32ac22100cb44a963f2ec82349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a2f60ad32ac22100cb44a963f2ec82349">get_property</a> () const</td></tr>
<tr class="separator:a2f60ad32ac22100cb44a963f2ec82349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0910b5065c2edeb9135ded2010aacc7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a0910b5065c2edeb9135ded2010aacc7e">set_current_matrix_property</a> (const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> <a class="el" href="classHMatrix.html#afef60ed63bd5b247116ce42cbb74e9b4">property</a>)</td></tr>
<tr class="separator:a0910b5065c2edeb9135ded2010aacc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a807ab7d80f124e5713f5c1a25b03e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6a807ab7d80f124e5713f5c1a25b03e1">set_current_matrix_property</a> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a6a807ab7d80f124e5713f5c1a25b03e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0d7f72ac23e856efd7d5f0b0bff4df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aac0d7f72ac23e856efd7d5f0b0bff4df">set_property</a> (const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> <a class="el" href="classHMatrix.html#afef60ed63bd5b247116ce42cbb74e9b4">property</a>)</td></tr>
<tr class="separator:aac0d7f72ac23e856efd7d5f0b0bff4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b19edf2d99ada13990fdbfe4b7bd90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a00b19edf2d99ada13990fdbfe4b7bd90">set_property</a> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a00b19edf2d99ada13990fdbfe4b7bd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37523f6e2ffc646f48b2a93e1e80f92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae37523f6e2ffc646f48b2a93e1e80f92">set_current_matrix_state</a> (const <a class="el" href="hmatrix__support_8h.html#a8358c4882bca00f7e887d9b44e633aa0">HMatrixSupport::State</a> <a class="el" href="classHMatrix.html#ab504bacb27635c8962c8e58eba943e6b">state</a>)</td></tr>
<tr class="separator:ae37523f6e2ffc646f48b2a93e1e80f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b694355eaed1b888e7223d90eb0b81d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hmatrix__support_8h.html#a8358c4882bca00f7e887d9b44e633aa0">HMatrixSupport::State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8b694355eaed1b888e7223d90eb0b81d">get_state</a> () const</td></tr>
<tr class="separator:a8b694355eaed1b888e7223d90eb0b81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b53f819723d341285ab93b7cc32f7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac8b53f819723d341285ab93b7cc32f7f">set_state</a> (const <a class="el" href="hmatrix__support_8h.html#a8358c4882bca00f7e887d9b44e633aa0">HMatrixSupport::State</a> <a class="el" href="classHMatrix.html#ab504bacb27635c8962c8e58eba943e6b">state</a>)</td></tr>
<tr class="separator:ac8b53f819723d341285ab93b7cc32f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22b6f66ad982ae50668d696aaba7c24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa22b6f66ad982ae50668d696aaba7c24">get_block_type</a> () const</td></tr>
<tr class="separator:aa22b6f66ad982ae50668d696aaba7c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896ce340a65c96b0947736a5235d18fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a896ce340a65c96b0947736a5235d18fb">set_current_matrix_block_type</a> (const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> <a class="el" href="classHMatrix.html#a6d2930c9ef5832e01cc98b3cb03b9a91">block_type</a>)</td></tr>
<tr class="separator:a896ce340a65c96b0947736a5235d18fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0722edd8560ac7dfee0ca5259d0935"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aeb0722edd8560ac7dfee0ca5259d0935">set_block_type</a> (const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> <a class="el" href="classHMatrix.html#a6d2930c9ef5832e01cc98b3cb03b9a91">block_type</a>)</td></tr>
<tr class="separator:aeb0722edd8560ac7dfee0ca5259d0935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff89130116d62ea4159bc69ca11f8d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#abff89130116d62ea4159bc69ca11f8d5">get_n</a> () const</td></tr>
<tr class="separator:abff89130116d62ea4159bc69ca11f8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0189de6e276fbd3425c4a7ef132f5e16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a0189de6e276fbd3425c4a7ef132f5e16">get_rkmatrix</a> ()</td></tr>
<tr class="separator:a0189de6e276fbd3425c4a7ef132f5e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c81db6357d0e00b82fd523af001ae5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a64c81db6357d0e00b82fd523af001ae5">get_rkmatrix</a> () const</td></tr>
<tr class="separator:a64c81db6357d0e00b82fd523af001ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72191c447afaa0fd84505022cf1d174e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a72191c447afaa0fd84505022cf1d174e">calc_rank_upper_bound_for_rkmatrices</a> () const</td></tr>
<tr class="separator:a72191c447afaa0fd84505022cf1d174e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d914c27d4e990d476a4529b2daa64cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a9d914c27d4e990d476a4529b2daa64cd">get_fullmatrix</a> ()</td></tr>
<tr class="separator:a9d914c27d4e990d476a4529b2daa64cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed550b5b41a64c6f1bbcde4f8f7eca91"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aed550b5b41a64c6f1bbcde4f8f7eca91">get_fullmatrix</a> () const</td></tr>
<tr class="separator:aed550b5b41a64c6f1bbcde4f8f7eca91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0572b2c0484ce618db0034e3bc7988ed"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a0572b2c0484ce618db0034e3bc7988ed">get_submatrices</a> ()</td></tr>
<tr class="separator:a0572b2c0484ce618db0034e3bc7988ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8e9bc437ab86296d78950081ea34cd"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8f8e9bc437ab86296d78950081ea34cd">get_submatrices</a> () const</td></tr>
<tr class="separator:a8f8e9bc437ab86296d78950081ea34cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e849f7e8f35e3ebdfcb2dbb7ad4ad01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a7e849f7e8f35e3ebdfcb2dbb7ad4ad01">print_formatted</a> (std::ostream &amp;out, const unsigned int precision=3, const bool scientific=true, const unsigned int width=0, const char *zero_string=&quot; &quot;, const double denominator=1., const double threshold=0.) const</td></tr>
<tr class="separator:a7e849f7e8f35e3ebdfcb2dbb7ad4ad01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f87883cf49080706233441c0e09171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ad8f87883cf49080706233441c0e09171">print_matrix_info</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ad8f87883cf49080706233441c0e09171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0c393acf1c416ebc7ab05ca85d9e49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aab0c393acf1c416ebc7ab05ca85d9e49">print_current_matrix_info</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:aab0c393acf1c416ebc7ab05ca85d9e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a659ef16f75b771cadfbdf4561cc57d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a1a659ef16f75b771cadfbdf4561cc57d">print_matrix_info_as_dot</a> (std::ostream &amp;out)</td></tr>
<tr class="separator:a1a659ef16f75b771cadfbdf4561cc57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6def1971478e41bf08cd5df77f9873ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6def1971478e41bf08cd5df77f9873ed">print_as_formatted_full_matrix</a> (std::ostream &amp;out, const std::string &amp;name, const unsigned int precision=8, const bool scientific=true, const unsigned int width=0, const char *zero_string=&quot;0&quot;, const double denominator=1., const double threshold=0.) const</td></tr>
<tr class="separator:a6def1971478e41bf08cd5df77f9873ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41e8ad6d96d27dffc21fddb8cde4544"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab41e8ad6d96d27dffc21fddb8cde4544">print_leaf_set_info</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ab41e8ad6d96d27dffc21fddb8cde4544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9daef657e3ce80c6761c2efdd799b6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab9daef657e3ce80c6761c2efdd799b6c">write_fullmatrix_leaf_node</a> (std::ostream &amp;out, const real_type singular_value_threshold=0.) const</td></tr>
<tr class="separator:ab9daef657e3ce80c6761c2efdd799b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c8ccd5763d3952505741c657b6468c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac2c8ccd5763d3952505741c657b6468c">write_rkmatrix_leaf_node</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ac2c8ccd5763d3952505741c657b6468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c08c982804a0cbfd3210c6be3599ea3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a7c08c982804a0cbfd3210c6be3599ea3">write_leaf_set</a> (std::ostream &amp;out, const real_type singular_value_threshold=0.) const</td></tr>
<tr class="separator:a7c08c982804a0cbfd3210c6be3599ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5440e0e6e0c75066f200feaa4ebda40c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a5440e0e6e0c75066f200feaa4ebda40c">write_leaf_set_by_iteration</a> (std::ostream &amp;out, const real_type singular_value_threshold=0.) const</td></tr>
<tr class="separator:a5440e0e6e0c75066f200feaa4ebda40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da518d5ca7e685e3e787f58dcad4e61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a1da518d5ca7e685e3e787f58dcad4e61">find_row_diag_block_for_offdiag_block</a> ()</td></tr>
<tr class="separator:a1da518d5ca7e685e3e787f58dcad4e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab763860706b9cbef8f5e73d995f29a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a1ab763860706b9cbef8f5e73d995f29a">find_col_diag_block_for_offdiag_block</a> ()</td></tr>
<tr class="separator:a1ab763860706b9cbef8f5e73d995f29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64be687cacd167efc12b892aa154dcd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a64be687cacd167efc12b892aa154dcd3">truncate_to_rank</a> (<a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> new_rank)</td></tr>
<tr class="separator:a64be687cacd167efc12b892aa154dcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938473855f9e95358d00ee7ea14f6c51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a938473855f9e95358d00ee7ea14f6c51">truncate_to_rank_preserve_positive_definite</a> (<a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> new_rank, const bool is_only_handle_tril=true)</td></tr>
<tr class="separator:a938473855f9e95358d00ee7ea14f6c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421beeb0b30d63f286a7905db394bdab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a421beeb0b30d63f286a7905db394bdab">truncate_to_rank_diag_preserve_positive_definite</a> (<a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> new_rank, const bool is_only_handle_tril=true)</td></tr>
<tr class="separator:a421beeb0b30d63f286a7905db394bdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88546d9ca48a3c1a2a0874545cc4c8df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a88546d9ca48a3c1a2a0874545cc4c8df">truncate_to_rank_off_diag_preserve_positive_definite</a> (<a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> new_rank, const bool is_compensate_diag_blocks=true)</td></tr>
<tr class="separator:a88546d9ca48a3c1a2a0874545cc4c8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1e7c2802c14c86080b84005bea3cf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6a1e7c2802c14c86080b84005bea3cf0">set_default_vmult_strategy</a> ()</td></tr>
<tr class="separator:a6a1e7c2802c14c86080b84005bea3cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af096bc12ca77bb1a71282fa1ce03ad23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af096bc12ca77bb1a71282fa1ce03ad23">set_vmult_strategy</a> (std::unique_ptr&lt; <a class="el" href="classHMatrixVmultStrategy.html">HMatrixVmultStrategy</a>&lt; spacedim, Number &gt; &gt; strategy)</td></tr>
<tr class="separator:af096bc12ca77bb1a71282fa1ce03ad23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbf34180ab8dc8c09a200b32c636ea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#adbbf34180ab8dc8c09a200b32c636ea9">vmult</a> (Vector&lt; Number &gt; &amp;y, const Vector&lt; Number &gt; &amp;x, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:adbbf34180ab8dc8c09a200b32c636ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8232db1cb74fdf791264e8e05a12341b"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a8232db1cb74fdf791264e8e05a12341b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8232db1cb74fdf791264e8e05a12341b">vmult</a> (Vector&lt; Number &gt; &amp;y, const Number2 alpha, const Vector&lt; Number &gt; &amp;x, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:a8232db1cb74fdf791264e8e05a12341b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385f2c2bd3344106ca7be36cb07911ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a385f2c2bd3344106ca7be36cb07911ab">vmult</a> (Vector&lt; Number &gt; &amp;y, const Vector&lt; Number &gt; &amp;x, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:a385f2c2bd3344106ca7be36cb07911ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f01d982409cbd87263acf44cdd28944"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a0f01d982409cbd87263acf44cdd28944"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a0f01d982409cbd87263acf44cdd28944">vmult</a> (Vector&lt; Number &gt; &amp;y, const Number2 alpha, const Vector&lt; Number &gt; &amp;x, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:a0f01d982409cbd87263acf44cdd28944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4ac818aa34c9b7f8311e85871f04a8"><td class="memTemplParams" colspan="2">template&lt;typename Number2 , typename Number3 &gt; </td></tr>
<tr class="memitem:afe4ac818aa34c9b7f8311e85871f04a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#afe4ac818aa34c9b7f8311e85871f04a8">vmult_serial_iterative</a> (const Number2 beta, Vector&lt; Number &gt; &amp;y, const Number3 alpha, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:afe4ac818aa34c9b7f8311e85871f04a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c68f0bc71bc6904b5a5d93ec82262e8"><td class="memTemplParams" colspan="2">template&lt;typename Number2 , typename Number3 &gt; </td></tr>
<tr class="memitem:a8c68f0bc71bc6904b5a5d93ec82262e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8c68f0bc71bc6904b5a5d93ec82262e8">vmult_task_parallel</a> (const Number2 beta, Vector&lt; Number &gt; &amp;y, const Number3 alpha, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:a8c68f0bc71bc6904b5a5d93ec82262e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11b5761aba86606effd14b4bdf31912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">vmult</a> (Vector&lt; Number &gt; &amp;y, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:aa11b5761aba86606effd14b4bdf31912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bd65c4b094859f2cab51943387ef07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa3bd65c4b094859f2cab51943387ef07">vmult_add</a> (Vector&lt; Number &gt; &amp;y, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:aa3bd65c4b094859f2cab51943387ef07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477c9c01a7ca957b710b978c972cac7c"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a477c9c01a7ca957b710b978c972cac7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a477c9c01a7ca957b710b978c972cac7c">vmult</a> (Vector&lt; Number &gt; &amp;y, const Number2 alpha, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:a477c9c01a7ca957b710b978c972cac7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8292d39103f6ee9fd817121aa2235b"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:aca8292d39103f6ee9fd817121aa2235b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aca8292d39103f6ee9fd817121aa2235b">vmult_add</a> (Vector&lt; Number &gt; &amp;y, const Number2 alpha, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:aca8292d39103f6ee9fd817121aa2235b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4da3bc44083f7bc4798a019928056dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab4da3bc44083f7bc4798a019928056dd">Tvmult</a> (Vector&lt; Number &gt; &amp;y, const Vector&lt; Number &gt; &amp;x, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:ab4da3bc44083f7bc4798a019928056dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a87e1448e004e1028409aa35e3b2f81"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a3a87e1448e004e1028409aa35e3b2f81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a3a87e1448e004e1028409aa35e3b2f81">Tvmult</a> (Vector&lt; Number &gt; &amp;y, const Number2 alpha, const Vector&lt; Number &gt; &amp;x, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:a3a87e1448e004e1028409aa35e3b2f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac8968a871a1ceea6715cdaad53679b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a1ac8968a871a1ceea6715cdaad53679b">Tvmult</a> (Vector&lt; Number &gt; &amp;y, const Vector&lt; Number &gt; &amp;x, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:a1ac8968a871a1ceea6715cdaad53679b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644b2ceec8129d8ed5c162601fef9402"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a644b2ceec8129d8ed5c162601fef9402"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a644b2ceec8129d8ed5c162601fef9402">Tvmult</a> (Vector&lt; Number &gt; &amp;y, const Number2 alpha, const Vector&lt; Number &gt; &amp;x, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:a644b2ceec8129d8ed5c162601fef9402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512208d62ab73b3106789dc26da041eb"><td class="memTemplParams" colspan="2">template&lt;typename Number2 , typename Number3 &gt; </td></tr>
<tr class="memitem:a512208d62ab73b3106789dc26da041eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a512208d62ab73b3106789dc26da041eb">Tvmult_serial_iterative</a> (const Number2 beta, Vector&lt; Number &gt; &amp;y, const Number3 alpha, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:a512208d62ab73b3106789dc26da041eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cc513bffdab39bb4ce6e818d23452a"><td class="memTemplParams" colspan="2">template&lt;typename Number2 , typename Number3 &gt; </td></tr>
<tr class="memitem:a20cc513bffdab39bb4ce6e818d23452a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a20cc513bffdab39bb4ce6e818d23452a">Tvmult_task_parallel</a> (const Number2 beta, Vector&lt; Number &gt; &amp;y, const Number3 alpha, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:a20cc513bffdab39bb4ce6e818d23452a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e5255eb5ce46136d0e2b195c82f016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">Tvmult</a> (Vector&lt; Number &gt; &amp;y, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:a72e5255eb5ce46136d0e2b195c82f016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42722bdec9d1af24cc3f4ad03296ce6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af42722bdec9d1af24cc3f4ad03296ce6">Tvmult_add</a> (Vector&lt; Number &gt; &amp;y, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:af42722bdec9d1af24cc3f4ad03296ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bae1198a6f79a4aae86de495795e47"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a05bae1198a6f79a4aae86de495795e47"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a05bae1198a6f79a4aae86de495795e47">Tvmult</a> (Vector&lt; Number &gt; &amp;y, const Number2 alpha, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:a05bae1198a6f79a4aae86de495795e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499e785209cdda063fe05a677b0dd083"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a499e785209cdda063fe05a677b0dd083"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a499e785209cdda063fe05a677b0dd083">Tvmult_add</a> (Vector&lt; Number &gt; &amp;y, const Number2 alpha, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:a499e785209cdda063fe05a677b0dd083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5e188e85cfb6e496b248623a2ac4c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8b5e188e85cfb6e496b248623a2ac4c1">Hvmult</a> (Vector&lt; Number &gt; &amp;y, const Vector&lt; Number &gt; &amp;x, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:a8b5e188e85cfb6e496b248623a2ac4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a4720ce98a0e06cc0a6a5b6699dd7c"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ad8a4720ce98a0e06cc0a6a5b6699dd7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ad8a4720ce98a0e06cc0a6a5b6699dd7c">Hvmult</a> (Vector&lt; Number &gt; &amp;y, const Number2 alpha, const Vector&lt; Number &gt; &amp;x, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:ad8a4720ce98a0e06cc0a6a5b6699dd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae892da432aa66cce8c7a5957bfad1524"><td class="memTemplParams" colspan="2">template&lt;typename Number2 , typename Number3 &gt; </td></tr>
<tr class="memitem:ae892da432aa66cce8c7a5957bfad1524"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae892da432aa66cce8c7a5957bfad1524">Hvmult_task_parallel</a> (const Number2 beta, Vector&lt; Number &gt; &amp;y, const Number3 alpha, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:ae892da432aa66cce8c7a5957bfad1524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15331134773fc584b60a9c34c93eec87"><td class="memTemplParams" colspan="2">template&lt;typename Number2 , typename Number3 &gt; </td></tr>
<tr class="memitem:a15331134773fc584b60a9c34c93eec87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a15331134773fc584b60a9c34c93eec87">Hvmult_serial_iterative</a> (const Number2 beta, Vector&lt; Number &gt; &amp;y, const Number3 alpha, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="memdesc:a15331134773fc584b60a9c34c93eec87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication as \(y =
\beta y + \alpha \cdot M^H \cdot x\) by iterating over the leaf set.  <a href="classHMatrix.html#a15331134773fc584b60a9c34c93eec87">More...</a><br /></td></tr>
<tr class="separator:a15331134773fc584b60a9c34c93eec87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2bc6ca001ca921f280614faeddd435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a1b2bc6ca001ca921f280614faeddd435">Hvmult</a> (Vector&lt; Number &gt; &amp;y, const Vector&lt; Number &gt; &amp;x, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:a1b2bc6ca001ca921f280614faeddd435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c94c022628ddfca8aa122ef34432e27"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a6c94c022628ddfca8aa122ef34432e27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6c94c022628ddfca8aa122ef34432e27">Hvmult</a> (Vector&lt; Number &gt; &amp;y, const Number2 alpha, const Vector&lt; Number &gt; &amp;x, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:a6c94c022628ddfca8aa122ef34432e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a43050c345bd3509a8f5c43aaa81d1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a7a43050c345bd3509a8f5c43aaa81d1b">Hvmult</a> (Vector&lt; Number &gt; &amp;y, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:a7a43050c345bd3509a8f5c43aaa81d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f71200095b99f4eec2f34ccfe9c3cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa8f71200095b99f4eec2f34ccfe9c3cb">Hvmult_add</a> (Vector&lt; Number &gt; &amp;y, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:aa8f71200095b99f4eec2f34ccfe9c3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12dd46760596b0b15fdfa5d4ad0b014"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ab12dd46760596b0b15fdfa5d4ad0b014"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab12dd46760596b0b15fdfa5d4ad0b014">Hvmult</a> (Vector&lt; Number &gt; &amp;y, const Number2 alpha, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:ab12dd46760596b0b15fdfa5d4ad0b014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae30964f21e645da51c2026d064b54ca"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:aae30964f21e645da51c2026d064b54ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aae30964f21e645da51c2026d064b54ca">Hvmult_add</a> (Vector&lt; Number &gt; &amp;y, const Number2 alpha, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:aae30964f21e645da51c2026d064b54ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168b6eea2e5b27528497850bf5ee2bbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a168b6eea2e5b27528497850bf5ee2bbe">h_h_mmult_reduction</a> ()</td></tr>
<tr class="separator:a168b6eea2e5b27528497850bf5ee2bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ab8944771c025a9ad4ff006c91f912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a37ab8944771c025a9ad4ff006c91f912">h_h_mmult_horizontal_split</a> (<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;bc_tree)</td></tr>
<tr class="separator:a37ab8944771c025a9ad4ff006c91f912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b5ad565226b3547660248646358879"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a58b5ad565226b3547660248646358879">h_h_mmult_vertical_split</a> (<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;bc_tree)</td></tr>
<tr class="separator:a58b5ad565226b3547660248646358879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658a9b4b4ed09d69e0dd5e83a6b3a076"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a658a9b4b4ed09d69e0dd5e83a6b3a076">h_h_mmult_cross_split</a> (<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;bc_tree)</td></tr>
<tr class="separator:a658a9b4b4ed09d69e0dd5e83a6b3a076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa763338d356defaa27703af609c99ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#afa763338d356defaa27703af609c99ac">mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;bct_a, const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;bct_b, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;bct_c, const unsigned int fixed_rank=1)</td></tr>
<tr class="separator:afa763338d356defaa27703af609c99ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa956917ff6ea23e3cce01e575e0fe4b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa956917ff6ea23e3cce01e575e0fe4b1">mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;bct_a, const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;bct_b, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;bct_c, const unsigned int fixed_rank, const bool adding)</td></tr>
<tr class="separator:aa956917ff6ea23e3cce01e575e0fe4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1081a7c682ba916d9fe4aa9c39ccc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aca1081a7c682ba916d9fe4aa9c39ccc4">mmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:aca1081a7c682ba916d9fe4aa9c39ccc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803bffdbc9cae08918593254afccbb39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a803bffdbc9cae08918593254afccbb39">mmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a803bffdbc9cae08918593254afccbb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a1a1b175d315371967719b97772d19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a03a1a1b175d315371967719b97772d19">mmult_level_conserving_for_parallel_lu</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a03a1a1b175d315371967719b97772d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24219f800e4e43e658cb85c8a792a661"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a24219f800e4e43e658cb85c8a792a661">mTmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a24219f800e4e43e658cb85c8a792a661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b80a79d32414d2bd3fe24bc2891981a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a7b80a79d32414d2bd3fe24bc2891981a">mTmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a7b80a79d32414d2bd3fe24bc2891981a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9b5368ed1505c886ef3364ba148cbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aaf9b5368ed1505c886ef3364ba148cbd">mTmult_level_conserving_for_parallel_cholesky</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:aaf9b5368ed1505c886ef3364ba148cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff160828042444659db036ae2144a03d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aff160828042444659db036ae2144a03d">Tmmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:aff160828042444659db036ae2144a03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad342f70d049da229a7347b98e2a72d37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ad342f70d049da229a7347b98e2a72d37">Tmmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:ad342f70d049da229a7347b98e2a72d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f96186426cd3147d5af32ca84ad25ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">add</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k) const</td></tr>
<tr class="separator:a8f96186426cd3147d5af32ca84ad25ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea42f5112b88270fef73342853fa386d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aea42f5112b88270fef73342853fa386d">add</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, const Number b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k) const</td></tr>
<tr class="separator:aea42f5112b88270fef73342853fa386d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd48ada567962ab0dc75c31986bd1a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a9bd48ada567962ab0dc75c31986bd1a6">add</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k) const</td></tr>
<tr class="separator:a9bd48ada567962ab0dc75c31986bd1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42aaa86b9f47c5c1514e4f06e343db6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af42aaa86b9f47c5c1514e4f06e343db6">add</a> (const Number b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k) const</td></tr>
<tr class="separator:af42aaa86b9f47c5c1514e4f06e343db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05e22ca9cdc2131accd6a32e4f1dffe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac05e22ca9cdc2131accd6a32e4f1dffe">add</a> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;B, const std::array&lt; types::global_dof_index, 2 &gt; &amp;B_row_index_range, const std::array&lt; types::global_dof_index, 2 &gt; &amp;B_col_index_range, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k, const bool is_result_matrix_store_tril_only=false) const</td></tr>
<tr class="separator:ac05e22ca9cdc2131accd6a32e4f1dffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158984c444bbbb0b76e33fded6e1ab5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a158984c444bbbb0b76e33fded6e1ab5b">add_for_parallel_lu_or_cholesky</a> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;B, const std::array&lt; types::global_dof_index, 2 &gt; &amp;B_row_index_range, const std::array&lt; types::global_dof_index, 2 &gt; &amp;B_col_index_range, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a158984c444bbbb0b76e33fded6e1ab5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c14a1ea5579fd8a3b80aec78567cfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a76c14a1ea5579fd8a3b80aec78567cfb">add</a> (const Number b, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;B, const std::array&lt; types::global_dof_index, 2 &gt; &amp;B_row_index_range, const std::array&lt; types::global_dof_index, 2 &gt; &amp;B_col_index_range, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k, const bool is_result_matrix_store_tril_only=false) const</td></tr>
<tr class="separator:a76c14a1ea5579fd8a3b80aec78567cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d4010167d34c910836f2e40009fb6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a59d4010167d34c910836f2e40009fb6d">add</a> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a59d4010167d34c910836f2e40009fb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcce49f50f1c4490e4aeaa48e074b67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a3dcce49f50f1c4490e4aeaa48e074b67">add_for_parallel_lu_or_cholesky</a> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a3dcce49f50f1c4490e4aeaa48e074b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d58db68b297aa5da7f772354775b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a89d58db68b297aa5da7f772354775b3a">add</a> (const Number b, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k, const bool is_result_matrix_store_tril_only=false)</td></tr>
<tr class="separator:a89d58db68b297aa5da7f772354775b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72668962dbad336f0c289bbd060e6ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac72668962dbad336f0c289bbd060e6ce">addsym_diag</a> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;E)</td></tr>
<tr class="separator:ac72668962dbad336f0c289bbd060e6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403d72a5eea3912d67fd0807ddd0baf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a403d72a5eea3912d67fd0807ddd0baf8">add</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k)</td></tr>
<tr class="separator:a403d72a5eea3912d67fd0807ddd0baf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66071b53145fe007ac040fa0c4b47c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af66071b53145fe007ac040fa0c4b47c6">add</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, const Number b, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k)</td></tr>
<tr class="separator:af66071b53145fe007ac040fa0c4b47c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af972cb62d436b8dca5d95a5b6e2ed964"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af972cb62d436b8dca5d95a5b6e2ed964">invert_by_gauss_elim</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M_inv, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k)</td></tr>
<tr class="separator:af972cb62d436b8dca5d95a5b6e2ed964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee2443c3f85cd6a961e77e5287e43f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">solve_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;b, const bool is_unit_diagonal=true) const</td></tr>
<tr class="separator:aeee2443c3f85cd6a961e77e5287e43f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c226aaa96ad7b1a7f0c1507d43bba89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a4c226aaa96ad7b1a7f0c1507d43bba89">solve_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const bool is_unit_diagonal=true) const</td></tr>
<tr class="separator:a4c226aaa96ad7b1a7f0c1507d43bba89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d79f163311ae5390a58afc93cbeb29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae0d79f163311ae5390a58afc93cbeb29">solve_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat, const bool is_unit_diagonal=true) const</td></tr>
<tr class="separator:ae0d79f163311ae5390a58afc93cbeb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae066471c31c11d7a33b03f6374a28bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aae066471c31c11d7a33b03f6374a28bf">solve_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat, const bool is_unit_diagonal=true) const</td></tr>
<tr class="separator:aae066471c31c11d7a33b03f6374a28bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d490a19746c5ecf2dff44e8a865459"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ad5d490a19746c5ecf2dff44e8a865459">solve_by_forward_substitution_matrix_valued</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;X, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;<a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615a28de0ca7ea61d1edea9a803db4c0fa34">Z</a>, const unsigned int fixed_rank, const bool is_unit_diagonal=true) const</td></tr>
<tr class="separator:ad5d490a19746c5ecf2dff44e8a865459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17604ea8298c81150980ffd1a65e7249"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a17604ea8298c81150980ffd1a65e7249">solve_by_forward_substitution_matrix_valued</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;<a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615a28de0ca7ea61d1edea9a803db4c0fa34">Z</a>, const unsigned int fixed_rank, const bool is_unit_diagonal=true) const</td></tr>
<tr class="separator:a17604ea8298c81150980ffd1a65e7249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fa863c5b7f78be13dd3cbfd3780b92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac8fa863c5b7f78be13dd3cbfd3780b92">solve_cholesky_by_forward_substitution_matrix_valued</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;X, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;<a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615a28de0ca7ea61d1edea9a803db4c0fa34">Z</a>, const unsigned int fixed_rank) const</td></tr>
<tr class="separator:ac8fa863c5b7f78be13dd3cbfd3780b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb99ec3f920d4ba9e13d5e6597e26cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aaeb99ec3f920d4ba9e13d5e6597e26cf">solve_cholesky_by_forward_substitution_matrix_valued</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;<a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615a28de0ca7ea61d1edea9a803db4c0fa34">Z</a>, const unsigned int fixed_rank) const</td></tr>
<tr class="separator:aaeb99ec3f920d4ba9e13d5e6597e26cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624fc153099a20572a655457d4f81b70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a624fc153099a20572a655457d4f81b70">solve_transpose_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;b) const</td></tr>
<tr class="separator:a624fc153099a20572a655457d4f81b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f9bb1bc4e584fc5f29541be6b85ef1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a94f9bb1bc4e584fc5f29541be6b85ef1">solve_transpose_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b) const</td></tr>
<tr class="separator:a94f9bb1bc4e584fc5f29541be6b85ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42baae78ace516023e7c6cb79f2ffcdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a42baae78ace516023e7c6cb79f2ffcdb">solve_transpose_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat) const</td></tr>
<tr class="separator:a42baae78ace516023e7c6cb79f2ffcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e9f424455af6e874743e5c315c728b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab0e9f424455af6e874743e5c315c728b">solve_transpose_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat) const</td></tr>
<tr class="separator:ab0e9f424455af6e874743e5c315c728b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6532f857a821aa6f58087bb2b92b910f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6532f857a821aa6f58087bb2b92b910f">solve_transpose_by_forward_substitution_matrix_valued</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;X, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;<a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615a28de0ca7ea61d1edea9a803db4c0fa34">Z</a>, const unsigned int fixed_rank) const</td></tr>
<tr class="separator:a6532f857a821aa6f58087bb2b92b910f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbd5d02a1cf3df14dca830bf6118a62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a1fbd5d02a1cf3df14dca830bf6118a62">solve_transpose_by_forward_substitution_matrix_valued</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;<a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615a28de0ca7ea61d1edea9a803db4c0fa34">Z</a>, const unsigned int fixed_rank) const</td></tr>
<tr class="separator:a1fbd5d02a1cf3df14dca830bf6118a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae857d662e39096b416bbcef1a62c67b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae857d662e39096b416bbcef1a62c67b1">solve_cholesky_transpose_by_forward_substitution_matrix_valued</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;X, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;<a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615a28de0ca7ea61d1edea9a803db4c0fa34">Z</a>, const unsigned int fixed_rank) const</td></tr>
<tr class="separator:ae857d662e39096b416bbcef1a62c67b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa9ccfc3a44cd2b3b6e68845e78d2b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aeaa9ccfc3a44cd2b3b6e68845e78d2b4">solve_cholesky_transpose_by_forward_substitution_matrix_valued</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;<a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615a28de0ca7ea61d1edea9a803db4c0fa34">Z</a>, const unsigned int fixed_rank) const</td></tr>
<tr class="separator:aeaa9ccfc3a44cd2b3b6e68845e78d2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b64d4a5b7120a2599ec3e3e0708775"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab8b64d4a5b7120a2599ec3e3e0708775">solve_block_triangular_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;b, const bool is_unit_block_diagonal=true) const</td></tr>
<tr class="separator:ab8b64d4a5b7120a2599ec3e3e0708775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8046a87be454c81d4a884b53150685a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa8046a87be454c81d4a884b53150685a">solve_block_triangular_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const bool is_unit_block_diagonal=true) const</td></tr>
<tr class="separator:aa8046a87be454c81d4a884b53150685a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0436e9d29e57d1c4d69c6821b5a93519"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a0436e9d29e57d1c4d69c6821b5a93519">solve_block_triangular_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat, const bool is_unit_block_diagonal=true) const</td></tr>
<tr class="separator:a0436e9d29e57d1c4d69c6821b5a93519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b82f66044e334adea7eefac058f5f88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8b82f66044e334adea7eefac058f5f88">solve_block_triangular_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat, const bool is_unit_block_diagonal=true) const</td></tr>
<tr class="separator:a8b82f66044e334adea7eefac058f5f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09beb710b79d47e34ff3283424cf2a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a09beb710b79d47e34ff3283424cf2a22">solve_cholesky_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;b) const</td></tr>
<tr class="separator:a09beb710b79d47e34ff3283424cf2a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d32edbfaac9221dc5e219640c3ecd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a59d32edbfaac9221dc5e219640c3ecd3">solve_cholesky_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b) const</td></tr>
<tr class="separator:a59d32edbfaac9221dc5e219640c3ecd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8e5445922ed3d1313e87bd795e4f57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aff8e5445922ed3d1313e87bd795e4f57">solve_cholesky_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat) const</td></tr>
<tr class="separator:aff8e5445922ed3d1313e87bd795e4f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9406e2cb64246b738c0f4e10cd4eef9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac9406e2cb64246b738c0f4e10cd4eef9">solve_cholesky_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat) const</td></tr>
<tr class="separator:ac9406e2cb64246b738c0f4e10cd4eef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7231b00a53ef6b860d774d1daad738f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac7231b00a53ef6b860d774d1daad738f">solve_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;b, const bool is_unit_diagonal=false) const</td></tr>
<tr class="separator:ac7231b00a53ef6b860d774d1daad738f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89582b86090d18d33f7ae04deda1f5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab89582b86090d18d33f7ae04deda1f5f">solve_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const bool is_unit_diagonal=false) const</td></tr>
<tr class="separator:ab89582b86090d18d33f7ae04deda1f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f6334bf7f44c2351b4899c64344a23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af0f6334bf7f44c2351b4899c64344a23">solve_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat, const bool is_unit_diagonal=false) const</td></tr>
<tr class="separator:af0f6334bf7f44c2351b4899c64344a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059a847185207f9dff8a5b20b5498a2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a059a847185207f9dff8a5b20b5498a2b">solve_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat, const bool is_unit_diagonal=false) const</td></tr>
<tr class="separator:a059a847185207f9dff8a5b20b5498a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81db0ff79182302de83d693bab9f9e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa81db0ff79182302de83d693bab9f9e3">solve_block_triangular_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;b, const bool is_unit_block_diagonal=false) const</td></tr>
<tr class="separator:aa81db0ff79182302de83d693bab9f9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69432f004b60ade76aaabf2c94dd205c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a69432f004b60ade76aaabf2c94dd205c">solve_block_triangular_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const bool is_unit_block_diagonal=false) const</td></tr>
<tr class="separator:a69432f004b60ade76aaabf2c94dd205c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113c6b3209c415501f721bc55766d880"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a113c6b3209c415501f721bc55766d880">solve_block_triangular_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat, const bool is_unit_block_diagonal=false) const</td></tr>
<tr class="separator:a113c6b3209c415501f721bc55766d880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3f278df6f64dc3e140f5fbf47e42a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#adf3f278df6f64dc3e140f5fbf47e42a5">solve_block_triangular_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat, const bool is_unit_block_diagonal=false) const</td></tr>
<tr class="separator:adf3f278df6f64dc3e140f5fbf47e42a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054ad84d52a9ee6df9df3bda0a17cfb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a054ad84d52a9ee6df9df3bda0a17cfb7">solve_cholesky_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;b) const</td></tr>
<tr class="separator:a054ad84d52a9ee6df9df3bda0a17cfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880948492a7df252f3696219f6966703"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a880948492a7df252f3696219f6966703">solve_cholesky_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b) const</td></tr>
<tr class="separator:a880948492a7df252f3696219f6966703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ac0a0f9c4ac7d9383a210ee0165039"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a26ac0a0f9c4ac7d9383a210ee0165039">solve_cholesky_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat) const</td></tr>
<tr class="separator:a26ac0a0f9c4ac7d9383a210ee0165039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a92a883d001a278b042db59fa99eef6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8a92a883d001a278b042db59fa99eef6">solve_cholesky_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat) const</td></tr>
<tr class="separator:a8a92a883d001a278b042db59fa99eef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bf0581bcf6d1319b661d0f0527ffc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af2bf0581bcf6d1319b661d0f0527ffc9">compute_lu_factorization</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;LU, const unsigned int fixed_rank)</td></tr>
<tr class="separator:af2bf0581bcf6d1319b661d0f0527ffc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba14c63550f42d8a971beab340337b0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aba14c63550f42d8a971beab340337b0e">compute_lu_factorization</a> (const unsigned int fixed_rank)</td></tr>
<tr class="separator:aba14c63550f42d8a971beab340337b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8dcc2c66364c7d392792d98f770bf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#adb8dcc2c66364c7d392792d98f770bf8">compute_lu_factorization_task_parallel</a> (const unsigned int fixed_rank)</td></tr>
<tr class="separator:adb8dcc2c66364c7d392792d98f770bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61481fc8168b811c81e7cbc4da49cdc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a61481fc8168b811c81e7cbc4da49cdc1">compute_cholesky_factorization</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;L, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a61481fc8168b811c81e7cbc4da49cdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6e787e46fb082579b2d3aea1ad54f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#abc6e787e46fb082579b2d3aea1ad54f6">compute_cholesky_factorization</a> (const unsigned int fixed_rank)</td></tr>
<tr class="separator:abc6e787e46fb082579b2d3aea1ad54f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25e5d85a53b2f5e1bf035d5874dc04f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac25e5d85a53b2f5e1bf035d5874dc04f">compute_cholesky_factorization_task_parallel</a> (const unsigned int fixed_rank)</td></tr>
<tr class="separator:ac25e5d85a53b2f5e1bf035d5874dc04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e9dd55091e7eaed11ffb803321c49d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a83e9dd55091e7eaed11ffb803321c49d">solve_lu</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b) const</td></tr>
<tr class="separator:a83e9dd55091e7eaed11ffb803321c49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5582db8445ec15c69bc4bfdda19d547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac5582db8445ec15c69bc4bfdda19d547">solve_cholesky</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b) const</td></tr>
<tr class="separator:ac5582db8445ec15c69bc4bfdda19d547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f3890fdcdb796d2f262bb21589207d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa3f3890fdcdb796d2f262bb21589207d">coarsen_to_subtree</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;subtree, const unsigned int fixed_rank_k)</td></tr>
<tr class="separator:aa3f3890fdcdb796d2f262bb21589207d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa448c1380f54e5888c14a180e5156b29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa448c1380f54e5888c14a180e5156b29">coarsen_to_partition</a> (const std::vector&lt; typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt;::node_pointer_type &gt; &amp;partition, const unsigned int fixed_rank_k)</td></tr>
<tr class="separator:aa448c1380f54e5888c14a180e5156b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9333fe8b56012040aa375723b533273"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ad9333fe8b56012040aa375723b533273">link_hmat_nodes_on_same_levels</a> ()</td></tr>
<tr class="separator:ad9333fe8b56012040aa375723b533273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebe19839b8649eb14e8156b37e069fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a2ebe19839b8649eb14e8156b37e069fb">link_hmat_nodes_on_cross_from_diagonal_blocks</a> (const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property)</td></tr>
<tr class="separator:a2ebe19839b8649eb14e8156b37e069fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f8da3a2d1666a610cb7a7912c6c09f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a22f8da3a2d1666a610cb7a7912c6c09f">get_top_left_leaf_node</a> ()</td></tr>
<tr class="memdesc:a22f8da3a2d1666a610cb7a7912c6c09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the top left leaf node in the \(\mathcal{H}\)-matrix.  <a href="classHMatrix.html#a22f8da3a2d1666a610cb7a7912c6c09f">More...</a><br /></td></tr>
<tr class="separator:a22f8da3a2d1666a610cb7a7912c6c09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b6a6e858acc668f762d3ac85d79e6d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ad6b6a6e858acc668f762d3ac85d79e6d">get_top_left_leaf_node</a> () const</td></tr>
<tr class="memdesc:ad6b6a6e858acc668f762d3ac85d79e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the top left leaf node in the \(\mathcal{H}\)-matrix.  <a href="classHMatrix.html#ad6b6a6e858acc668f762d3ac85d79e6d">More...</a><br /></td></tr>
<tr class="separator:ad6b6a6e858acc668f762d3ac85d79e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139f32982527ba981e0211b5663e3b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">build_leaf_set</a> ()</td></tr>
<tr class="separator:a139f32982527ba981e0211b5663e3b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c9102fc04997c1ae3627185379d9bb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac5c9102fc04997c1ae3627185379d9bb">get_leaf_set</a> ()</td></tr>
<tr class="separator:ac5c9102fc04997c1ae3627185379d9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851d7bb3632bc1d18538d4d1dd5f6393"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a851d7bb3632bc1d18538d4d1dd5f6393">get_leaf_set</a> () const</td></tr>
<tr class="separator:a851d7bb3632bc1d18538d4d1dd5f6393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99d7f686a41528a537a9857140c260c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae99d7f686a41528a537a9857140c260c">get_near_field_leaf_set</a> ()</td></tr>
<tr class="separator:ae99d7f686a41528a537a9857140c260c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a2c595359811a343c9a119035d7dc8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a38a2c595359811a343c9a119035d7dc8">get_near_field_leaf_set</a> () const</td></tr>
<tr class="separator:a38a2c595359811a343c9a119035d7dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa499c9af9db42304394a8972e0950eb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#afa499c9af9db42304394a8972e0950eb">get_far_field_leaf_set</a> ()</td></tr>
<tr class="separator:afa499c9af9db42304394a8972e0950eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cb754d4623b62920a6ece5d388f1d6"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a48cb754d4623b62920a6ece5d388f1d6">get_far_field_leaf_set</a> () const</td></tr>
<tr class="separator:a48cb754d4623b62920a6ece5d388f1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d44c2527bc4a6230bf9b08d6cb2caf"><td class="memItemLeft" align="right" valign="top">std::array&lt; types::global_dof_index, 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a21d44c2527bc4a6230bf9b08d6cb2caf">get_row_index_range</a> ()</td></tr>
<tr class="separator:a21d44c2527bc4a6230bf9b08d6cb2caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0363e92bb29490faf47f013b1a2364"><td class="memItemLeft" align="right" valign="top">const std::array&lt; types::global_dof_index, 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8c0363e92bb29490faf47f013b1a2364">get_row_index_range</a> () const</td></tr>
<tr class="separator:a8c0363e92bb29490faf47f013b1a2364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a975c2033a702d47dd4c7e91d66811e"><td class="memItemLeft" align="right" valign="top">std::array&lt; types::global_dof_index, 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a4a975c2033a702d47dd4c7e91d66811e">get_col_index_range</a> ()</td></tr>
<tr class="separator:a4a975c2033a702d47dd4c7e91d66811e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8a1f31650cc5bed4cb2a88aca0e354"><td class="memItemLeft" align="right" valign="top">const std::array&lt; types::global_dof_index, 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8e8a1f31650cc5bed4cb2a88aca0e354">get_col_index_range</a> () const</td></tr>
<tr class="separator:a8e8a1f31650cc5bed4cb2a88aca0e354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb19e987450fc02acea91dffd237e0a0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aeb19e987450fc02acea91dffd237e0a0">find_block_cluster_in_leaf_set</a> (const <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, real_type &gt; &amp;block_cluster)</td></tr>
<tr class="separator:aeb19e987450fc02acea91dffd237e0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9e10d11ac2c5a929854ac7b3b15ad1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a4d9e10d11ac2c5a929854ac7b3b15ad1">find_block_cluster_in_leaf_set</a> (const <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, real_type &gt; &amp;block_cluster) const</td></tr>
<tr class="separator:a4d9e10d11ac2c5a929854ac7b3b15ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b353962226c78910d6ddb6b5b8e460"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ad2b353962226c78910d6ddb6b5b8e460">refine_to_supertree</a> ()</td></tr>
<tr class="separator:ad2b353962226c78910d6ddb6b5b8e460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f1f56d79630de7c254bba1a5bdc82d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a82f1f56d79630de7c254bba1a5bdc82d">convert_between_different_block_cluster_trees</a> (<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;bct1, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;bct2, const unsigned int fixed_rank_k2=1)</td></tr>
<tr class="separator:a82f1f56d79630de7c254bba1a5bdc82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e023f39b1f8916117a63557895a91b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a9e023f39b1f8916117a63557895a91b4">remove_hmat_pair_from_mm_product_list</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M2)</td></tr>
<tr class="separator:a9e023f39b1f8916117a63557895a91b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f7b64b8d16939811a923060c29ec88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa3f7b64b8d16939811a923060c29ec88">remove_hmat_pair_from_mm_product_list</a> (const std::pair&lt; const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;hmat_pair)</td></tr>
<tr class="separator:aa3f7b64b8d16939811a923060c29ec88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f24998c7de1d0e336577be41c6281e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tree_8h.html#a922ca07db9633957939f697a65aff11d">TreeNodeSplitMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6f24998c7de1d0e336577be41c6281e3">determine_mm_split_mode_from_Sigma_P</a> ()</td></tr>
<tr class="separator:a6f24998c7de1d0e336577be41c6281e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a396e5a5035c4d4637c99cff9825ac5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a0a396e5a5035c4d4637c99cff9825ac5">memory_consumption_of_current_hmat_node</a> () const</td></tr>
<tr class="separator:a0a396e5a5035c4d4637c99cff9825ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8cd16d63388b514c016eb998d7e902"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#adb8cd16d63388b514c016eb998d7e902">memory_consumption</a> () const</td></tr>
<tr class="separator:adb8cd16d63388b514c016eb998d7e902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30c2033a1fe84c92029044aecb48926"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab30c2033a1fe84c92029044aecb48926">memory_consumption_of_leaf_set</a> () const</td></tr>
<tr class="separator:ab30c2033a1fe84c92029044aecb48926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c439e1d5d4ac0b1a939197031b73dc"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab1c439e1d5d4ac0b1a939197031b73dc">memory_consumption_of_near_field_leaf_set</a> () const</td></tr>
<tr class="separator:ab1c439e1d5d4ac0b1a939197031b73dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacba927cf5e79d0fe36ba73b710dd509"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aacba927cf5e79d0fe36ba73b710dd509">memory_consumption_of_far_field_leaf_set</a> () const</td></tr>
<tr class="separator:aacba927cf5e79d0fe36ba73b710dd509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e55fd99889f299478358b58855bda4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a49e55fd99889f299478358b58855bda4">compute_leaf_set_vmult_or_Tvmult_task_costs</a> (std::vector&lt; double &gt; &amp;task_costs) const</td></tr>
<tr class="separator:a49e55fd99889f299478358b58855bda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad8511dd6d1ff5081b9a6c69d8aa009"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a7ad8511dd6d1ff5081b9a6c69d8aa009">compute_near_field_leaf_set_assembly_task_costs</a> (std::vector&lt; double &gt; &amp;task_costs) const</td></tr>
<tr class="separator:a7ad8511dd6d1ff5081b9a6c69d8aa009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d1df9f94ee28a79ef528879090e3b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac0d1df9f94ee28a79ef528879090e3b5">compute_far_field_leaf_set_assembly_task_costs</a> (std::vector&lt; double &gt; &amp;task_costs) const</td></tr>
<tr class="separator:ac0d1df9f94ee28a79ef528879090e3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababd28a7322d6c3accef139c56636c9f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ababd28a7322d6c3accef139c56636c9f">compute_vmult_or_tvmult_thread_num</a> (const bool is_vmult, const bool is_tvmult) const</td></tr>
<tr class="separator:ababd28a7322d6c3accef139c56636c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae170394e8f48f5b99d4cc4f7954dfdec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae170394e8f48f5b99d4cc4f7954dfdec">prepare_for_vmult_or_tvmult</a> (const bool is_vmult, const bool is_tvmult)</td></tr>
<tr class="separator:ae170394e8f48f5b99d4cc4f7954dfdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a85e034ae910d91c3c46fc2028bdc5e18"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a85e034ae910d91c3c46fc2028bdc5e18">set_leaf_set_traversal_method</a> (const <a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615">SpaceFillingCurveType</a> <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">type</a>)</td></tr>
<tr class="separator:a85e034ae910d91c3c46fc2028bdc5e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8b5a9fb65c716187d95bcdb43542884c"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8b5a9fb65c716187d95bcdb43542884c">submatrix_index_invalid</a> = 9</td></tr>
<tr class="separator:a8b5a9fb65c716187d95bcdb43542884c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a866f076c7c0535e6d824505ac4f58e96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a866f076c7c0535e6d824505ac4f58e96">assign_node_ids_for_dot</a> ()</td></tr>
<tr class="separator:a866f076c7c0535e6d824505ac4f58e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8e08ec263ea524bef3c5c66796c61d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#afd8e08ec263ea524bef3c5c66796c61d">_print_matrix_info_as_dot_node</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:afd8e08ec263ea524bef3c5c66796c61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f87f1cd5637e27b33c02aec0dbbfbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ad7f87f1cd5637e27b33c02aec0dbbfbe">set_property_for_converted_fullmatrix</a> (<a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M) const</td></tr>
<tr class="separator:ad7f87f1cd5637e27b33c02aec0dbbfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0510ed1e0356059a449d01ba3182fb1d"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a0510ed1e0356059a449d01ba3182fb1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a0510ed1e0356059a449d01ba3182fb1d">_convertToFullMatrix</a> (MatrixType &amp;M, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property=HMatrixSupport::Property::general) const</td></tr>
<tr class="separator:a0510ed1e0356059a449d01ba3182fb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74438781b4a0e1b3b1a3102200f468f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a74438781b4a0e1b3b1a3102200f468f1">is_current_hmat_node_nonemtpy</a> (const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property=HMatrixSupport::Property::general) const</td></tr>
<tr class="separator:a74438781b4a0e1b3b1a3102200f468f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8a3448bc2a3ec0b80eb0c52fc4c16d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#add8a3448bc2a3ec0b80eb0c52fc4c16d">_build_leaf_set_z_traversal</a> (std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a> * &gt; &amp;total_leaf_set, std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a> * &gt; &amp;total_near_field_leaf_set, std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a> * &gt; &amp;total_far_field_leaf_set, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:add8a3448bc2a3ec0b80eb0c52fc4c16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651ac10b059076f48a7cfbd3adceb125"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a651ac10b059076f48a7cfbd3adceb125">_build_leaf_set_hilbert_traversal</a> (std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a> * &gt; &amp;total_leaf_set, std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a> * &gt; &amp;total_near_field_leaf_set, std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a> * &gt; &amp;total_far_field_leaf_set, <a class="el" href="classHMatrix.html#afaff6be3787ae9ecebd8cb53868ae65b">HilbertBlockType</a> current_hilbert_block_type, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:a651ac10b059076f48a7cfbd3adceb125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66979dbdf56155c63f0706649e8545b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a66979dbdf56155c63f0706649e8545b9">distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves</a> (const unsigned int fixed_rank=0)</td></tr>
<tr class="separator:a66979dbdf56155c63f0706649e8545b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e24569fe32027c840b160f9dcd1ad7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a39e24569fe32027c840b160f9dcd1ad7">distribute_sigma_r_and_f_to_leaves</a> (const unsigned int fixed_rank=0)</td></tr>
<tr class="separator:a39e24569fe32027c840b160f9dcd1ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187e0c009a7c28679df7e92e0b01929c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a187e0c009a7c28679df7e92e0b01929c">_distribute_sigma_r_and_f_to_leaves</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat, const unsigned int fixed_rank=0)</td></tr>
<tr class="separator:a187e0c009a7c28679df7e92e0b01929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74e3b0c19e9178cfe699a6620a51170"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af74e3b0c19e9178cfe699a6620a51170">_invert_by_gauss_elim</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M_inv, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k)</td></tr>
<tr class="separator:af74e3b0c19e9178cfe699a6620a51170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae706d9ed5f2a0ad239624294efd81b81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae706d9ed5f2a0ad239624294efd81b81">_compute_lu_factorization</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;LU, const unsigned int fixed_rank) const</td></tr>
<tr class="separator:ae706d9ed5f2a0ad239624294efd81b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e36fb4ecad2198fbf4cc612ea47132"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac9e36fb4ecad2198fbf4cc612ea47132">_compute_lu_factorization</a> (const unsigned int fixed_rank)</td></tr>
<tr class="separator:ac9e36fb4ecad2198fbf4cc612ea47132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad564d02c7ee36f644e684ad20fec3cec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ad564d02c7ee36f644e684ad20fec3cec">compute_lu_dag</a> (tbb::flow::graph &amp;dag, const unsigned int fixed_rank, std::mutex &amp;log_stream_lock)</td></tr>
<tr class="separator:ad564d02c7ee36f644e684ad20fec3cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bf4feff6b7c2dc0f32d3eb4868a6a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a62bf4feff6b7c2dc0f32d3eb4868a6a9">lu_factorize_diagonal_block_task</a> (tbb::flow::graph &amp;dag, std::mutex &amp;log_stream_lock)</td></tr>
<tr class="separator:a62bf4feff6b7c2dc0f32d3eb4868a6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca060b26379cd6f346f7c7befe814bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#abca060b26379cd6f346f7c7befe814bf">lu_solve_upper_task</a> (tbb::flow::graph &amp;dag, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;<a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615a28de0ca7ea61d1edea9a803db4c0fa34">Z</a>, const unsigned int fixed_rank, std::mutex &amp;log_stream_lock)</td></tr>
<tr class="separator:abca060b26379cd6f346f7c7befe814bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18244798da62ef79736267a31e8b7e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab18244798da62ef79736267a31e8b7e5">lu_solve_lower_task</a> (tbb::flow::graph &amp;dag, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;<a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615a28de0ca7ea61d1edea9a803db4c0fa34">Z</a>, const unsigned int fixed_rank, std::mutex &amp;log_stream_lock)</td></tr>
<tr class="separator:ab18244798da62ef79736267a31e8b7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6d48cb0d859820ac38df388f991911"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ade6d48cb0d859820ac38df388f991911">lu_update_task</a> (tbb::flow::graph &amp;dag, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;diag_block, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;diag_column_block, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;diag_row_block, const unsigned int fixed_rank, std::mutex &amp;log_stream_lock)</td></tr>
<tr class="separator:ade6d48cb0d859820ac38df388f991911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54cb4e40086a5ac8d1effac05ab64fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac54cb4e40086a5ac8d1effac05ab64fe">lu_or_cholesky_build_solve_upper_to_update_dependencies</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;update_block)</td></tr>
<tr class="separator:ac54cb4e40086a5ac8d1effac05ab64fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7ccd8a95c9af8331f2491bd84121a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a7a7ccd8a95c9af8331f2491bd84121a3">lu_build_solve_lower_to_update_dependencies</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;update_block)</td></tr>
<tr class="separator:a7a7ccd8a95c9af8331f2491bd84121a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae964afb855e244317f9b68df774c0113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae964afb855e244317f9b68df774c0113">lu_build_update_to_factorize_dependencies</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;factorize_block)</td></tr>
<tr class="separator:ae964afb855e244317f9b68df774c0113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8d00d75e5238f237d15bc8ba5345dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a1f8d00d75e5238f237d15bc8ba5345dd">lu_build_update_to_solve_upper_or_lower_dependencies</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;solve_upper_or_lower_block)</td></tr>
<tr class="separator:a1f8d00d75e5238f237d15bc8ba5345dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296b3d77a2a9ccb78e76085d2ffda8e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a296b3d77a2a9ccb78e76085d2ffda8e5">lu_assign_update_to_solve_and_factorize_dependencies</a> ()</td></tr>
<tr class="separator:a296b3d77a2a9ccb78e76085d2ffda8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369057ef4f20f12494faa8261cbaf233"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a369057ef4f20f12494faa8261cbaf233">_compute_cholesky_factorization</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;L, const unsigned int fixed_rank) const</td></tr>
<tr class="separator:a369057ef4f20f12494faa8261cbaf233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695ef43b376e704f3436447d3fda24de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a695ef43b376e704f3436447d3fda24de">_compute_cholesky_factorization</a> (const unsigned int fixed_rank)</td></tr>
<tr class="separator:a695ef43b376e704f3436447d3fda24de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e028a99709e896e6d922d4bb67ca09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab1e028a99709e896e6d922d4bb67ca09">compute_cholesky_dag</a> (tbb::flow::graph &amp;dag, const unsigned int fixed_rank, std::mutex &amp;log_stream_lock)</td></tr>
<tr class="separator:ab1e028a99709e896e6d922d4bb67ca09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7c81260b52fba9ef1be63e180e43c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#afe7c81260b52fba9ef1be63e180e43c5">cholesky_factorize_diagonal_block_task</a> (tbb::flow::graph &amp;dag, std::mutex &amp;log_stream_lock)</td></tr>
<tr class="separator:afe7c81260b52fba9ef1be63e180e43c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009b339cb4be6fa51afa70d6f9d06c2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a009b339cb4be6fa51afa70d6f9d06c2d">cholesky_solve_upper_task</a> (tbb::flow::graph &amp;dag, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;<a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615a28de0ca7ea61d1edea9a803db4c0fa34">Z</a>, const unsigned int fixed_rank, std::mutex &amp;log_stream_lock)</td></tr>
<tr class="separator:a009b339cb4be6fa51afa70d6f9d06c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12633037763ee8ea288bd881545c2069"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a12633037763ee8ea288bd881545c2069">cholesky_update_task</a> (tbb::flow::graph &amp;dag, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;diag_block, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;diag_column_block1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;diag_column_block2, const unsigned int fixed_rank, std::mutex &amp;log_stream_lock)</td></tr>
<tr class="separator:a12633037763ee8ea288bd881545c2069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4073e87db371d706761a861b229119"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a1d4073e87db371d706761a861b229119">cholesky_build_update_to_factorize_dependencies</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;factorize_block)</td></tr>
<tr class="separator:a1d4073e87db371d706761a861b229119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bbad9065a8ade27dda7f5d95514272"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a41bbad9065a8ade27dda7f5d95514272">cholesky_build_update_to_solve_upper_dependencies</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;solve_upper_block)</td></tr>
<tr class="separator:a41bbad9065a8ade27dda7f5d95514272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34153f643b74f566e992a24c7ec7be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab34153f643b74f566e992a24c7ec7be0">cholesky_assign_update_to_solve_and_factorize_dependencies</a> ()</td></tr>
<tr class="separator:ab34153f643b74f566e992a24c7ec7be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace629d5a578f32a43d94d2e51f9a53f0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ace629d5a578f32a43d94d2e51f9a53f0">compute_near_field_hmat_vmult_or_Tvmult_task_cost</a> (const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:ace629d5a578f32a43d94d2e51f9a53f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513a0cad5bbafc39bf82c260de2ec2a0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a513a0cad5bbafc39bf82c260de2ec2a0">compute_far_field_hmat_vmult_or_Tvmult_task_cost</a> (const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:a513a0cad5bbafc39bf82c260de2ec2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485b984ec9eb3a3f1e1dc309f5c3725a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a485b984ec9eb3a3f1e1dc309f5c3725a">compute_near_field_hmat_assembly_task_cost</a> (const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:a485b984ec9eb3a3f1e1dc309f5c3725a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb916719c90a396362ae2bddfbbe0dc5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#afb916719c90a396362ae2bddfbbe0dc5">compute_far_field_hmat_assembly_task_cost</a> (const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_property) const</td></tr>
<tr class="separator:afb916719c90a396362ae2bddfbbe0dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b8a7933d2ee304a6e26cdef0e93347"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af1b8a7933d2ee304a6e26cdef0e93347">get_row_index_range_for_leaf_set_interval</a> (const std::pair&lt; int64_t, int64_t &gt; &amp;interval, const unsigned int thread_no)</td></tr>
<tr class="separator:af1b8a7933d2ee304a6e26cdef0e93347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704afe558efd60e34c9cb1643293b40d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a704afe558efd60e34c9cb1643293b40d">get_column_index_range_for_leaf_set_interval</a> (const std::pair&lt; int64_t, int64_t &gt; &amp;interval, const unsigned int thread_no)</td></tr>
<tr class="separator:a704afe558efd60e34c9cb1643293b40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60be54e6d0592fb8f4e727ad490fd867"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a60be54e6d0592fb8f4e727ad490fd867">compute_vmult_contributing_index_ranges_from_all_threads</a> (const unsigned int thread_no)</td></tr>
<tr class="separator:a60be54e6d0592fb8f4e727ad490fd867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1442eeae359cb7f9cbcf70c2c92ae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6a1442eeae359cb7f9cbcf70c2c92ae4">compute_tvmult_contributing_index_ranges_from_all_threads</a> (const unsigned int thread_no)</td></tr>
<tr class="separator:a6a1442eeae359cb7f9cbcf70c2c92ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a89ef60f3ba737c04708195ca0bb13620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">type</a></td></tr>
<tr class="separator:a89ef60f3ba737c04708195ca0bb13620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab504bacb27635c8962c8e58eba943e6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hmatrix__support_8h.html#a8358c4882bca00f7e887d9b44e633aa0">HMatrixSupport::State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab504bacb27635c8962c8e58eba943e6b">state</a></td></tr>
<tr class="separator:ab504bacb27635c8962c8e58eba943e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef60ed63bd5b247116ce42cbb74e9b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#afef60ed63bd5b247116ce42cbb74e9b4">property</a></td></tr>
<tr class="separator:afef60ed63bd5b247116ce42cbb74e9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2930c9ef5832e01cc98b3cb03b9a91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6d2930c9ef5832e01cc98b3cb03b9a91">block_type</a></td></tr>
<tr class="separator:a6d2930c9ef5832e01cc98b3cb03b9a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1fa017f02f9e961774f31200ab65b8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classHMatrixVmultStrategy.html">HMatrixVmultStrategy</a>&lt; spacedim, Number &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aab1fa017f02f9e961774f31200ab65b8">vmult_strategy</a></td></tr>
<tr class="separator:aab1fa017f02f9e961774f31200ab65b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca26797a5d41fb0fb0a6f1f3b7817870"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aca26797a5d41fb0fb0a6f1f3b7817870">dot_node_id</a></td></tr>
<tr class="separator:aca26797a5d41fb0fb0a6f1f3b7817870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd1b9a32f2c7693e603a7c6ea916e4f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">submatrices</a></td></tr>
<tr class="separator:a4bd1b9a32f2c7693e603a7c6ea916e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71690997092a4142799b2fa2dbf53db4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">parent</a></td></tr>
<tr class="separator:a71690997092a4142799b2fa2dbf53db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e832b2b0ba418aed92692535aaa2cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa2e832b2b0ba418aed92692535aaa2cc">next_same_level_hmat_node</a></td></tr>
<tr class="separator:aa2e832b2b0ba418aed92692535aaa2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c0e3b27396d3d9120b2514f94cdb2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a50c0e3b27396d3d9120b2514f94cdb2e">next_same_level_same_row_hmat_node</a></td></tr>
<tr class="separator:a50c0e3b27396d3d9120b2514f94cdb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7a717c26b61c24c0a6347f958edc74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#abd7a717c26b61c24c0a6347f958edc74">next_same_level_same_column_hmat_node</a></td></tr>
<tr class="separator:abd7a717c26b61c24c0a6347f958edc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18aa785af706bad34c48883ce005c5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa18aa785af706bad34c48883ce005c5d">previous_same_level_same_row_hmat_node</a></td></tr>
<tr class="separator:aa18aa785af706bad34c48883ce005c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08561fd6dcd930b65fe0f2ffc77bc818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a08561fd6dcd930b65fe0f2ffc77bc818">previous_same_level_same_column_hmat_node</a></td></tr>
<tr class="separator:a08561fd6dcd930b65fe0f2ffc77bc818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c851dd63ba1a466c19f451be369475"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">submatrix_index</a></td></tr>
<tr class="separator:a64c851dd63ba1a466c19f451be369475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dbd471077be0ad8325d0f2afe3d43f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">leaf_set</a></td></tr>
<tr class="separator:a61dbd471077be0ad8325d0f2afe3d43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6816bb6905d4cce96eacaa1f6593e130"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6816bb6905d4cce96eacaa1f6593e130">near_field_leaf_set</a></td></tr>
<tr class="separator:a6816bb6905d4cce96eacaa1f6593e130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df8e2ca7b4d35778bc4e5fcd6f706f1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6df8e2ca7b4d35778bc4e5fcd6f706f1">far_field_leaf_set</a></td></tr>
<tr class="separator:a6df8e2ca7b4d35778bc4e5fcd6f706f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97a8f5e42aba0f1d5faf41f35a27819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">rkmatrix</a></td></tr>
<tr class="separator:aa97a8f5e42aba0f1d5faf41f35a27819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328134c9e9cb2c4b05d5431c0ca8a533"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">fullmatrix</a></td></tr>
<tr class="separator:a328134c9e9cb2c4b05d5431c0ca8a533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc153ec757cd8fecdeca2274e1ed5a27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt;::node_pointer_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#acc153ec757cd8fecdeca2274e1ed5a27">bc_node</a></td></tr>
<tr class="separator:acc153ec757cd8fecdeca2274e1ed5a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fee69a46f53bb4fd168d6ff1e27a53a"><td class="memItemLeft" align="right" valign="top">std::array&lt; types::global_dof_index, 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6fee69a46f53bb4fd168d6ff1e27a53a">row_index_range</a></td></tr>
<tr class="separator:a6fee69a46f53bb4fd168d6ff1e27a53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fad92358cff261c113af5bd29ac9caf"><td class="memItemLeft" align="right" valign="top">std::array&lt; types::global_dof_index, 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6fad92358cff261c113af5bd29ac9caf">col_index_range</a></td></tr>
<tr class="separator:a6fad92358cff261c113af5bd29ac9caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5523463043e4d542eae17d262bd22ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">m</a></td></tr>
<tr class="separator:aa5523463043e4d542eae17d262bd22ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ae2eb472f81f80653ed4411629c2d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">n</a></td></tr>
<tr class="separator:ab5ae2eb472f81f80653ed4411629c2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7492f731ddeb720c3ff810e07fd64546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a7492f731ddeb720c3ff810e07fd64546">Tind</a></td></tr>
<tr class="separator:a7492f731ddeb720c3ff810e07fd64546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d96d0252ef8c873ae06cf87874acaf3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">Sigma_P</a></td></tr>
<tr class="separator:a3d96d0252ef8c873ae06cf87874acaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d341b4e606d1be2d71b8ea636efe7b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">Sigma_R</a></td></tr>
<tr class="separator:a04d341b4e606d1be2d71b8ea636efe7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa659b6df63d533432ec1a24435cd9c40"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">Sigma_F</a></td></tr>
<tr class="separator:aa659b6df63d533432ec1a24435cd9c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018c8f03c2e151d821067329262b368d"><td class="memItemLeft" align="right" valign="top">TaskNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a018c8f03c2e151d821067329262b368d">factorize_lu_or_cholesky_graph_node</a></td></tr>
<tr class="separator:a018c8f03c2e151d821067329262b368d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4d781e9ee655382013b16e3c4943c1"><td class="memItemLeft" align="right" valign="top">TaskNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a4a4d781e9ee655382013b16e3c4943c1">solve_upper_or_lower_lu_or_cholesky_graph_node</a></td></tr>
<tr class="separator:a4a4d781e9ee655382013b16e3c4943c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544b5099a50c5e911447382b5a62e651"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix_1_1UpdateTaskNodeForLUOrCholesky.html">UpdateTaskNodeForLUOrCholesky</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a544b5099a50c5e911447382b5a62e651">update_lu_or_cholesky_graph_nodes</a></td></tr>
<tr class="separator:a544b5099a50c5e911447382b5a62e651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6428e132a07e029b058d838feee19755"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6428e132a07e029b058d838feee19755">update_lock</a></td></tr>
<tr class="separator:a6428e132a07e029b058d838feee19755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab828dc70638fae2b3a4343389cbf09cf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; std::vector&lt; <a class="el" href="structHMatrix_1_1VmultOrTvmultThreadData.html">VmultOrTvmultThreadData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab828dc70638fae2b3a4343389cbf09cf">data_for_vmult_or_tvmult_threads</a></td></tr>
<tr class="separator:ab828dc70638fae2b3a4343389cbf09cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:aa2f41977cbee7201a4e97ad304f66358"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615">SpaceFillingCurveType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa2f41977cbee7201a4e97ad304f66358">leaf_set_traversal_method</a></td></tr>
<tr class="separator:aa2f41977cbee7201a4e97ad304f66358"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a164958e28d4db4562017a63c63158a81"><td class="memTemplParams" colspan="2"><a id="a164958e28d4db4562017a63c63158a81" name="a164958e28d4db4562017a63c63158a81"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a164958e28d4db4562017a63c63158a81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitHMatrixWrtBlockClusterNode</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, typename numbers::NumberTraits&lt; Number1 &gt;::real_type &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#acc153ec757cd8fecdeca2274e1ed5a27">bc_node</a>)</td></tr>
<tr class="separator:a164958e28d4db4562017a63c63158a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4252a946854a56b78554874f90994718"><td class="memTemplParams" colspan="2"><a id="a4252a946854a56b78554874f90994718" name="a4252a946854a56b78554874f90994718"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a4252a946854a56b78554874f90994718"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitHMatrixWrtBlockClusterNode</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, typename numbers::NumberTraits&lt; Number1 &gt;::real_type &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#acc153ec757cd8fecdeca2274e1ed5a27">bc_node</a>, const std::vector&lt; std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; * &gt; &gt; &amp;<a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">Sigma_P</a>)</td></tr>
<tr class="separator:a4252a946854a56b78554874f90994718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d1476f52c951c00dea55f8b2ccf29c"><td class="memTemplParams" colspan="2"><a id="a97d1476f52c951c00dea55f8b2ccf29c" name="a97d1476f52c951c00dea55f8b2ccf29c"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a97d1476f52c951c00dea55f8b2ccf29c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitHMatrixWrtBlockClusterNode</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, typename numbers::NumberTraits&lt; Number1 &gt;::real_type &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#acc153ec757cd8fecdeca2274e1ed5a27">bc_node</a>, const std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; * &gt; &amp;hmat_pair)</td></tr>
<tr class="separator:a97d1476f52c951c00dea55f8b2ccf29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21339b2184070226335135fd3379198"><td class="memTemplParams" colspan="2"><a id="ab21339b2184070226335135fd3379198" name="ab21339b2184070226335135fd3379198"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ab21339b2184070226335135fd3379198"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildrenWithoutAlloc</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, typename numbers::NumberTraits&lt; Number1 &gt;::real_type &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#acc153ec757cd8fecdeca2274e1ed5a27">bc_node</a>)</td></tr>
<tr class="separator:ab21339b2184070226335135fd3379198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507d1c2aae497f17a7fa684be0790f16"><td class="memTemplParams" colspan="2"><a id="a507d1c2aae497f17a7fa684be0790f16" name="a507d1c2aae497f17a7fa684be0790f16"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a507d1c2aae497f17a7fa684be0790f16"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildren</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, typename numbers::NumberTraits&lt; Number1 &gt;::real_type &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#acc153ec757cd8fecdeca2274e1ed5a27">bc_node</a>, const unsigned int fixed_rank_k, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_node_property)</td></tr>
<tr class="separator:a507d1c2aae497f17a7fa684be0790f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4269e65220121bfaa2121b7f1395a2c1"><td class="memTemplParams" colspan="2"><a id="a4269e65220121bfaa2121b7f1395a2c1" name="a4269e65220121bfaa2121b7f1395a2c1"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a4269e65220121bfaa2121b7f1395a2c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildren</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, typename numbers::NumberTraits&lt; Number1 &gt;::real_type &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#acc153ec757cd8fecdeca2274e1ed5a27">bc_node</a>, const unsigned int fixed_rank_k, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_node_property)</td></tr>
<tr class="separator:a4269e65220121bfaa2121b7f1395a2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f921f9c75a807bb5fa167b27db7097"><td class="memTemplParams" colspan="2"><a id="a57f921f9c75a807bb5fa167b27db7097" name="a57f921f9c75a807bb5fa167b27db7097"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a57f921f9c75a807bb5fa167b27db7097"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildren</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, typename numbers::NumberTraits&lt; Number1 &gt;::real_type &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#acc153ec757cd8fecdeca2274e1ed5a27">bc_node</a>, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_node_property)</td></tr>
<tr class="separator:a57f921f9c75a807bb5fa167b27db7097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d71548a34dbb55c0ad05caba9ee0068"><td class="memTemplParams" colspan="2"><a id="a3d71548a34dbb55c0ad05caba9ee0068" name="a3d71548a34dbb55c0ad05caba9ee0068"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a3d71548a34dbb55c0ad05caba9ee0068"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildren</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, typename numbers::NumberTraits&lt; Number1 &gt;::real_type &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#acc153ec757cd8fecdeca2274e1ed5a27">bc_node</a>, const unsigned int fixed_rank_k, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M, const std::array&lt; types::global_dof_index, 2 &gt; &amp;M_row_index_range, const std::array&lt; types::global_dof_index, 2 &gt; &amp;M_col_index_range, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_node_property)</td></tr>
<tr class="separator:a3d71548a34dbb55c0ad05caba9ee0068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4657e8432ee8b3778fb4bced08dba133"><td class="memTemplParams" colspan="2"><a id="a4657e8432ee8b3778fb4bced08dba133" name="a4657e8432ee8b3778fb4bced08dba133"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a4657e8432ee8b3778fb4bced08dba133"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildren</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, typename numbers::NumberTraits&lt; Number1 &gt;::real_type &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#acc153ec757cd8fecdeca2274e1ed5a27">bc_node</a>, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M, const std::array&lt; types::global_dof_index, 2 &gt; &amp;M_row_index_range, const std::array&lt; types::global_dof_index, 2 &gt; &amp;M_col_index_range, const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> top_hmat_node_property)</td></tr>
<tr class="separator:a4657e8432ee8b3778fb4bced08dba133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ce1b9b5f1b4b4127db9cc80987a5e2"><td class="memTemplParams" colspan="2"><a id="ac9ce1b9b5f1b4b4127db9cc80987a5e2" name="ac9ce1b9b5f1b4b4127db9cc80987a5e2"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ac9ce1b9b5f1b4b4127db9cc80987a5e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildren</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, typename numbers::NumberTraits&lt; Number1 &gt;::real_type &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#acc153ec757cd8fecdeca2274e1ed5a27">bc_node</a>, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;&amp;H)</td></tr>
<tr class="separator:ac9ce1b9b5f1b4b4127db9cc80987a5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac511284701f9f527c0480608242d0619"><td class="memTemplParams" colspan="2"><a id="ac511284701f9f527c0480608242d0619" name="ac511284701f9f527c0480608242d0619"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ac511284701f9f527c0480608242d0619"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RefineHMatrixWrtExtendedBlockClusterTree</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *starting_hmat, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *current_hmat)</td></tr>
<tr class="separator:ac511284701f9f527c0480608242d0619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47825229983c7fa5755b3be8d5ac03f7"><td class="memTemplParams" colspan="2"><a id="a47825229983c7fa5755b3be8d5ac03f7" name="a47825229983c7fa5755b3be8d5ac03f7"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a47825229983c7fa5755b3be8d5ac03f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertHMatBlockToRkMatrix</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat_block, const unsigned int fixed_rank_k, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat_root_block, size_t *calling_counter, const std::string &amp;output_file_base_name)</td></tr>
<tr class="separator:a47825229983c7fa5755b3be8d5ac03f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5b4592067610eec18b830482897243"><td class="memTemplParams" colspan="2"><a id="a1b5b4592067610eec18b830482897243" name="a1b5b4592067610eec18b830482897243"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a1b5b4592067610eec18b830482897243"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_rk_mmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a1b5b4592067610eec18b830482897243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04c7cb6f2968253cf41b1d1a93760c7"><td class="memTemplParams" colspan="2"><a id="af04c7cb6f2968253cf41b1d1a93760c7" name="af04c7cb6f2968253cf41b1d1a93760c7"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:af04c7cb6f2968253cf41b1d1a93760c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_rk_mmult</b> (const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:af04c7cb6f2968253cf41b1d1a93760c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59530b8595d7716e02b405e35dbc561"><td class="memTemplParams" colspan="2"><a id="ad59530b8595d7716e02b405e35dbc561" name="ad59530b8595d7716e02b405e35dbc561"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ad59530b8595d7716e02b405e35dbc561"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_rk_mTmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:ad59530b8595d7716e02b405e35dbc561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf5a4058289ffe89a9f88379e643e53"><td class="memTemplParams" colspan="2"><a id="a8cf5a4058289ffe89a9f88379e643e53" name="a8cf5a4058289ffe89a9f88379e643e53"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a8cf5a4058289ffe89a9f88379e643e53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_rk_mTmult</b> (const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a8cf5a4058289ffe89a9f88379e643e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10af3d1fafe805822d87e50999041172"><td class="memTemplParams" colspan="2"><a id="a10af3d1fafe805822d87e50999041172" name="a10af3d1fafe805822d87e50999041172"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a10af3d1fafe805822d87e50999041172"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_rk_Tmmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a10af3d1fafe805822d87e50999041172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd46e395af7b40043683ede4d480fda"><td class="memTemplParams" colspan="2"><a id="aabd46e395af7b40043683ede4d480fda" name="aabd46e395af7b40043683ede4d480fda"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:aabd46e395af7b40043683ede4d480fda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_rk_Tmmult</b> (const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:aabd46e395af7b40043683ede4d480fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614ba3b92b97d95cb3146db181611a34"><td class="memTemplParams" colspan="2"><a id="a614ba3b92b97d95cb3146db181611a34" name="a614ba3b92b97d95cb3146db181611a34"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a614ba3b92b97d95cb3146db181611a34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_rk_mmult_for_h_h_mmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M, bool is_M1M2_last_in_M_Sigma_P)</td></tr>
<tr class="separator:a614ba3b92b97d95cb3146db181611a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa94f9688a9443024a2631d2bfae06c8"><td class="memTemplParams" colspan="2"><a id="afa94f9688a9443024a2631d2bfae06c8" name="afa94f9688a9443024a2631d2bfae06c8"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:afa94f9688a9443024a2631d2bfae06c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rk_h_mmult</b> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:afa94f9688a9443024a2631d2bfae06c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a9c2821153dd59f0d230a997879ff3"><td class="memTemplParams" colspan="2"><a id="a52a9c2821153dd59f0d230a997879ff3" name="a52a9c2821153dd59f0d230a997879ff3"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a52a9c2821153dd59f0d230a997879ff3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rk_h_mmult</b> (const Number1 alpha, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a52a9c2821153dd59f0d230a997879ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c04e99e7f40fb0c9f3dcc042e95882a"><td class="memTemplParams" colspan="2"><a id="a0c04e99e7f40fb0c9f3dcc042e95882a" name="a0c04e99e7f40fb0c9f3dcc042e95882a"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a0c04e99e7f40fb0c9f3dcc042e95882a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rk_h_mTmult</b> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a0c04e99e7f40fb0c9f3dcc042e95882a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fddb7ff1c462d5605b63ea0b10bcc34"><td class="memTemplParams" colspan="2"><a id="a2fddb7ff1c462d5605b63ea0b10bcc34" name="a2fddb7ff1c462d5605b63ea0b10bcc34"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a2fddb7ff1c462d5605b63ea0b10bcc34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rk_h_mTmult</b> (const Number1 alpha, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a2fddb7ff1c462d5605b63ea0b10bcc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc54a829e3100f36876dfc48ce84075"><td class="memTemplParams" colspan="2"><a id="addc54a829e3100f36876dfc48ce84075" name="addc54a829e3100f36876dfc48ce84075"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:addc54a829e3100f36876dfc48ce84075"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rk_h_Tmmult</b> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:addc54a829e3100f36876dfc48ce84075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dae3d2559fa070045599ec7a00ce2b"><td class="memTemplParams" colspan="2"><a id="a61dae3d2559fa070045599ec7a00ce2b" name="a61dae3d2559fa070045599ec7a00ce2b"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a61dae3d2559fa070045599ec7a00ce2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rk_h_Tmmult</b> (const Number1 alpha, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a61dae3d2559fa070045599ec7a00ce2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b12cf1aa7504c436b84394f2116f6a9"><td class="memTemplParams" colspan="2"><a id="a9b12cf1aa7504c436b84394f2116f6a9" name="a9b12cf1aa7504c436b84394f2116f6a9"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a9b12cf1aa7504c436b84394f2116f6a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rk_h_mmult_for_h_h_mmult</b> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M, bool is_M1M2_last_in_M_Sigma_P)</td></tr>
<tr class="separator:a9b12cf1aa7504c436b84394f2116f6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ccef980f81f9fb3c63675f3f9c014f"><td class="memTemplParams" colspan="2"><a id="a85ccef980f81f9fb3c63675f3f9c014f" name="a85ccef980f81f9fb3c63675f3f9c014f"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a85ccef980f81f9fb3c63675f3f9c014f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a85ccef980f81f9fb3c63675f3f9c014f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72731e18525c507f92b16d880858b93"><td class="memTemplParams" colspan="2"><a id="ab72731e18525c507f92b16d880858b93" name="ab72731e18525c507f92b16d880858b93"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ab72731e18525c507f92b16d880858b93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mmult</b> (const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:ab72731e18525c507f92b16d880858b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcedf4b5e2f14d085cce5cdc3f2b46cf"><td class="memTemplParams" colspan="2"><a id="adcedf4b5e2f14d085cce5cdc3f2b46cf" name="adcedf4b5e2f14d085cce5cdc3f2b46cf"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:adcedf4b5e2f14d085cce5cdc3f2b46cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mTmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:adcedf4b5e2f14d085cce5cdc3f2b46cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86eb2a4d2b7039163dd4f28650fe747e"><td class="memTemplParams" colspan="2"><a id="a86eb2a4d2b7039163dd4f28650fe747e" name="a86eb2a4d2b7039163dd4f28650fe747e"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a86eb2a4d2b7039163dd4f28650fe747e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mTmult</b> (const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a86eb2a4d2b7039163dd4f28650fe747e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6d308dfa0262aa49a38edc6a03fd9c"><td class="memTemplParams" colspan="2"><a id="a4f6d308dfa0262aa49a38edc6a03fd9c" name="a4f6d308dfa0262aa49a38edc6a03fd9c"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a4f6d308dfa0262aa49a38edc6a03fd9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_Tmmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a4f6d308dfa0262aa49a38edc6a03fd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0131da9fbf81d7b80e92181b6110c3c"><td class="memTemplParams" colspan="2"><a id="aa0131da9fbf81d7b80e92181b6110c3c" name="aa0131da9fbf81d7b80e92181b6110c3c"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:aa0131da9fbf81d7b80e92181b6110c3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_Tmmult</b> (const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:aa0131da9fbf81d7b80e92181b6110c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3866052a5345742ad9f44f11f33989"><td class="memTemplParams" colspan="2"><a id="aea3866052a5345742ad9f44f11f33989" name="aea3866052a5345742ad9f44f11f33989"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:aea3866052a5345742ad9f44f11f33989"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:aea3866052a5345742ad9f44f11f33989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad090448398bf367cba0b208456144e7d"><td class="memTemplParams" colspan="2"><a id="ad090448398bf367cba0b208456144e7d" name="ad090448398bf367cba0b208456144e7d"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ad090448398bf367cba0b208456144e7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mmult</b> (const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:ad090448398bf367cba0b208456144e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f368b3c372ece4b6506d89bb9e255df"><td class="memTemplParams" colspan="2"><a id="a8f368b3c372ece4b6506d89bb9e255df" name="a8f368b3c372ece4b6506d89bb9e255df"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a8f368b3c372ece4b6506d89bb9e255df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mTmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a8f368b3c372ece4b6506d89bb9e255df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81f9d9c00ebd7bdabb28b6ea0646236"><td class="memTemplParams" colspan="2"><a id="ad81f9d9c00ebd7bdabb28b6ea0646236" name="ad81f9d9c00ebd7bdabb28b6ea0646236"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ad81f9d9c00ebd7bdabb28b6ea0646236"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mTmult</b> (const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:ad81f9d9c00ebd7bdabb28b6ea0646236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc76bfd036d6732850077e9c9b4ffe01"><td class="memTemplParams" colspan="2"><a id="adc76bfd036d6732850077e9c9b4ffe01" name="adc76bfd036d6732850077e9c9b4ffe01"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:adc76bfd036d6732850077e9c9b4ffe01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_Tmmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:adc76bfd036d6732850077e9c9b4ffe01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae504b6ecc0eaf551a84980536e68cec4"><td class="memTemplParams" colspan="2"><a id="ae504b6ecc0eaf551a84980536e68cec4" name="ae504b6ecc0eaf551a84980536e68cec4"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ae504b6ecc0eaf551a84980536e68cec4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_Tmmult</b> (const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:ae504b6ecc0eaf551a84980536e68cec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897365f6716975f71b528f610498c69b"><td class="memTemplParams" colspan="2"><a id="a897365f6716975f71b528f610498c69b" name="a897365f6716975f71b528f610498c69b"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a897365f6716975f71b528f610498c69b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mmult_for_h_h_mmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M, bool is_M1M2_last_in_M_Sigma_P)</td></tr>
<tr class="separator:a897365f6716975f71b528f610498c69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b0f45b3a6734fef74d90f28fcefbc1"><td class="memTemplParams" colspan="2"><a id="a67b0f45b3a6734fef74d90f28fcefbc1" name="a67b0f45b3a6734fef74d90f28fcefbc1"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a67b0f45b3a6734fef74d90f28fcefbc1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mmult</b> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a67b0f45b3a6734fef74d90f28fcefbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58df6eed9eb48d8d725476c8e289d859"><td class="memTemplParams" colspan="2"><a id="a58df6eed9eb48d8d725476c8e289d859" name="a58df6eed9eb48d8d725476c8e289d859"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a58df6eed9eb48d8d725476c8e289d859"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mmult</b> (const Number1 alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a58df6eed9eb48d8d725476c8e289d859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a400c086f929a643da87cf6dc493c26"><td class="memTemplParams" colspan="2"><a id="a6a400c086f929a643da87cf6dc493c26" name="a6a400c086f929a643da87cf6dc493c26"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a6a400c086f929a643da87cf6dc493c26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mTmult</b> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a6a400c086f929a643da87cf6dc493c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2beff0c056d76818dc4e61dded73fe0"><td class="memTemplParams" colspan="2"><a id="ac2beff0c056d76818dc4e61dded73fe0" name="ac2beff0c056d76818dc4e61dded73fe0"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ac2beff0c056d76818dc4e61dded73fe0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mTmult</b> (const Number1 alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:ac2beff0c056d76818dc4e61dded73fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109184ddbbed8921590db6ee108aa21a"><td class="memTemplParams" colspan="2"><a id="a109184ddbbed8921590db6ee108aa21a" name="a109184ddbbed8921590db6ee108aa21a"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a109184ddbbed8921590db6ee108aa21a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_Tmmult</b> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a109184ddbbed8921590db6ee108aa21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21dc84e40c74c310f65dc86e72a0253b"><td class="memTemplParams" colspan="2"><a id="a21dc84e40c74c310f65dc86e72a0253b" name="a21dc84e40c74c310f65dc86e72a0253b"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a21dc84e40c74c310f65dc86e72a0253b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_Tmmult</b> (const Number1 alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a21dc84e40c74c310f65dc86e72a0253b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d1ce72cb294b2c4da6536250905a32"><td class="memTemplParams" colspan="2"><a id="a66d1ce72cb294b2c4da6536250905a32" name="a66d1ce72cb294b2c4da6536250905a32"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a66d1ce72cb294b2c4da6536250905a32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mmult</b> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a66d1ce72cb294b2c4da6536250905a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6da79ad8924c127c5eb34acf396cf00"><td class="memTemplParams" colspan="2"><a id="ac6da79ad8924c127c5eb34acf396cf00" name="ac6da79ad8924c127c5eb34acf396cf00"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ac6da79ad8924c127c5eb34acf396cf00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mmult</b> (const Number1 alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:ac6da79ad8924c127c5eb34acf396cf00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439a1469e55ddc97987ee592b920cedb"><td class="memTemplParams" colspan="2"><a id="a439a1469e55ddc97987ee592b920cedb" name="a439a1469e55ddc97987ee592b920cedb"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a439a1469e55ddc97987ee592b920cedb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mTmult</b> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a439a1469e55ddc97987ee592b920cedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c51795179e7c52726d2eb3a76a17914"><td class="memTemplParams" colspan="2"><a id="a7c51795179e7c52726d2eb3a76a17914" name="a7c51795179e7c52726d2eb3a76a17914"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a7c51795179e7c52726d2eb3a76a17914"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mTmult</b> (const Number1 alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a7c51795179e7c52726d2eb3a76a17914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bb106c6d6c53614d907c5642ec7a7d"><td class="memTemplParams" colspan="2"><a id="a72bb106c6d6c53614d907c5642ec7a7d" name="a72bb106c6d6c53614d907c5642ec7a7d"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a72bb106c6d6c53614d907c5642ec7a7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_Tmmult</b> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a72bb106c6d6c53614d907c5642ec7a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b88264f5b48edb1fc9e620407709347"><td class="memTemplParams" colspan="2"><a id="a6b88264f5b48edb1fc9e620407709347" name="a6b88264f5b48edb1fc9e620407709347"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a6b88264f5b48edb1fc9e620407709347"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_Tmmult</b> (const Number1 alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a6b88264f5b48edb1fc9e620407709347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311938523b49a053a8cf16bc96576cdf"><td class="memTemplParams" colspan="2"><a id="a311938523b49a053a8cf16bc96576cdf" name="a311938523b49a053a8cf16bc96576cdf"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a311938523b49a053a8cf16bc96576cdf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mmult_for_h_h_mmult</b> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M, bool is_M1M2_last_in_M_Sigma_P)</td></tr>
<tr class="separator:a311938523b49a053a8cf16bc96576cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4a159321790fc560545746f4dc9399"><td class="memTemplParams" colspan="2"><a id="a7c4a159321790fc560545746f4dc9399" name="a7c4a159321790fc560545746f4dc9399"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a7c4a159321790fc560545746f4dc9399"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mmult_phase1_recursion</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, typename numbers::NumberTraits&lt; Number1 &gt;::real_type &gt; &amp;<a class="el" href="classHMatrix.html#a7492f731ddeb720c3ff810e07fd64546">Tind</a>)</td></tr>
<tr class="separator:a7c4a159321790fc560545746f4dc9399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315159833ace90a9ba4d4addd6f502e0"><td class="memTemplParams" colspan="2"><a id="a315159833ace90a9ba4d4addd6f502e0" name="a315159833ace90a9ba4d4addd6f502e0"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a315159833ace90a9ba4d4addd6f502e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mmult_phase2</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, typename numbers::NumberTraits&lt; Number1 &gt;::real_type &gt; &amp;target_bc_tree, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a315159833ace90a9ba4d4addd6f502e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8caaded81a1d2766fc697ec3bff651a9"><td class="memTemplParams" colspan="2"><a id="a8caaded81a1d2766fc697ec3bff651a9" name="a8caaded81a1d2766fc697ec3bff651a9"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a8caaded81a1d2766fc697ec3bff651a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mmult_from_leaf_node</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> block_type_for_local_Z, const unsigned int fixed_rank, const bool is_result_matrix_symm_apriori)</td></tr>
<tr class="separator:a8caaded81a1d2766fc697ec3bff651a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598ae0d8d56c560161ad3104431caf3f"><td class="memTemplParams" colspan="2"><a id="a598ae0d8d56c560161ad3104431caf3f" name="a598ae0d8d56c560161ad3104431caf3f"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a598ae0d8d56c560161ad3104431caf3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mmult_from_leaf_node</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> block_type_for_local_Z, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only)</td></tr>
<tr class="separator:a598ae0d8d56c560161ad3104431caf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd90d1eb928bfe55e0e83fdaa48d850c"><td class="memTemplParams" colspan="2"><a id="afd90d1eb928bfe55e0e83fdaa48d850c" name="afd90d1eb928bfe55e0e83fdaa48d850c"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:afd90d1eb928bfe55e0e83fdaa48d850c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mmult_from_leaf_node_for_parallel_lu</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> block_type_for_local_Z, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only)</td></tr>
<tr class="separator:afd90d1eb928bfe55e0e83fdaa48d850c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2b4f910cadebf2998694c8861a6f56"><td class="memTemplParams" colspan="2"><a id="aae2b4f910cadebf2998694c8861a6f56" name="aae2b4f910cadebf2998694c8861a6f56"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:aae2b4f910cadebf2998694c8861a6f56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mTmult_from_leaf_node</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> block_type_for_local_Z, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only)</td></tr>
<tr class="separator:aae2b4f910cadebf2998694c8861a6f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8058c4f11181294d9ec3bcae5af296e"><td class="memTemplParams" colspan="2"><a id="ab8058c4f11181294d9ec3bcae5af296e" name="ab8058c4f11181294d9ec3bcae5af296e"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ab8058c4f11181294d9ec3bcae5af296e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mTmult_from_leaf_node</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> block_type_for_local_Z, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only)</td></tr>
<tr class="separator:ab8058c4f11181294d9ec3bcae5af296e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd8d804b51f7fb90805987f4084a658"><td class="memTemplParams" colspan="2"><a id="a6bd8d804b51f7fb90805987f4084a658" name="a6bd8d804b51f7fb90805987f4084a658"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a6bd8d804b51f7fb90805987f4084a658"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mTmult_from_leaf_node_for_parallel_cholesky</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> block_type_for_local_Z, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only)</td></tr>
<tr class="separator:a6bd8d804b51f7fb90805987f4084a658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e1c97350460e6ed82984fd8285c820"><td class="memTemplParams" colspan="2"><a id="aa3e1c97350460e6ed82984fd8285c820" name="aa3e1c97350460e6ed82984fd8285c820"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:aa3e1c97350460e6ed82984fd8285c820"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_Tmmult_from_leaf_node</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> block_type_for_local_Z, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only)</td></tr>
<tr class="separator:aa3e1c97350460e6ed82984fd8285c820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da4c711fd593c622b0b395db5e35876"><td class="memTemplParams" colspan="2"><a id="a0da4c711fd593c622b0b395db5e35876" name="a0da4c711fd593c622b0b395db5e35876"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a0da4c711fd593c622b0b395db5e35876"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_Tmmult_from_leaf_node</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> block_type_for_local_Z, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only)</td></tr>
<tr class="separator:a0da4c711fd593c622b0b395db5e35876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a36303995bd4eefca6c8a2c8a782b8"><td class="memTemplParams" colspan="2"><a id="ae8a36303995bd4eefca6c8a2c8a782b8" name="ae8a36303995bd4eefca6c8a2c8a782b8"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ae8a36303995bd4eefca6c8a2c8a782b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mmult_level_conserving</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only)</td></tr>
<tr class="separator:ae8a36303995bd4eefca6c8a2c8a782b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b29bf8db6d2ba011b0f23f195718fa4"><td class="memTemplParams" colspan="2"><a id="a3b29bf8db6d2ba011b0f23f195718fa4" name="a3b29bf8db6d2ba011b0f23f195718fa4"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a3b29bf8db6d2ba011b0f23f195718fa4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mmult_level_conserving</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only)</td></tr>
<tr class="separator:a3b29bf8db6d2ba011b0f23f195718fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97024e47dacd197efe29e04748de477"><td class="memTemplParams" colspan="2"><a id="ae97024e47dacd197efe29e04748de477" name="ae97024e47dacd197efe29e04748de477"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ae97024e47dacd197efe29e04748de477"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mmult_level_conserving_for_parallel_lu</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only)</td></tr>
<tr class="separator:ae97024e47dacd197efe29e04748de477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb88250b5db970aa18588dbdae38fae"><td class="memTemplParams" colspan="2"><a id="a6fb88250b5db970aa18588dbdae38fae" name="a6fb88250b5db970aa18588dbdae38fae"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a6fb88250b5db970aa18588dbdae38fae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mTmult_level_conserving</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only)</td></tr>
<tr class="separator:a6fb88250b5db970aa18588dbdae38fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ad461a28d5bf57778cd7737bce251f"><td class="memTemplParams" colspan="2"><a id="a04ad461a28d5bf57778cd7737bce251f" name="a04ad461a28d5bf57778cd7737bce251f"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a04ad461a28d5bf57778cd7737bce251f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mTmult_level_conserving</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only)</td></tr>
<tr class="separator:a04ad461a28d5bf57778cd7737bce251f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f52ec4b604f89e6277e397592d51b39"><td class="memTemplParams" colspan="2"><a id="a1f52ec4b604f89e6277e397592d51b39" name="a1f52ec4b604f89e6277e397592d51b39"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a1f52ec4b604f89e6277e397592d51b39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mTmult_level_conserving_for_parallel_cholesky</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only)</td></tr>
<tr class="separator:a1f52ec4b604f89e6277e397592d51b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e9765a8e6ba1e1735be03e23be0796"><td class="memTemplParams" colspan="2"><a id="ac9e9765a8e6ba1e1735be03e23be0796" name="ac9e9765a8e6ba1e1735be03e23be0796"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ac9e9765a8e6ba1e1735be03e23be0796"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_Tmmult_level_conserving</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only)</td></tr>
<tr class="separator:ac9e9765a8e6ba1e1735be03e23be0796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6006f92381b2278c7e1a3907327c2c83"><td class="memTemplParams" colspan="2"><a id="a6006f92381b2278c7e1a3907327c2c83" name="a6006f92381b2278c7e1a3907327c2c83"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a6006f92381b2278c7e1a3907327c2c83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_Tmmult_level_conserving</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const unsigned int fixed_rank, const bool is_result_matrix_store_tril_only)</td></tr>
<tr class="separator:a6006f92381b2278c7e1a3907327c2c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec67bee413b9db0bedfe58ddc0d91c1"><td class="memTemplParams" colspan="2"><a id="a4ec67bee413b9db0bedfe58ddc0d91c1" name="a4ec67bee413b9db0bedfe58ddc0d91c1"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a4ec67bee413b9db0bedfe58ddc0d91c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_hmatrix_node</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat_dst, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat_src)</td></tr>
<tr class="separator:a4ec67bee413b9db0bedfe58ddc0d91c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e52ecf1ea024322e4318243e922a1c"><td class="memTemplParams" colspan="2"><a id="a10e52ecf1ea024322e4318243e922a1c" name="a10e52ecf1ea024322e4318243e922a1c"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a10e52ecf1ea024322e4318243e922a1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_hmatrix_node</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat_dst, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;&amp;hmat_src)</td></tr>
<tr class="separator:a10e52ecf1ea024322e4318243e922a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ce56e1013c5060804023841e3ac93b"><td class="memTemplParams" colspan="2"><a id="a29ce56e1013c5060804023841e3ac93b" name="a29ce56e1013c5060804023841e3ac93b"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a29ce56e1013c5060804023841e3ac93b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_hmatrix</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat_dst, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat_src)</td></tr>
<tr class="separator:a29ce56e1013c5060804023841e3ac93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eefa50a413f628f9b74c4b7ca7fd118"><td class="memTemplParams" colspan="2"><a id="a9eefa50a413f628f9b74c4b7ca7fd118" name="a9eefa50a413f628f9b74c4b7ca7fd118"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a9eefa50a413f628f9b74c4b7ca7fd118"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print_h_submatrix_accessor</b> (std::ostream &amp;out, const std::string &amp;name, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a9eefa50a413f628f9b74c4b7ca7fd118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee7e6e1599718531085769438a918a7"><td class="memTemplParams" colspan="2"><a id="adee7e6e1599718531085769438a918a7" name="adee7e6e1599718531085769438a918a7"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:adee7e6e1599718531085769438a918a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print_h_h_submatrix_mmult_accessor</b> (std::ostream &amp;out, const std::string &amp;name1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const std::string &amp;name2, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2)</td></tr>
<tr class="separator:adee7e6e1599718531085769438a918a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cbdadb17c9b375a0183d2172b678ff"><td class="memTemplParams" colspan="2"><a id="aa5cbdadb17c9b375a0183d2172b678ff" name="aa5cbdadb17c9b375a0183d2172b678ff"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:aa5cbdadb17c9b375a0183d2172b678ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hmatrix_solve_lu</b> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;L, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;U, Vector&lt; Number1 &gt; &amp;x, const Vector&lt; Number1 &gt; &amp;b)</td></tr>
<tr class="separator:aa5cbdadb17c9b375a0183d2172b678ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2e9410cc83312bd7d00cebf4584b75"><td class="memTemplParams" colspan="2"><a id="a9f2e9410cc83312bd7d00cebf4584b75" name="a9f2e9410cc83312bd7d00cebf4584b75"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a9f2e9410cc83312bd7d00cebf4584b75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hmatrix_solve_cholesky</b> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;L, Vector&lt; Number1 &gt; &amp;x, const Vector&lt; Number1 &gt; &amp;b)</td></tr>
<tr class="separator:a9f2e9410cc83312bd7d00cebf4584b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int spacedim, typename Number = double&gt;<br />
class HMatrix&lt; spacedim, Number &gt;</div>
<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l00103">103</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1a9caa0d8f5c4d73364969feea0de137" name="a1a9caa0d8f5c4d73364969feea0de137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9caa0d8f5c4d73364969feea0de137">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::real_type =  typename numbers::NumberTraits&lt;Number&gt;::real_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l00111">111</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a5ca8dc549783d38371a01ecd621ecb34" name="a5ca8dc549783d38371a01ecd621ecb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca8dc549783d38371a01ecd621ecb34">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;<a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">::size_type</a> =  std::make_unsigned&lt;types::blas_int&gt;<a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">::type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Declare the type for container size. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l00109">109</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a8d96bca39ce2ce666ae5e997f2cc32d5" name="a8d96bca39ce2ce666ae5e997f2cc32d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d96bca39ce2ce666ae5e997f2cc32d5">&#9670;&nbsp;</a></span>TaskNode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::TaskNode =  tbb::flow::continue_node&lt;tbb::flow::continue_msg&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Declare the type for TBB flow graph node. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l00270">270</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a39cc9da38a1c6ef145ea4f5f6624e1dd" name="a39cc9da38a1c6ef145ea4f5f6624e1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cc9da38a1c6ef145ea4f5f6624e1dd">&#9670;&nbsp;</a></span>TaskNodePtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::TaskNodePtr =  std::shared_ptr&lt;<a class="el" href="classHMatrix.html#a8d96bca39ce2ce666ae5e997f2cc32d5">TaskNode</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l00271">271</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aa2580f4a72dc08c758be692a4e904952" name="aa2580f4a72dc08c758be692a4e904952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2580f4a72dc08c758be692a4e904952">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::value_type =  Number</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l00110">110</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="afaff6be3787ae9ecebd8cb53868ae65b" name="afaff6be3787ae9ecebd8cb53868ae65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaff6be3787ae9ecebd8cb53868ae65b">&#9670;&nbsp;</a></span>HilbertBlockType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classHMatrix.html#afaff6be3787ae9ecebd8cb53868ae65b">HMatrix::HilbertBlockType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >BLock type during leaf node traversal by following the Hilbert curve. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l00131">131</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a2b67e35d653ab864ae89c137ea3c8615" name="a2b67e35d653ab864ae89c137ea3c8615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b67e35d653ab864ae89c137ea3c8615">&#9670;&nbsp;</a></span>SpaceFillingCurveType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615">HMatrix::SpaceFillingCurveType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Space-filling curve used for traversing the leaf nodes of the \(\mathcal{H}\)-matrix. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2b67e35d653ab864ae89c137ea3c8615a28de0ca7ea61d1edea9a803db4c0fa34" name="a2b67e35d653ab864ae89c137ea3c8615a28de0ca7ea61d1edea9a803db4c0fa34"></a>Z&#160;</td><td class="fielddoc"><p >Z curve, which is obtained from a depth-first-search (DFS). </p>
</td></tr>
<tr><td class="fieldname"><a id="a2b67e35d653ab864ae89c137ea3c8615ae616dc6bd2559757065bcab8df46f355" name="a2b67e35d653ab864ae89c137ea3c8615ae616dc6bd2559757065bcab8df46f355"></a>Hilbert&#160;</td><td class="fielddoc"><p >Hilbert curve </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l00116">116</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae3dc35e1aefee2580d27ad2d65c906de" name="ae3dc35e1aefee2580d27ad2d65c906de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3dc35e1aefee2580d27ad2d65c906de">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;<a class="el" href="classHMatrix.html">::HMatrix</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Default constructor.</p>
<dl class="section note">
<dt>Note</dt>
<dd>Because an empty \(\mathcal{H}\)-matrix is to be created, its \(\mathcal{H}\)-matrix type is set to <code>UndefinedMatrixType</code> and block type is set to <code>undefined_block</code>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17600">17600</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a194ec72be8c3b078f90e528422cc5ca8" name="a194ec72be8c3b078f90e528422cc5ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194ec72be8c3b078f90e528422cc5ca8">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;<a class="el" href="classHMatrix.html">::HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>property</em> = <code>HMatrixSupport::Property::general</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type</em> = <code>HMatrixSupport::BlockType::undefined_block</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Construct the hierarchical structure without data from the root node of a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree.">BlockClusterTree</a>.</p>
<dl class="section note">
<dt>Note</dt>
<dd>In case the block cluster tree is only a subtree and the \(\mathcal{H}\)-matrix to be built is just a block in the global \(\mathcal{H}\)-matrix, the block type is set to <code>HMatrixSupport::BlockType::undefined_block</code> by default.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17632">17632</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a64ec7c9a264e5c91d1d2e1c8e9afa829" name="a64ec7c9a264e5c91d1d2e1c8e9afa829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ec7c9a264e5c91d1d2e1c8e9afa829">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;<a class="el" href="classHMatrix.html">::HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>property</em> = <code>HMatrixSupport::Property::general</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type</em> = <code>HMatrixSupport::BlockType::undefined_block</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Construct the hierarchical structure without data from a <a class="el" href="classTreeNode.html" title="Class for general tree node.">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree.">BlockClusterTree</a>.</p>
<dl class="section note">
<dt>Note</dt>
<dd>In case the block cluster node is not the root node of the block cluster tree and the \(\mathcal{H}\)-matrix to be built is just a block in the global \(\mathcal{H}\)-matrix, the block type is set to <code>HMatrixSupport::BlockType::undefined_block</code> by default.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17673">17673</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aa08639151120336201d0a1df4e011b54" name="aa08639151120336201d0a1df4e011b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08639151120336201d0a1df4e011b54">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;<a class="el" href="classHMatrix.html">::HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type</em> = <code>HMatrixSupport::BlockType::diagonal_block</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Construct from the root node of a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree.">BlockClusterTree</a> while copying the data of a <b>global</b> full matrix, which is created on the complete block cluster \(I \times J\).</p>
<dl class="section note">
<dt>Note</dt>
<dd>Since this \(\mathcal{H}\)-matrix is the global matrix, i.e. on the same level as the global full matrix <code>M</code> in the \(\mathcal{H}\)-matrix hierarchy, its block type is set to <code>HMatrixSupport::BlockType::diagonal_block</code> by default and its property is inferred from the full matrix <code>M</code> inside this constructor's body.</dd>
</dl>
<p >Determine the property of the \(\mathcal{H}\)-matrix from the global full matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17715">17715</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a611361b83bdcc32acc5872587a3b1706" name="a611361b83bdcc32acc5872587a3b1706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611361b83bdcc32acc5872587a3b1706">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;<a class="el" href="classHMatrix.html">::HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type</em> = <code>HMatrixSupport::BlockType::diagonal_block</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Construct from the root node of a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree.">BlockClusterTree</a> while copying the data of a <b>global</b> full matrix, which is created on the complete block cluster \(I \times J\).</p>
<p >This version has no rank truncation.</p>
<dl class="section note">
<dt>Note</dt>
<dd>Since this \(\mathcal{H}\)-matrix is the global matrix, i.e. on the same level as the global full matrix <code>M</code> in the \(\mathcal{H}\)-matrix hierarchy, its block type is set to <code>HMatrixSupport::BlockType::diagonal_block</code> by default and its property is inferred from the full matrix <code>M</code> inside this constructor's body.</dd>
</dl>
<p >Determine the property of the \(\mathcal{H}\)-matrix from the global full matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17761">17761</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a813e1de9fb112e29f95875c7eb942fd8" name="a813e1de9fb112e29f95875c7eb942fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813e1de9fb112e29f95875c7eb942fd8">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;<a class="el" href="classHMatrix.html">::HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>property</em> = <code>HMatrixSupport::Property::general</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type</em> = <code>HMatrixSupport::BlockType::undefined_block</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Construct from a <a class="el" href="classTreeNode.html" title="Class for general tree node.">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree.">BlockClusterTree</a> while copying the data of a global full matrix, which is created on the complete block cluster \(I
\times J\).</p>
<dl class="section note">
<dt>Note</dt>
<dd>The current \(\mathcal{H}\)-matrix to be built may only be a matrix block in the global matrix, while the full matrix <code>M</code> is global, i.e., the \(\mathcal{H}\)-matrix and the full matrix <code>M</code> are not on a same level in the \(\mathcal{H}\)-matrix hierarchy. Therefore, the block type of this \(\mathcal{H}\)-matrix should be set to <code>undefined_block</code> by default and its property cannot be inferred from the global matrix.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17806">17806</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aff43c2b8b2880094c3c2e85299cb5555" name="aff43c2b8b2880094c3c2e85299cb5555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff43c2b8b2880094c3c2e85299cb5555">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;<a class="el" href="classHMatrix.html">::HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>property</em> = <code>HMatrixSupport::Property::general</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type</em> = <code>HMatrixSupport::BlockType::undefined_block</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Construct from a <a class="el" href="classTreeNode.html" title="Class for general tree node.">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree.">BlockClusterTree</a> while copying the data of a global full matrix, which is created on the complete block cluster \(I
\times J\).</p>
<p >This version has no rank truncation.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The current \(\mathcal{H}\)-matrix to be built may only be a matrix block in the global matrix, while the full matrix <code>M</code> is global, i.e., the \(\mathcal{H}\)-matrix and the full matrix <code>M</code> are not on a same level in the \(\mathcal{H}\)-matrix hierarchy. Therefore, the block type of this \(\mathcal{H}\)-matrix should be set to <code>undefined_block</code> by default and its property cannot be inferred from the global matrix.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17849">17849</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a2456ea4b70ec915a821c5385b523beec" name="a2456ea4b70ec915a821c5385b523beec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2456ea4b70ec915a821c5385b523beec">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;<a class="el" href="classHMatrix.html">::HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>property</em> = <code>HMatrixSupport::Property::general</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type</em> = <code>HMatrixSupport::BlockType::undefined_block</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Construct from a <code><a class="el" href="classTreeNode.html" title="Class for general tree node.">TreeNode</a></code> in a <code><a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree.">BlockClusterTree</a></code> while moving the data from the leaf set of the \(\mathcal{H}\)-matrix <code>H</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bc_node</td><td></td></tr>
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17891">17891</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a557c894192e6191e8db7837222229beb" name="a557c894192e6191e8db7837222229beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557c894192e6191e8db7837222229beb">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;<a class="el" href="classHMatrix.html">::HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>property</em> = <code>HMatrixSupport::Property::general</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type</em> = <code>HMatrixSupport::BlockType::diagonal_block</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Construct from the root node of a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree.">BlockClusterTree</a> while moving the data from the leaf set of the \(\mathcal{H}\)-matrix <code>H</code>.</p>
<dl class="section note">
<dt>Note</dt>
<dd>Since this \(\mathcal{H}\)-matrix is the global matrix because it is constructed with respect to the root node of the block cluster tree, its block type is set to <code>HMatrixSupport::BlockType::diagonal_block</code>.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bct</td><td></td></tr>
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17933">17933</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a0b5227e35290f6c9fba1e8948e9a29c3" name="a0b5227e35290f6c9fba1e8948e9a29c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5227e35290f6c9fba1e8948e9a29c3">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;<a class="el" href="classHMatrix.html">::HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Deep copy constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l17974">17974</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a1ceaa51b9b52d22e79558dfc22470855" name="a1ceaa51b9b52d22e79558dfc22470855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ceaa51b9b52d22e79558dfc22470855">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;<a class="el" href="classHMatrix.html">::HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Shallow copy constructor.</p>
<p >After the copy operation, the data in the source matrix <code>H</code> are transferred to the current \(\mathcal{H}\)-matrix node and <code>H</code> is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l18011">18011</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ae16c956c1b22eb307e9f360a83f4fa75" name="ae16c956c1b22eb307e9f360a83f4fa75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16c956c1b22eb307e9f360a83f4fa75">&#9670;&nbsp;</a></span>~HMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::~<a class="el" href="classHMatrix.html">HMatrix</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Destructor which releases the memory by recursion. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19044">19044</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a651ac10b059076f48a7cfbd3adceb125" name="a651ac10b059076f48a7cfbd3adceb125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651ac10b059076f48a7cfbd3adceb125">&#9670;&nbsp;</a></span>_build_leaf_set_hilbert_traversal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_build_leaf_set_hilbert_traversal </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>total_leaf_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>total_near_field_leaf_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>total_far_field_leaf_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html#afaff6be3787ae9ecebd8cb53868ae65b">HilbertBlockType</a>&#160;</td>
          <td class="paramname"><em>current_hilbert_block_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The \(\mathcal{H}\)-matrix should be a quad-tree in this scenario.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l18515">18515</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

</div>
</div>
<a id="add8a3448bc2a3ec0b80eb0c52fc4c16d" name="add8a3448bc2a3ec0b80eb0c52fc4c16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8a3448bc2a3ec0b80eb0c52fc4c16d">&#9670;&nbsp;</a></span>_build_leaf_set_z_traversal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_build_leaf_set_z_traversal </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>total_leaf_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>total_near_field_leaf_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>total_far_field_leaf_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Collect \(\mathcal{H}\)-matrix nodes in the leaf set into a vector using Z-curve traversal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_leaf_set</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l18469">18469</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

</div>
</div>
<a id="a695ef43b376e704f3436447d3fda24de" name="a695ef43b376e704f3436447d3fda24de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695ef43b376e704f3436447d3fda24de">&#9670;&nbsp;</a></span>_compute_cholesky_factorization() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_compute_cholesky_factorization </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Internal recursive function to be called by <code>{c++} <a class="el" href="classHMatrix.html#abc6e787e46fb082579b2d3aea1ad54f6">HMatrix::compute_cholesky_factorization(const unsigned int fixed_rank)</a>. </code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and the Cholesky factorization can be directly applied to it using LAPACK.</p>
<p >N.B. Unlike the LU factorization, the Cholesky factorization performed by LAPACK has no pivoting.</p>
<p >After the Cholesky factorization, the matrix <code>L</code> is stored in the same full matrix. Hence, this operation is in situ.</p>
<p >At present, Cholesky factorization is only to be applied to square matrix and block square matrix.</p>
<p >When the current \(\mathcal{H}\)-matrix node is not a leaf, iterate over each block row.</p>
<p >Iterate over each block column from beginning to the diagonal block.</p>
<p >Iterate over each block column before the \(j\)-th column.</p>
<p ><b>2022-04-24 When \(i\equiv j\), the product \(L_{ik}\cdot L_{jk}^T\) is a symmetric matrix, which needs a special treatment when it is to be added to the symmetric \(\mathcal{H}\)-matrix \(Z\). Because the property of the \(\mathcal{H}\)-matrix block \(L_{ik}\) is <code>general</code> not <code>symmetric</code>, all of its submatrices have been allocated with memory, while the symmetric block \(Z\) only stores its diagonal and lower triangular blocks, which cannot accept values assembled form the upper triangular part.</b></p>
<p >When the current block column is before the i'th column, solve \(L_{ij} L_{jj}^T = M_{ij}\) using the matrix-valued Cholesky transposed forward substitution.</p>
<p >When coming to the diagonal block, go down one level of recursion for Cholesky factorization.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l33804">33804</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>.</p>

</div>
</div>
<a id="a369057ef4f20f12494faa8261cbaf233" name="a369057ef4f20f12494faa8261cbaf233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369057ef4f20f12494faa8261cbaf233">&#9670;&nbsp;</a></span>_compute_cholesky_factorization() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_compute_cholesky_factorization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Internal recursive function to be called by </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">HMatrix::compute_cholesky_fatorization(<a class="code hl_class" href="classHMatrix.html">HMatrix&lt;spacedim, Number&gt;</a> &amp;L,</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fixed_rank).</div>
<div class="ttc" id="aclassHMatrix_html"><div class="ttname"><a href="classHMatrix.html">HMatrix</a></div><div class="ttdef"><b>Definition:</b> <a href="hmatrix_8h_source.html#l00103">hmatrix.h:104</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and the Cholesky factorization can be directly applied to it using LAPACK.</p>
<p >N.B. Unlike the LU factorization, the Cholesky factorization performed by LAPACK has no pivoting.</p>
<p >Copy the full matrix from the source matrix to the result matrix <code>L</code>. <b>N.B. The result matrix <code>L</code> is lower triangular, so the associated full matrix is also lower triangular. However, after copying the data from <code>this-&gt;fullmatrix</code> to <code>L.fullmatrix</code>, the property of <code>L.fullmatrix</code> has been overwritten as <code>symmetric</code>, which is just what we desire, since full matrix Cholesky factorization will be applied to <code>L.fullmatrix</code>.</b></p>
<p >After the Cholesky factorization, the matrix <code>L</code> is stored in the same full matrix. Hence, this operation is in situ.</p>
<p >At present, Cholesky factorization is only to be applied to square matrix and block square matrix.</p>
<p >When the current \(\mathcal{H}\)-matrix node is not a leaf, iterate over each block row.</p>
<p >Iterate over each block column from beginning to the diagonal block.</p>
<p >Create a local \(\mathcal{H}\)-matrix \(Z_{ij}\) as the new RHS matrix.</p>
<p >Iterate over each block column before the \(j\)-th column.</p>
<p ><b>2022-04-24 When \(i\equiv j\), the product \(L_{ik}\cdot L_{jk}^T\) is a symmetric matrix, which needs a special treatment when it is to be added to the symmetric \(\mathcal{H}\)-matrix \(Z\). Because the property of the \(\mathcal{H}\)-matrix block \(L_{ik}\) is <code>general</code> not <code>symmetric</code>, all of its submatrices have been allocated with memory, while the symmetric block \(Z\) only stores its diagonal and lower triangular blocks, which cannot accept values assembled form the upper triangular part.</b></p>
<p >When the current block column is before the i'th column, solve \(L_{ij} L_{jj}^T = M_{ij}\) using the matrix-valued Cholesky transposed forward substitution.</p>
<p >When coming to the diagonal block, go down one level of recursion for Cholesky factorization.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l33644">33644</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04263">HMatrix&lt; spacedim, Number &gt;::property</a>, and <a class="el" href="hmatrix_8h_source.html#l04257">HMatrix&lt; spacedim, Number &gt;::state</a>.</p>

</div>
</div>
<a id="ac9e36fb4ecad2198fbf4cc612ea47132" name="ac9e36fb4ecad2198fbf4cc612ea47132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e36fb4ecad2198fbf4cc612ea47132">&#9670;&nbsp;</a></span>_compute_lu_factorization() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_compute_lu_factorization </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Internal recursive function to be called by </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line"><a class="code hl_function" href="classHMatrix.html#af2bf0581bcf6d1319b661d0f0527ffc9">HMatrix::compute_lu_factorization</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fixed_rank).</div>
<div class="ttc" id="aclassHMatrix_html_af2bf0581bcf6d1319b661d0f0527ffc9"><div class="ttname"><a href="classHMatrix.html#af2bf0581bcf6d1319b661d0f0527ffc9">HMatrix::compute_lu_factorization</a></div><div class="ttdeci">void compute_lu_factorization(HMatrix&lt; spacedim, Number &gt; &amp;LU, const unsigned int fixed_rank)</div><div class="ttdef"><b>Definition:</b> <a href="hmatrix_8h_source.html#l32473">hmatrix.h:32473</a></div></div>
</div><!-- fragment --><p >This algorithm is in situ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and the LU factorization can be directly applied to it using LAPACK.</p>
<p >N.B. The LU factorization performed by LAPACK has row partial pivoting.</p>
<p >After the LU factorization, L and U matrices are stored in the same full matrix. Hence, this operation is in situ.</p>
<p >At present, LU factorization is only to be applied to square matrix and block square matrix.</p>
<p >When the current \(\mathcal{H}\)-matrix node is not a leaf, iterate over each block row.</p>
<p >Iterate over each block column.</p>
<p >Iterate over each block column before the \(\min\{i,
j\}\)-th column using the loop counter \(k\). The corresponding submatrix product \(L_{i,k}U_{k,j}\) needs to be subtracted from the RHS submatrix \(M_{ij}\).</p>
<p >When the current block column is before the i'th column, solve \(L_{ij} U_{jj}=M_{ij}\) to get \(L_{ij}\) using the matrix-valued transposed forward substitution.</p>
<p >When the current block column is i, go down one level of recursion for LU factorization.</p>
<p >Solve \(L_{ii}U_{ij}=M_{ij}\) for \(L_{ii}\).</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l32615">32615</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>.</p>

</div>
</div>
<a id="ae706d9ed5f2a0ad239624294efd81b81" name="ae706d9ed5f2a0ad239624294efd81b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae706d9ed5f2a0ad239624294efd81b81">&#9670;&nbsp;</a></span>_compute_lu_factorization() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_compute_lu_factorization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>LU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Internal recursive function to be called by </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line"><a class="code hl_function" href="classHMatrix.html#af2bf0581bcf6d1319b661d0f0527ffc9">HMatrix::compute_lu_factorization</a>(<a class="code hl_class" href="classHMatrix.html">HMatrix&lt;spacedim, Number&gt;</a> &amp;LU, <span class="keyword">const</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fixed_rank).</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LU</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and the LU factorization can be directly applied to it using LAPACK.</p>
<p >N.B. The LU factorization performed by LAPACK has row partial pivoting.</p>
<p >Copy the full matrix from the source matrix to the result matrix <code>LU</code>.</p>
<p >After the LU factorization, L and U matrices are stored in the same full matrix. Hence, this operation is in situ.</p>
<p >At present, LU factorization is only to be applied to square matrix and block square matrix.</p>
<p >When the current \(\mathcal{H}\)-matrix node is not a leaf, iterate over each block row.</p>
<p >Iterate over each block column.</p>
<p >Iterate over each block column before the \(\min\{i,
j\}\)-th column using the loop counter \(k\). The corresponding submatrix product \(L_{i,k}U_{k,j}\) needs to be subtracted from the RHS submatrix \(M_{ij}\).</p>
<p >Create a local \(\mathcal{H}\)-matrix \(Z_{ij}\) as the new RHS matrix.</p>
<p >When the current block column is before the i'th column, solve \(L_{ij} U_{jj}=M_{ij}\) to get \(L_{ij}\) using the matrix-valued transposed forward substitution.</p>
<p >When the current block column is i, go down one level of recursion for LU factorization.</p>
<p >Solve \(L_{ii}U_{ij}=M_{ij}\) for \(L_{ii}\).</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l32504">32504</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>.</p>

</div>
</div>
<a id="a0510ed1e0356059a449d01ba3182fb1d" name="a0510ed1e0356059a449d01ba3182fb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0510ed1e0356059a449d01ba3182fb1d">&#9670;&nbsp;</a></span>_convertToFullMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_convertToFullMatrix </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em> = <code>HMatrixSupport::Property::general</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Convert an <a class="el" href="classHMatrix.html">HMatrix</a> to a full matrix by recursion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >In principle, we should make assertion here that the block type of the top level \(\mathcal{H}\)-matrix should be diagonal. However, this also requires to pass the block type of the top level \(\mathcal{H}\)-matrix into this function. To simplify the calling of this function, we do not make the assertion.</p>
<p >In principle, we should make assertion here that the block type of the top level \(\mathcal{H}\)-matrix should be diagonal. However, this also requires to pass the block type of the top level \(\mathcal{H}\)-matrix into this function. To simplify the calling of this function, we do not make the assertion.</p>
<p >Only when the converted full matrix is not zero-valued, the values will be copied to the full matrix.</p>
<p >In principle, we should make assertion here that the block type of the top level \(\mathcal{H}\)-matrix should be diagonal. However, this also requires to pass the block type of the top level \(\mathcal{H}\)-matrix into this function. To simplify the calling of this function, we do not make the assertion.</p>
<p >Only when the converted full matrix is not zero-valued, the values will be copied to the full matrix.</p>
<p >In principle, we should make assertion here that the block type of the top level \(\mathcal{H}\)-matrix should be diagonal. However, this also requires to pass the block type of the top level \(\mathcal{H}\)-matrix into this function. To simplify the calling of this function, we do not make the assertion.</p>
<p >Only when the converted full matrix is not zero-valued, the values will be copied to the full matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l18170">18170</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>.</p>

</div>
</div>
<a id="a187e0c009a7c28679df7e92e0b01929c" name="a187e0c009a7c28679df7e92e0b01929c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187e0c009a7c28679df7e92e0b01929c">&#9670;&nbsp;</a></span>_distribute_sigma_r_and_f_to_leaves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Restrict each rank-k matrix in the list <code>Sigma_R</code> of <code>starting_hmat</code> to the block as a full matrix.</p>
<p >Restrict each full matrix in the list <code>Sigma_F</code> of <code>starting_hmat</code> to the block as a full matrix.</p>
<p >Restrict each rank-k matrix in the list <code>Sigma_R</code> of <code>starting_hmat</code> to the block as a rank-k matrix.</p>
<p >Restrict each full matrix in the list <code>Sigma_F</code> of <code>starting_hmat</code> to the block as a rank-k matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l18760">18760</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="rkmatrix_8h_source.html#l02555">RkMatrix&lt; Number &gt;::restrictToFullMatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04403">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, and <a class="el" href="hmatrix_8h_source.html#l04397">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>.</p>

</div>
</div>
<a id="af74e3b0c19e9178cfe699a6620a51170" name="af74e3b0c19e9178cfe699a6620a51170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74e3b0c19e9178cfe699a6620a51170">&#9670;&nbsp;</a></span>_invert_by_gauss_elim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_invert_by_gauss_elim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Calculate the inverse of the \(\mathcal{H}\)-matrix node via Gauss elimination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M_inv</td><td></td></tr>
    <tr><td class="paramname">M_root</td><td>The \(\mathcal{H}\)-matrix node from which this recursive function is called for the first time. </td></tr>
    <tr><td class="paramname">M_root_bct</td><td>The block cluster tree associated with <code>M_root</code>. </td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >If the current matrix block to be handled has a same \(\tau\) cluster and \(\sigma\) cluster and belongs to the leaf set of <code>M_root</code>, directly calculate its inverse as full matrix.</p>
<p ><b>2021-10-05 At present, we assume the \(\mathcal{H}\)-matrix hierarchy is completely the same as the associated block cluster tree, or rather, the block cluster tree is not finer than the \(\mathcal{H}\)-matrix. Therefore, whether the block cluster node is a leaf is equivalent to whether the \(\mathcal{H}\)-matrix node is a leaf. In a more generalized implementation, the block cluster tree can be finer than the \(\mathcal{H}\)-matrix hierarchy.</b></p>
<p >Number of matrix blocks in a row, which is also the number of matrix blocks in a column.</p>
<p >Stage 1: eliminate the lower triangular part of the matrix.</p>
<p >Calculate the inverse of the diagonal block \(M
\vert_{\tau[l]\times\tau[l]}\). The formula \(l + l \cdot
k\) calculates the 1D index of the diagonal block in <code>submatrices</code>. This is because the submatrices of the current \(\mathcal{H}\)-matrix node is stored in the following order:</p>
<p ><code> submatrices = {tau[0]*sigma[0], tau[0]*sigma[1], tau[1]*sigma[0], tau[1]*sigma[1]} </code></p>
<p >Since \(\tau\) is the same as \(\sigma\), we have</p>
<p ><code> submatrices = {tau[0]*tau[0], tau[0]*tau[1], tau[1]*tau[0], tau[1]*tau[1]} </code></p>
<p >Hence, the index of <code>tau</code>[0]*tau[0] in <code>submatrices</code> is 0 and the index of <code>tau</code>[1]*tau[1] in <code>submatrices</code> is 3. The former index is calculated as <code>0 + 0 * 2 = 0</code>, while the latter index is calculated as <code>1 + 1 * 2 = 3</code>.</p>
<p >Iterate over the columns from \(l + 1\) to \(k\) in the source matrix and scale each matrix block with the factor <code>M_inv.submatrices</code>[diag_block_index_in_submatrices]. Also note that the column index starts from zero, therefore the loop variable \(j \in [l+1, k)\).</p>
<p >Migrate the newly created \(\mathcal{H}\)-matrix to the target submatrix.</p>
<p >Iterate over the columns from \(0\) to \(l - 1\) in the inverse matrix and scale each matrix block with the factor <code>M_inv.submatrices</code>[diag_block_index_in_submatrices].</p>
<p >Migrate the newly created \(\mathcal{H}\)-matrix to the target submatrix.</p>
<p >Iterate over the rows from \(l + 1\) to \(k - 1\) in order to eliminate the matrix blocks \(M_{l+1,l}, \cdots,
M_{k - 1,l}\).</p>
<p >Stage 2: eliminate the upper triangular part of the matrix.</p>
<p >Eliminate the elements \(M_{l-1,l}, \cdots, M_{1,l}\).</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35424">35424</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="afd8e08ec263ea524bef3c5c66796c61d" name="afd8e08ec263ea524bef3c5c66796c61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8e08ec263ea524bef3c5c66796c61d">&#9670;&nbsp;</a></span>_print_matrix_info_as_dot_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_print_matrix_info_as_dot_node </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Print the \(\mathcal{H}\)-matrix hierarchy information recursively as a node in the directional graph in Graphviz dot format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Create the graph node for the current \(\mathcal{H}\)-matrix node. When the current \(\mathcal{H}\)-matrix node is a full matrix, use red background. When it is a rank-k matrix, use green background.</p>
<p >Construct the relationship between the current node and its children.</p>
<p >Construct the relationship between the current node and its sequel on a same level, if there is any. The connection edge uses dotted line.</p>
<p >Construct the relationship between the current node and its sequel on a same level and in a same row, if there is any. The connection edge uses red dotted line.</p>
<p >Construct the relationship between the current node and its sequel on a same level and in a same column, if there is any. The connection edge uses green dotted line.</p>
<p >Print each submatrix node.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l20089">20089</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

</div>
</div>
<a id="a9bd48ada567962ab0dc75c31986bd1a6" name="a9bd48ada567962ab0dc75c31986bd1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd48ada567962ab0dc75c31986bd1a6">&#9670;&nbsp;</a></span>add() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add the <a class="el" href="classHMatrix.html">HMatrix</a> <code>B</code> into the current <a class="el" href="classHMatrix.html">HMatrix</a> <code>A</code>, i.e. whole matrix addition instead of addition limited to a specific block, where <code>C</code> will be truncated to a fixed rank <code>fixed_rank</code>.</p>
<p >This algorithm is intrinsically recursive, i.e. the addition of parent HMatrices will perform the addition of each pair of child HMatrices corresponding to a same block cluster. Strictly speaking, this member function <code>add</code> is not a recursive function, because the class instance which calls <code>add</code> changes from parent to child <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >N.B. The two operands should have the same partition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p ><b>Work flow</b></p>
<p >Recursively add each pair of submatrices.</p>
<p >Perform addition of full matrices.</p>
<p >Perform addition of rank-k matrices.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29529">29529</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="hmatrix_8h_source.html#l00070">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="af42aaa86b9f47c5c1514e4f06e343db6" name="af42aaa86b9f47c5c1514e4f06e343db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42aaa86b9f47c5c1514e4f06e343db6">&#9670;&nbsp;</a></span>add() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Perform the addition \(A = A + b B\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>
<p ><b>Work flow</b></p>
<p >Recursively add each pair of submatrices.</p>
<p >Perform addition of full matrices.</p>
<p >Perform addition of rank-k matrices.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29574">29574</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="hmatrix_8h_source.html#l00070">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a89d58db68b297aa5da7f772354775b3a" name="a89d58db68b297aa5da7f772354775b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d58db68b297aa5da7f772354775b3a">&#9670;&nbsp;</a></span>add() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add a rank-k matrix multiplied by a factor into the current \(\mathcal{H}\)-matrix node.</p>
<p >The rank-k matrix will be restricted to each leaf node of the \(\mathcal{H}\)-matrix node and the addition will be performed there. In this implementation, the row and column index ranges with respect to <code>B</code> are the same as those associated with the \(\mathcal{H}\)-matrix, i.e. the rank-k matrix and \(\mathcal{H}\)-matrix are on a same block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30103">30103</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="rkmatrix_8h_source.html#l02471">RkMatrix&lt; Number &gt;::get_m()</a>.</p>

</div>
</div>
<a id="a76c14a1ea5579fd8a3b80aec78567cfb" name="a76c14a1ea5579fd8a3b80aec78567cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c14a1ea5579fd8a3b80aec78567cfb">&#9670;&nbsp;</a></span>add() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B_row_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B_col_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add a rank-k matrix multiplied by a factor into the current \(\mathcal{H}\)-matrix node.</p>
<p >The rank-k matrix will be restricted to each leaf node of the \(\mathcal{H}\)-matrix node and the addition will be performed there. In this implementation, the row and column global to local index maps with respect to <code>B</code> should be explicitly provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >When the result matrix is expected to be symmetric or lower triangular, we perform assertions about its property and block type.</p>
<p >When the result matrix has children and is expected to be a symmetric matrix, the addition operation will not be carried out for the upper triangular part. Otherwise, perform the recursive addition as usual.</p>
<p >Restrict the rank-k matrix to the local full matrix then perform the addition with the leaf node of the \(\mathcal{H}\)-matrix.</p>
<p >When the current \(\mathcal{H}\)-matrix node is a full matrix, i.e. belongs to the near field, it can belong to either the diagonal part or off-diagonal part. When the current matrix is symmetric, it must be a diagonal block. Then, the addition will be carried out for the full matrix elements in the diagonal part and in the lower triangular part only.</p>
<dl class="section note">
<dt>Note</dt>
<dd>When the current \(\mathcal{H}\)-matrix node is a rank-k matrix, it belongs to the far field, which itself cannot be a symmetric \(\mathcal{H}\)-matrix and belongs to the diagonal part. Hence, in this case, the flag <code>is_result_matrix_symm_apriori</code> will not be checked and all matrix elements will be added into the result rank-k matrix.</dd>
</dl>
<p >Create a local rank-k matrix by restricting from the original large rank-k matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29941">29941</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="rkmatrix_8h_source.html#l02555">RkMatrix&lt; Number &gt;::restrictToFullMatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00070">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a59d4010167d34c910836f2e40009fb6d" name="a59d4010167d34c910836f2e40009fb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d4010167d34c910836f2e40009fb6d">&#9670;&nbsp;</a></span>add() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add a rank-k matrix into the current \(\mathcal{H}\)-matrix node.</p>
<p >The rank-k matrix will be restricted to each leaf node of the \(\mathcal{H}\)-matrix node and the addition will be performed there respectively. In this implementation, the row and column index ranges with respect to <code>B</code> are the same as those associated with the \(\mathcal{H}\)-matrix, i.e. the rank-k matrix and \(\mathcal{H}\)-matrix are on a same block.</p>
<p >When the flag <code>is_result_matrix_symm_apriori</code> is true, the result matrix is known to be symmetric a priori. Then, the internal addition operation on upper triangular part will be ignored. If the addition operation is performed on a diagonal full matrix block, only its diagonal and lower triangular elements will be computed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30068">30068</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="rkmatrix_8h_source.html#l02471">RkMatrix&lt; Number &gt;::get_m()</a>.</p>

</div>
</div>
<a id="ac05e22ca9cdc2131accd6a32e4f1dffe" name="ac05e22ca9cdc2131accd6a32e4f1dffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05e22ca9cdc2131accd6a32e4f1dffe">&#9670;&nbsp;</a></span>add() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B_row_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B_col_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add a rank-k matrix into the current \(\mathcal{H}\)-matrix node.</p>
<p >The rank-k matrix will be restricted to each leaf node of the \(\mathcal{H}\)-matrix node and the addition will be performed there. In this implementation, the row and column global to local index maps with respect to <code>B</code> should be explicit provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >When the result matrix is expected to be symmetric, Hermite symmetric or lower triangular, we perform assertions about its property and block type.</p>
<p >When the result matrix has children and is expected to be a symmetric/lower triangular matrix, the addition operation will not be carried out for the upper triangular part. Otherwise, perform the recursive addition as usual. <b>We should also note that even though the current \(\mathcal{H}\)-matrix node is symmetric/lower triangular, not all of its submatrices are symmetric/lower triangular, i.e. only the first and the last submatrices are symmetric/lower triangular and belong to the diagonal part.</b></p>
<p >Restrict the rank-k matrix to the local full matrix then perform the addition with the leaf node of the \(\mathcal{H}\)-matrix.</p>
<p >When the current \(\mathcal{H}\)-matrix node is a full matrix, i.e. belongs to the near field, it can belong to either the diagonal part or off-diagonal part. When the current matrix is symmetric, it must be a diagonal block. Then, the addition will be carried out for the full matrix elements in the diagonal part and in the lower triangular part only.</p>
<p ><b>2022-05-06 The explicit type cast here for <code>fullmatrix_from_rk</code> is mandatory, otherwise the compiler will complain about the ambiguity during looking for a matched overloaded function of <code><a class="el" href="classLAPACKFullMatrixExt.html#a29db0215128c03cac93f6ecdb8a98c0a">LAPACKFullMatrixExt::add</a></code>.</b></p>
<dl class="section note">
<dt>Note</dt>
<dd>When the current \(\mathcal{H}\)-matrix node is a rank-k matrix, it belongs to the far field, which itself cannot be a symmetric \(\mathcal{H}\)-matrix and belongs to the diagonal part. Hence, in this case, the flag <code>is_result_matrix_symm_apriori</code> will not be checked and all matrix elements will be added into the result rank-k matrix. But still, we make an assertion here that the result matrix should not be symmetric.</dd>
</dl>
<p >Create a local rank-k matrix by restricting from the original large rank-k matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29620">29620</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="rkmatrix_8h_source.html#l02555">RkMatrix&lt; Number &gt;::restrictToFullMatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00070">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a8f96186426cd3147d5af32ca84ad25ea" name="a8f96186426cd3147d5af32ca84ad25ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f96186426cd3147d5af32ca84ad25ea">&#9670;&nbsp;</a></span>add() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add the current <a class="el" href="classHMatrix.html">HMatrix</a> <code>A</code> with another <a class="el" href="classHMatrix.html">HMatrix</a> <code>B</code> into <code>C</code>, i.e. whole matrix addition instead of addition limited to a specific block, where <code>C</code> will be truncated to a fixed rank <code>fixed_rank</code>.</p>
<p >This algorithm is intrinsically recursive, i.e. the addition of parent HMatrices will perform the addition of each pair of child HMatrices corresponding to a same block cluster. Strictly speaking, this member function <code>add</code> is not a recursive function, because the class instance which calls <code>add</code> changes from parent to child <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p >N.B.</p>
<ol type="1">
<li>The two operands should have the same partition.</li>
<li>The hierarchical structure of <code>C</code> should be pre-generated.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p ><b>Work flow</b></p>
<p >Recursively add each pair of submatrices.</p>
<p >Perform addition of full matrices.</p>
<p >Perform addition of rank-k matrices.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29431">29431</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="hmatrix_8h_source.html#l00070">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l30202">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="hmatrix_8h_source.html#l16039">h_h_mmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l16558">h_h_mTmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l17073">h_h_Tmmult_level_conserving()</a>, and <a class="el" href="hmatrix_8h_source.html#l29298">HMatrix&lt; spacedim, Number &gt;::mmult()</a>.</p>

</div>
</div>
<a id="aea42f5112b88270fef73342853fa386d" name="aea42f5112b88270fef73342853fa386d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea42f5112b88270fef73342853fa386d">&#9670;&nbsp;</a></span>add() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Perform the addition with factor \(C = A + b B\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>
<p ><b>Work flow</b></p>
<p >Recursively add each pair of submatrices.</p>
<p >Perform addition of full matrices.</p>
<p >Perform addition of rank-k matrices.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29479">29479</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04350">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04344">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="hmatrix_8h_source.html#l00070">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="af66071b53145fe007ac040fa0c4b47c6" name="af66071b53145fe007ac040fa0c4b47c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66071b53145fe007ac040fa0c4b47c6">&#9670;&nbsp;</a></span>add() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Perform the \(\mathcal{H}\)-matrix addition \(C = A + b B\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30213">30213</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l29431">HMatrix&lt; spacedim, Number &gt;::add()</a>.</p>

</div>
</div>
<a id="a403d72a5eea3912d67fd0807ddd0baf8" name="a403d72a5eea3912d67fd0807ddd0baf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403d72a5eea3912d67fd0807ddd0baf8">&#9670;&nbsp;</a></span>add() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Perform the \(\mathcal{H}\)-matrix addition \(C = A + B\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30202">30202</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l29431">HMatrix&lt; spacedim, Number &gt;::add()</a>.</p>

</div>
</div>
<a id="a3dcce49f50f1c4490e4aeaa48e074b67" name="a3dcce49f50f1c4490e4aeaa48e074b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcce49f50f1c4490e4aeaa48e074b67">&#9670;&nbsp;</a></span>add_for_parallel_lu_or_cholesky() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add_for_parallel_lu_or_cholesky </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30085">30085</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a158984c444bbbb0b76e33fded6e1ab5b" name="a158984c444bbbb0b76e33fded6e1ab5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158984c444bbbb0b76e33fded6e1ab5b">&#9670;&nbsp;</a></span>add_for_parallel_lu_or_cholesky() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add_for_parallel_lu_or_cholesky </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B_row_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; types::global_dof_index, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B_col_index_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >When the result matrix is expected to be symmetric or lower triangular, we perform assertions about its property and block type.</p>
<p >When the result matrix has children and is expected to be a symmetric/lower triangular matrix, the addition operation will not be carried out for the upper triangular part. Otherwise, perform the recursive addition as usual. <b>We should also note that even though the current \(\mathcal{H}\)-matrix node is symmetric/lower triangular, not all of its submatrices are symmetric/lower triangular, i.e. only the first and the last submatrices are symmetric/lower triangular and belong to the diagonal part.</b></p>
<p >2024-01-13 N.B. The current submatrix <code>submatrices</code>[i] may still have its own hierarchical structure, hence, <code>add_for_parallel_lu_or_cholesky</code> should be recursively called.</p>
<p >2024-01-13 N.B. The current submatrix <code>submatrices</code>[i] may still have its own hierarchical structure, hence, <code>add_for_parallel_lu_or_cholesky</code> should be recursively called.</p>
<p >Restrict the rank-k matrix to the local full matrix then perform the addition with the leaf node of the \(\mathcal{H}\)-matrix.</p>
<p >When the current \(\mathcal{H}\)-matrix node is a full matrix, i.e. belongs to the near field, it can belong to either the diagonal part or off-diagonal part. When the current matrix is symmetric, it must be a diagonal block. Then, the addition will be carried out for the full matrix elements in the diagonal part and in the lower triangular part only.</p>
<p >When we come to the addition into a leaf \(\mathcal{H}\)-matrix node, the mutex should be locked.</p>
<p ><b>2022-05-06 The explicit type cast here for <code>fullmatrix_from_rk</code> is mandatory, otherwise the compiler will complain about the ambiguity during looking for a matched overloaded function of <code><a class="el" href="classLAPACKFullMatrixExt.html#a29db0215128c03cac93f6ecdb8a98c0a">LAPACKFullMatrixExt::add</a></code>.</b></p>
<dl class="section note">
<dt>Note</dt>
<dd>When the current \(\mathcal{H}\)-matrix node is a rank-k matrix, it belongs to the far field, which itself cannot be a symmetric \(\mathcal{H}\)-matrix and belongs to the diagonal part. Hence, in this case, the flag <code>is_result_matrix_symm_apriori</code> will not be checked and all matrix elements will be added into the result rank-k matrix. But still, we make an assertion here that the result matrix should not be symmetric.</dd>
</dl>
<p >Create a local rank-k matrix by restricting from the original large rank-k matrix.</p>
<p >When we come to the addition into a leaf \(\mathcal{H}\)-matrix node, the mutex should be locked.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29758">29758</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="config_8h_source.html#l00059">ARENA_MAX_CONCURRENCY_IN_LU_AND_CHOL</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="rkmatrix_8h_source.html#l02555">RkMatrix&lt; Number &gt;::restrictToFullMatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00070">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="ac72668962dbad336f0c289bbd060e6ce" name="ac72668962dbad336f0c289bbd060e6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72668962dbad336f0c289bbd060e6ce">&#9670;&nbsp;</a></span>addsym_diag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::addsym_diag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add the error matrix \(EE^H\) recursively to the leaf diagonal blocks of the current \(\mathcal{H}\)-matrix node for preserving positive definiteness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Only when the error matrix has non-zero dimension, there will be actual addition to the diagonal blocks.</p>
<p >Make an assertion that the current \(\mathcal{H}\)-matrix node should be a diagonal block.</p>
<p >When the current \(\mathcal{H}\)-matrix node is a leaf node, since it is a diagonal block, it must be a full matrix. Then, we directly add \(EE^H\) into the current \(\mathcal{H}\)-matrix node.</p>
<p >Make an assertion that the current \(\mathcal{H}\)-matrix node should have submatrices.</p>
<p >Restrict the rows of the error matrix \(E\) to the cluster \(t_1\).</p>
<p >Restrict the rows of the error matrix \(E\) to the cluster \(t_2\).</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30122">30122</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="lapack__full__matrix__ext_8h_source.html#l04563">LAPACKFullMatrixExt&lt; Number &gt;::fill_row()</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, and <a class="el" href="lapack__full__matrix__ext_8h_source.html#l05545">LAPACKFullMatrixExt&lt; Number &gt;::mTmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l20951">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank_off_diag_preserve_positive_definite()</a>.</p>

</div>
</div>
<a id="a866f076c7c0535e6d824505ac4f58e96" name="a866f076c7c0535e6d824505ac4f58e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866f076c7c0535e6d824505ac4f58e96">&#9670;&nbsp;</a></span>assign_node_ids_for_dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::assign_node_ids_for_dot</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assign IDs to \(\mathcal{H}\)-matrix nodes, which will be used to generate the dot directed graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_id</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Push all submatrix nodes of the current \(\mathcal{H}\)-matrix node into the queue, if there is any.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l20060">20060</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04279">HMatrix&lt; spacedim, Number &gt;::dot_node_id</a>, and <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>.</p>

</div>
</div>
<a id="a139f32982527ba981e0211b5663e3b43" name="a139f32982527ba981e0211b5663e3b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139f32982527ba981e0211b5663e3b43">&#9670;&nbsp;</a></span>build_leaf_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::build_leaf_set</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Build the leaf set of the current \(\mathcal{H}\)-matrix node. </p>
<p >The top level \(\mathcal{H}\)-matrix is type A.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35914">35914</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l36166">HMatrix&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees()</a>, <a class="el" href="hmatrix_8h_source.html#l30225">HMatrix&lt; spacedim, Number &gt;::invert_by_gauss_elim()</a>, and <a class="el" href="hmatrix_8h_source.html#l29207">HMatrix&lt; spacedim, Number &gt;::mmult()</a>.</p>

</div>
</div>
<a id="a72191c447afaa0fd84505022cf1d174e" name="a72191c447afaa0fd84505022cf1d174e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72191c447afaa0fd84505022cf1d174e">&#9670;&nbsp;</a></span>calc_rank_upper_bound_for_rkmatrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::calc_rank_upper_bound_for_rkmatrices</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate and set the rank upper bound for each rank-k matrix in the \(\mathcal{H}\)-matrix hierarchy. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19788">19788</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

</div>
</div>
<a id="ab34153f643b74f566e992a24c7ec7be0" name="ab34153f643b74f566e992a24c7ec7be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34153f643b74f566e992a24c7ec7be0">&#9670;&nbsp;</a></span>cholesky_assign_update_to_solve_and_factorize_dependencies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::cholesky_assign_update_to_solve_and_factorize_dependencies</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Build task dependencies between <code>update</code> tasks, <code>solve_upper</code> tasks and <code>factorize</code> tasks.</p>
<p >The following operations will be performed:</p>
<ol type="1">
<li>Build <code>update</code> task to <code>solve_upper</code> task dependencies.</li>
<li>Transfer the <code>update</code> tasks of the current \(\mathcal{H}\)-matrix node to its descendants.</li>
<li>Build <code>update</code> task to <code>factorize</code> task dependencies.</li>
<li>Build task dependencies between <code>factorize</code> tasks on successive \(\mathcal{H}\)-matrix levels. </li>
</ol>
<p >Collect <code>update</code> task nodes from child \(\mathcal{H}\)-matrix nodes and build the task edges from <code>update</code> to <code>solve_upper</code> or <code>solve_lower</code>.</p>
<p >In this case, the \(\mathcal{H}\)-matrix node is either upper or lower triangular, which cannot be a diagonal block, nor of its descendants. Therefore, there will be no task edges from <code>update</code> to <code>factorize</code> anymore.</p>
<p >For the top level \(\mathcal{H}\)-matrix node, it is a diagonal block but has no factorization task with it. Therefore, here we check if the factorization task node exists.</p>
<p >Build the dependency between factorization task nodes on successive levels, i.e. after all diagonal blocks on a deeper level are factorized, their parent diagonal block can then be factorized.</p>
<p >After processing the diagonal block, the algorithm continues to shift down update task nodes to child \(\mathcal{H}\)-matrix nodes.</p>
<p >Shift down the <code>update</code> task nodes.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l34513">34513</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a1d4073e87db371d706761a861b229119" name="a1d4073e87db371d706761a861b229119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4073e87db371d706761a861b229119">&#9670;&nbsp;</a></span>cholesky_build_update_to_factorize_dependencies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::cholesky_build_update_to_factorize_dependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>factorize_block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create the task node dependencies from <code>update</code> task to <code>factorize</code> task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factorize_node</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Recursion into child matrices except upper triangular blocks.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l34422">34422</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04409">HMatrix&lt; spacedim, Number &gt;::factorize_lu_or_cholesky_graph_node</a>, and <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>.</p>

</div>
</div>
<a id="a41bbad9065a8ade27dda7f5d95514272" name="a41bbad9065a8ade27dda7f5d95514272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bbad9065a8ade27dda7f5d95514272">&#9670;&nbsp;</a></span>cholesky_build_update_to_solve_upper_dependencies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::cholesky_build_update_to_solve_upper_dependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>solve_upper_block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create the task node dependencies from <code>update</code> task to <code>solve_upper</code> task by starting from a \(\mathcal{H}\)-matrix node which is itself associated with a <code>solve_upper</code> task node. </p>
<p >Recursion into child matrices except upper triangular blocks.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l34463">34463</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, and <a class="el" href="hmatrix_8h_source.html#l04414">HMatrix&lt; spacedim, Number &gt;::solve_upper_or_lower_lu_or_cholesky_graph_node</a>.</p>

</div>
</div>
<a id="afe7c81260b52fba9ef1be63e180e43c5" name="afe7c81260b52fba9ef1be63e180e43c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7c81260b52fba9ef1be63e180e43c5">&#9670;&nbsp;</a></span>cholesky_factorize_diagonal_block_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::cholesky_factorize_diagonal_block_task </td>
          <td>(</td>
          <td class="paramtype">tbb::flow::graph &amp;&#160;</td>
          <td class="paramname"><em>dag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mutex &amp;&#160;</td>
          <td class="paramname"><em>log_stream_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a task node for the Cholesky factorization of the current diagonal block. It only has actual computation when the current \(\mathcal{H}\)-matrix node belongs to the leaf set. </p>
<p >Only a diagonal block can be directly factorized.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a symmetric full matrix and the Cholesky factorization can be directly applied to it using LAPACK.</p>
<p >After the Cholesky factorization, the matrix <code>L</code> is stored in the same full matrix. Hence, this operation is in situ.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l34273">34273</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l33933">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_dag()</a>.</p>

</div>
</div>
<a id="a009b339cb4be6fa51afa70d6f9d06c2d" name="a009b339cb4be6fa51afa70d6f9d06c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009b339cb4be6fa51afa70d6f9d06c2d">&#9670;&nbsp;</a></span>cholesky_solve_upper_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::cholesky_solve_upper_task </td>
          <td>(</td>
          <td class="paramtype">tbb::flow::graph &amp;&#160;</td>
          <td class="paramname"><em>dag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mutex &amp;&#160;</td>
          <td class="paramname"><em>log_stream_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Solve the problem of \(XL^T=Z\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dag</td><td></td></tr>
    <tr><td class="paramname">Z</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be a diagonal block, while \(Z\) is not.</p>
<p >There should be no <code>solve_upper</code> task associated with the \(\mathcal{H}\)-matrix node \(Z\).</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l34326">34326</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, and <a class="el" href="hmatrix_8h_source.html#l04414">HMatrix&lt; spacedim, Number &gt;::solve_upper_or_lower_lu_or_cholesky_graph_node</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l33933">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_dag()</a>.</p>

</div>
</div>
<a id="a12633037763ee8ea288bd881545c2069" name="a12633037763ee8ea288bd881545c2069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12633037763ee8ea288bd881545c2069">&#9670;&nbsp;</a></span>cholesky_update_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::cholesky_update_task </td>
          <td>(</td>
          <td class="paramtype">tbb::flow::graph &amp;&#160;</td>
          <td class="paramname"><em>dag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>diag_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>diag_column_block1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>diag_column_block2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mutex &amp;&#160;</td>
          <td class="paramname"><em>log_stream_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create the task node for updating the current \(\mathcal{H}\)-matrix node. The task node will be added to the list of update nodes associated with the current \(\mathcal{H}\)-matrix node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dag</td><td></td></tr>
    <tr><td class="paramname">same_level_column_block</td><td>It corresponds to the \(\mathcal{H}\)-matrix node \(L_{ri}\). </td></tr>
    <tr><td class="paramname">same_level_row_block</td><td>It corresponds to the \(\mathcal{H}\)-matrix node \(U_{is}\). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l34370">34370</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, and <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>.</p>

</div>
</div>
<a id="ae55bd45587b895bfdb977e7cbea46519" name="ae55bd45587b895bfdb977e7cbea46519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55bd45587b895bfdb977e7cbea46519">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clear the whole \(\mathcal{H}\)-matrix hierarchy. </p>
<p >Recursively clear submatrices.</p>
<p >Clear the current matrix node.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l18964">18964</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>.</p>

</div>
</div>
<a id="aec0815bc9c3654391bb2b3095383e6cb" name="aec0815bc9c3654391bb2b3095383e6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0815bc9c3654391bb2b3095383e6cb">&#9670;&nbsp;</a></span>clear_hmat_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::clear_hmat_node</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clear the current \(\mathcal{H}\)-matrix node. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l18988">18988</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00070">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a5ccb82bba509fd20ba0e457e740b3fb6" name="a5ccb82bba509fd20ba0e457e740b3fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ccb82bba509fd20ba0e457e740b3fb6">&#9670;&nbsp;</a></span>clear_lu_or_cholesky_task_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::clear_lu_or_cholesky_task_nodes</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clear all LU or Cholesky factorization task nodes. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19022">19022</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a54406262b0d059c179343ec094d16a72" name="a54406262b0d059c179343ec094d16a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54406262b0d059c179343ec094d16a72">&#9670;&nbsp;</a></span>clear_lu_or_cholesky_task_nodes_in_hmat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::clear_lu_or_cholesky_task_nodes_in_hmat</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clear LU or Cholesky factorization task nodes associated with a \(\mathcal{H}\)-matrix node. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19035">19035</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aa448c1380f54e5888c14a180e5156b29" name="aa448c1380f54e5888c14a180e5156b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa448c1380f54e5888c14a180e5156b29">&#9670;&nbsp;</a></span>coarsen_to_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::coarsen_to_partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt;::node_pointer_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Coarsen the current \(\mathcal{H}\)-matrix via recursive call so that its leaf set complies with the given partition. Each rank-k matrix in the \(\mathcal{H}\)-matrix structure will be truncated to <code>fixed_rank_k</code>.</p>
<p >Since this is a recursive member function, it does not execute leaf set rebuilding, which is an operation on the overall \(\mathcal{H}\)-matrix hierarchy.</p>
<p >This member function implements the operator \(\mathcal{T}_{P&#39;
\leftarrow P}^{\mathcal{H} \leftarrow \mathcal{H}}\) for the case \(T(I
\times J, P&#39;) \subset T(I \times J, P)\) in (7.9) in Hackbusch's \(\mathcal{H}\)-matrix book. Because there is no internal check about this, users should ensure this set inclusion relationship.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >N.B. The function call <code>find_pointer_data</code> here involves the comparison of two block cluster nodes, which internally compares the contained two block clusters, which further compares the contained tau node and sigma node pointers. Therefore, at the moment, the inner most comparison is shallow comparison.</p>
<p >The block cluster node associated with the current \(\mathcal{H}\)-matrix node belongs to the given <code>partition</code>. Then \(\mathcal{T}_r^{\mathcal{R}
\leftarrow \mathcal{H}}\) will be applied to this \(\mathcal{H}\)-matrix node.</p>
<p >When the block cluster node associated with the current \(\mathcal{H}\)-matrix node does not belong to the <code>partition</code>, recursively call this same member function of its each child.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35624">35624</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l10017">convertHMatBlockToRkMatrix()</a>, and <a class="el" href="generic__functors_8h_source.html#l00055">find_pointer_data()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l36166">HMatrix&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees()</a>.</p>

</div>
</div>
<a id="aa3f3890fdcdb796d2f262bb21589207d" name="aa3f3890fdcdb796d2f262bb21589207d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f3890fdcdb796d2f262bb21589207d">&#9670;&nbsp;</a></span>coarsen_to_subtree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::coarsen_to_subtree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>subtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Coarsen the current \(\mathcal{H}\)-matrix so that it corresponds to the partition determined by the <code>subtree</code>. Each rank-k matrix in the hierarchical matrix structure will be truncated to <code>fixed_rank_k</code>.</p>
<p >This function calls <code><a class="el" href="classHMatrix.html#aa448c1380f54e5888c14a180e5156b29">HMatrix&lt;spacedim, Number&gt;::coarsen_to_partition</a></code> internally. After that, the leaf set is rebuilt.</p>
<p >This member function implements the operator \(\mathcal{T}_{P&#39;
\leftarrow P}^{\mathcal{H} \leftarrow \mathcal{H}}\) for the case \(T(I
\times J, P&#39;) \subset T(I \times J, P)\) in (7.9) in Hackbusch's \(\mathcal{H}\)-matrix book. Because there is no internal check about this, users should ensure that the given <code>subtree</code> is really a subtree of the block cluster tree associated with this \(\mathcal{H}\)-matrix hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subtree</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35612">35612</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="block__cluster__tree_8h_source.html#l03769">BlockClusterTree&lt; spacedim, Number &gt;::get_leaf_set()</a>.</p>

</div>
</div>
<a id="ab1e028a99709e896e6d922d4bb67ca09" name="ab1e028a99709e896e6d922d4bb67ca09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e028a99709e896e6d922d4bb67ca09">&#9670;&nbsp;</a></span>compute_cholesky_dag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_cholesky_dag </td>
          <td>(</td>
          <td class="paramtype">tbb::flow::graph &amp;&#160;</td>
          <td class="paramname"><em>dag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mutex &amp;&#160;</td>
          <td class="paramname"><em>log_stream_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compute the directed acyclic graph for H-Cholesky factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Iterative over each block row.</p>
<p >Iterate over each matrix blocks on a same level and in a same column from the diagonal block, which corresponds to the <code>solve_upper</code> stage.</p>
<p >Since there is one \(\mathcal{H}\)-matrix node belongs to the leaf set, the following <code>solve_upper</code> task has actual computation and is not recursive.</p>
<p >Create the dependency from factorization of the current diagonal block to the <code>solve_upper</code> task with respect to the current column block.</p>
<p >Iterate over each trailing matrix block on a same level from the diagonal block, which corresponds to the <code>update</code> stage. Both the row and column index sets of the matrix block should be larger than that of the diagonal block.</p>
<p ><code>current_diag_column_block1</code> points to the \(\mathcal{H}\)-matrix node, which is on a same row with the current trailing matrix node. <code>current_diag_column_block2</code> points to the \(\mathcal{H}\)-matrix node, the transpose of which is on a same column with the current trailing matrix node.</p>
<p >Both of them are on a same column with the current diagonal matrix node.</p>
<p >Sift out the matrix blocks having larger row and column index sets than the diagonal block.</p>
<p >Move the pointer <code>current_diag_column_block1</code>, so that it is in a same row with the current trailing block.</p>
<p >When the two column index ranges match.</p>
<p >Move forward <code>current_diag_column_block1</code>.</p>
<p >There is no corresponding same row block for the current trailing block. This is based on the assumption/fact that the index ranges of the same level same column \(\mathcal{H}\)-matrix blocks are increasing.</p>
<p >Move back <code>current_diag_column_block1</code>.</p>
<p >There is no corresponding same row block for the current trailing block. This is based on the assumption/fact that the index ranges of the same level same column \(\mathcal{H}\)-matrix blocks are increasing.</p>
<p >Move the pointer <code>current_diag_column_block2</code>, so that its transpose is in a same column with the current trailing block.</p>
<p >When the two index ranges match.</p>
<p >Move forward <code>current_diag_column_block2</code>.</p>
<p >There is no corresponding same column block for the current trailing block. This is based on the assumption/fact that the index ranges of the same level same column \(\mathcal{H}\)-matrix blocks are increasing.</p>
<p >Move back <code>current_diag_column_block2</code>.</p>
<p >There is no corresponding same column block for the current trailing block. This is based on the assumption/fact that the index ranges of the same level same column \(\mathcal{H}\)-matrix blocks are increasing.</p>
<p >Reset the pointer <code>current_diag_column_block2</code> for the next trailing block if it has touched either end of the doubly linked list.</p>
<p >Reset the pointer <code>current_diag_column_block1</code> for the next trailing block if it has touched either end of the doubly linked list.</p>
<p >Only when the corresponding same level, same row and column (after transpose) block for the current trailing block are found, update task will be added.</p>
<p >Add the update task to the current trailing \(\mathcal{H}\)-matrix node.</p>
<p >Iterate over the sub-block cluster tree associated with <code>current_diag_column_block1</code> and build the edge from <code>solve_upper</code> to the current <code>update</code> node.</p>
<p >Iterate over the sub-block cluster tree associated with <code>current_diag_column_block2</code> and build the edge from <code>solve_upper</code> to the current <code>update</code> node.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l33933">33933</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l34273">HMatrix&lt; spacedim, Number &gt;::cholesky_factorize_diagonal_block_task()</a>, <a class="el" href="hmatrix_8h_source.html#l34326">HMatrix&lt; spacedim, Number &gt;::cholesky_solve_upper_task()</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l33933">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_dag()</a>, <a class="el" href="hmatrix_8h_source.html#l04409">HMatrix&lt; spacedim, Number &gt;::factorize_lu_or_cholesky_graph_node</a>, <a class="el" href="hmatrix_8h_source.html#l19084">HMatrix&lt; spacedim, Number &gt;::is_leaf()</a>, <a class="el" href="hmatrix_8h_source.html#l04294">HMatrix&lt; spacedim, Number &gt;::next_same_level_hmat_node</a>, <a class="el" href="hmatrix_8h_source.html#l04306">HMatrix&lt; spacedim, Number &gt;::next_same_level_same_column_hmat_node</a>, and <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l33933">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_dag()</a>.</p>

</div>
</div>
<a id="abc6e787e46fb082579b2d3aea1ad54f6" name="abc6e787e46fb082579b2d3aea1ad54f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6e787e46fb082579b2d3aea1ad54f6">&#9670;&nbsp;</a></span>compute_cholesky_factorization() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_cholesky_factorization </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compute the Cholesky factorization of an \(\mathcal{H}\)-matrix in situ. Only the lower triangular \(\mathcal{H}\)-matrix factor \(L\) is stored in the original matrix.</p>
<dl class="section note">
<dt>Note</dt>
<dd>Before the factorization, the \(\mathcal{H}\)-matrix has <code>matrix</code> state, <code>symmetric</code> property and <code>diagonal_type</code> block type. After the factorization, it has <code>cholesky</code> state, <code>lower_triangular</code> property and <code>diagonal_type</code> block type.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >After Cholesky factorization, set the state of the current matrix to be <code>cholesky</code> and set its property as <code>lower_triangular</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l33917">33917</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a61481fc8168b811c81e7cbc4da49cdc1" name="a61481fc8168b811c81e7cbc4da49cdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61481fc8168b811c81e7cbc4da49cdc1">&#9670;&nbsp;</a></span>compute_cholesky_factorization() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_cholesky_factorization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compute the Cholesky factorization of an \(\mathcal{H}\)-matrix. Only the lower triangular \(\mathcal{H}\)-matrix factor \(L\) is stored in the output variable <code>L</code>. The matrix \(L\) should have the same hierarchical structure as the original matrix.</p>
<dl class="section note">
<dt>Note</dt>
<dd>1. The result \(\mathcal{H}\)-matrix <code>L</code> should have be constructed and allocated with memory.<ol type="1">
<li>After calling this function, the state of the original \(\mathcal{H}\)-matrix is set to <code>unusable</code>, while the result matrix <code>L</code> has <code>cholesky</code> state and <code>lower_triangular</code> property.</li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >After Cholesky factorization, set the state of the result matrix to be <code>cholesky</code> and that of the original matrix as <code>unusable</code>. Since the property of <code>L</code> is already lower triangular, there is no need to reset it here.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l33785">33785</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l19640">HMatrix&lt; spacedim, Number &gt;::set_state()</a>.</p>

</div>
</div>
<a id="ac25e5d85a53b2f5e1bf035d5874dc04f" name="ac25e5d85a53b2f5e1bf035d5874dc04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25e5d85a53b2f5e1bf035d5874dc04f">&#9670;&nbsp;</a></span>compute_cholesky_factorization_task_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_cholesky_factorization_task_parallel </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compute the Cholesky factorization of an \(\mathcal{H}\)-matrix in situ using task based parallelism. The resulted \(L\) factor is stored in the original \(\mathcal{H}\)-matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Link same level \(\mathcal{H}\)-matrix nodes on the cross of each diagonal block.</p>
<p >Mutex used for monitoring the parallel execution of H-LU factorization.</p>
<p >Build the DAG.</p>
<p >Send a message to the starting task node, i.e. the first leaf node, and trigger the parallel execution of the factorization.</p>
<p >After Cholesky factorization, set the state of the current matrix to be <code>cholesky</code> and set its property as <code>lower_triangular</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35311">35311</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04409">HMatrix&lt; spacedim, Number &gt;::factorize_lu_or_cholesky_graph_node</a>, and <a class="el" href="debug__tools_8h.html#abc4b513edfba014605e6259429800db3">print_wall_time()</a>.</p>

</div>
</div>
<a id="afb916719c90a396362ae2bddfbbe0dc5" name="afb916719c90a396362ae2bddfbbe0dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb916719c90a396362ae2bddfbbe0dc5">&#9670;&nbsp;</a></span>compute_far_field_hmat_assembly_task_cost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_far_field_hmat_assembly_task_cost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compute the task cost for assembling the current far field \(\mathcal{H}\)-matrix node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top_hmat_property</td><td>\(\mathcal{H}\)-matrix property of the top level \(\mathcal{H}\)-matrix node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task cost </dd></dl>
<p >The block type of a far field \(\mathcal{H}\)-matrix node can only be <code>lower_triangular_block</code> or <code>upper_triangular_block</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l34855">34855</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

</div>
</div>
<a id="a513a0cad5bbafc39bf82c260de2ec2a0" name="a513a0cad5bbafc39bf82c260de2ec2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513a0cad5bbafc39bf82c260de2ec2a0">&#9670;&nbsp;</a></span>compute_far_field_hmat_vmult_or_Tvmult_task_cost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_far_field_hmat_vmult_or_Tvmult_task_cost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compute the \(\mathcal{H}\)-matrix/vector multiplication or transposed \(\mathcal{H}\)-matrix/vector multiplication task cost for the current far field \(\mathcal{H}\)-matrix node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top_hmat_property</td><td>\(\mathcal{H}\)-matrix property of the top level \(\mathcal{H}\)-matrix node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task cost </dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l34681">34681</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

</div>
</div>
<a id="ac0d1df9f94ee28a79ef528879090e3b5" name="ac0d1df9f94ee28a79ef528879090e3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d1df9f94ee28a79ef528879090e3b5">&#9670;&nbsp;</a></span>compute_far_field_leaf_set_assembly_task_costs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_far_field_leaf_set_assembly_task_costs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>task_costs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compute the tasks costs for assembling matrix blocks in the far field leaf set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_costs</td><td>Vector of task costs for all matrix blocks in the far field leaf set. N.B. Its memory should be allocated before calling this function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l34917">34917</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

</div>
</div>
<a id="a49e55fd99889f299478358b58855bda4" name="a49e55fd99889f299478358b58855bda4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e55fd99889f299478358b58855bda4">&#9670;&nbsp;</a></span>compute_leaf_set_vmult_or_Tvmult_task_costs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_leaf_set_vmult_or_Tvmult_task_costs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>task_costs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compute the \(\mathcal{H}\)-matrix/vector multiplication or transposed \(\mathcal{H}\)-matrix/vector multiplication task costs for all matrix blocks in the leaf set.</p>
<p >The current \(\mathcal{H}\)-matrix node should be at the top level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_costs</td><td>Vector of task costs for all matrix blocks in the leaf set. N.B. Its memory should be allocated before calling this function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l34740">34740</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

</div>
</div>
<a id="ad564d02c7ee36f644e684ad20fec3cec" name="ad564d02c7ee36f644e684ad20fec3cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad564d02c7ee36f644e684ad20fec3cec">&#9670;&nbsp;</a></span>compute_lu_dag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_lu_dag </td>
          <td>(</td>
          <td class="paramtype">tbb::flow::graph &amp;&#160;</td>
          <td class="paramname"><em>dag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mutex &amp;&#160;</td>
          <td class="paramname"><em>log_stream_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compute the directed acyclic graph for H-LU factorization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >At present, LU factorization is only to be applied to square matrix and block square matrix.</p>
<p >Iterative over each block row.</p>
<p >Iterate over each matrix blocks on a same level and in a same column from the diagonal block, which corresponds to the <code>solve_upper</code> stage.</p>
<p >Since there is one \(\mathcal{H}\)-matrix node belongs to the leaf set, the following <code>solve_upper</code> task has actual computation and is not recursive.</p>
<p >Create the dependency from factorization of the current diagonal block to the <code>solve_upper</code> task with respect to the current column block.</p>
<p >Iterate over each matrix blocks on a same level and in a same row from the diagonal block, which corresponds to the <code>solve_lower</code> stage.</p>
<p >Since there is one \(\mathcal{H}\)-matrix node belongs to the leaf set, the following solve task has actual computation and is not recursive.</p>
<p >Create the dependency from factorization of the current diagonal block to the <code>solve_lower</code> task with respect to the current row block.</p>
<p >Iterate over each trailing matrix block on a same level from the diagonal block, which corresponds to the <code>update</code> stage. Both the row and column index sets of the matrix block should be larger than that of the diagonal block.</p>
<p >Sift out the matrix blocks having larger row and column index sets than the diagonal block.</p>
<p >Move the pointer <code>current_diag_row_block</code>, so that it is in a same column with the current trailing block.</p>
<p >When the two column index ranges match.</p>
<p >Move forward <code>current_diag_row_block</code>.</p>
<p >There is no corresponding same column block for the current trailing block. This is based on the assumption/fact that the index ranges of the same level same row \(\mathcal{H}\)-matrix blocks are increasing.</p>
<p >Move back <code>current_diag_row_block</code>.</p>
<p >There is no corresponding same column block for the current trailing block. This is based on the assumption/fact that the index ranges of the same level same row \(\mathcal{H}\)-matrix blocks are increasing.</p>
<p >Move the pointer <code>current_diag_column_block</code>, so that it is in a same row with the current trailing block.</p>
<p >When the two column index ranges match.</p>
<p >Move forward <code>current_diag_column_block</code>.</p>
<p >There is no corresponding same row block for the current trailing block. This is based on the assumption/fact that the index ranges of the same level same column \(\mathcal{H}\)-matrix blocks are increasing.</p>
<p >Move back <code>current_diag_column_block</code>.</p>
<p >There is no corresponding same row block for the current trailing block. This is based on the assumption/fact that the index ranges of the same level same column \(\mathcal{H}\)-matrix blocks are increasing.</p>
<p >Reset the pointer <code>current_diag_column_block</code> for the next trailing block if it has touched either end of the doubly linked list.</p>
<p >Reset the pointer <code>current_diag_row_block</code> for the next trailing block if it has touched either end of the doubly linked list.</p>
<p >Only when the corresponding same level, same row block and column block are found, update task will be added.</p>
<p >Add the update task to the current trailing \(\mathcal{H}\)-matrix node.</p>
<p >Iterate over the sub-block cluster tree associated with <code>current_diag_row_block</code> and build the edge from <code>solve_lower</code> node to the current <code>update</code> node.</p>
<p >Iterate over the sub-block cluster tree associated with <code>current_diag_column_block</code> and build the edge from <code>solve_upper</code> to the current <code>update</code> node.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l32796">32796</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l32796">HMatrix&lt; spacedim, Number &gt;::compute_lu_dag()</a>, <a class="el" href="hmatrix_8h_source.html#l04409">HMatrix&lt; spacedim, Number &gt;::factorize_lu_or_cholesky_graph_node</a>, <a class="el" href="hmatrix_8h_source.html#l19084">HMatrix&lt; spacedim, Number &gt;::is_leaf()</a>, <a class="el" href="hmatrix_8h_source.html#l33172">HMatrix&lt; spacedim, Number &gt;::lu_factorize_diagonal_block_task()</a>, <a class="el" href="hmatrix_8h_source.html#l33267">HMatrix&lt; spacedim, Number &gt;::lu_solve_lower_task()</a>, <a class="el" href="hmatrix_8h_source.html#l33224">HMatrix&lt; spacedim, Number &gt;::lu_solve_upper_task()</a>, <a class="el" href="hmatrix_8h_source.html#l04294">HMatrix&lt; spacedim, Number &gt;::next_same_level_hmat_node</a>, <a class="el" href="hmatrix_8h_source.html#l04306">HMatrix&lt; spacedim, Number &gt;::next_same_level_same_column_hmat_node</a>, <a class="el" href="hmatrix_8h_source.html#l04300">HMatrix&lt; spacedim, Number &gt;::next_same_level_same_row_hmat_node</a>, and <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l32796">HMatrix&lt; spacedim, Number &gt;::compute_lu_dag()</a>.</p>

</div>
</div>
<a id="aba14c63550f42d8a971beab340337b0e" name="aba14c63550f42d8a971beab340337b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba14c63550f42d8a971beab340337b0e">&#9670;&nbsp;</a></span>compute_lu_factorization() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_lu_factorization </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compute the LU factorization of an \(\mathcal{H}\)-matrix in situ. The resulted \(L\) and \(U\) factors are stored in the original \(\mathcal{H}\)-matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >After LU factorization, set the state of the current matrix to be <code>lu</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l32490">32490</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="af2bf0581bcf6d1319b661d0f0527ffc9" name="af2bf0581bcf6d1319b661d0f0527ffc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bf0581bcf6d1319b661d0f0527ffc9">&#9670;&nbsp;</a></span>compute_lu_factorization() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_lu_factorization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>LU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compute the LU factorization of an \(\mathcal{H}\)-matrix. The resulted \(L\) and \(U\) factors are stored in a same \(\mathcal{H}\)-matrix \(LU\). The matrix \(LU\) should have the same hierarchical structure as the original matrix.</p>
<dl class="section note">
<dt>Note</dt>
<dd>After LU factorization, the state of the result matrix is set to <code>lu</code> and that of the original matrix is <code>unusable</code>.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LU</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >After LU factorization, set the state of the result matrix to be <code>lu</code> and that of the original matrix as <code>unusable</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l32473">32473</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l19640">HMatrix&lt; spacedim, Number &gt;::set_state()</a>.</p>

</div>
</div>
<a id="adb8dcc2c66364c7d392792d98f770bf8" name="adb8dcc2c66364c7d392792d98f770bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8dcc2c66364c7d392792d98f770bf8">&#9670;&nbsp;</a></span>compute_lu_factorization_task_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_lu_factorization_task_parallel </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compute the LU factorization of an \(\mathcal{H}\)-matrix in situ using task based parallelism. The resulted \(L\) and \(U\) factors are stored in the original \(\mathcal{H}\)-matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Link same level \(\mathcal{H}\)-matrix nodes on the cross of each diagonal block.</p>
<p >Mutex used for monitoring the parallel execution of H-LU factorization.</p>
<p >Build the DAG.</p>
<p >Send a message to the starting task node, i.e. the first leaf node, and trigger the parallel execution of the factorization.</p>
<p >After LU factorization, set the state of the current matrix to be <code>lu</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l32715">32715</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04409">HMatrix&lt; spacedim, Number &gt;::factorize_lu_or_cholesky_graph_node</a>, and <a class="el" href="debug__tools_8h.html#abc4b513edfba014605e6259429800db3">print_wall_time()</a>.</p>

</div>
</div>
<a id="a485b984ec9eb3a3f1e1dc309f5c3725a" name="a485b984ec9eb3a3f1e1dc309f5c3725a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485b984ec9eb3a3f1e1dc309f5c3725a">&#9670;&nbsp;</a></span>compute_near_field_hmat_assembly_task_cost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_near_field_hmat_assembly_task_cost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compute the task cost for assembling the current near field \(\mathcal{H}\)-matrix node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top_hmat_property</td><td>\(\mathcal{H}\)-matrix property of the top level \(\mathcal{H}\)-matrix node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task cost </dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l34779">34779</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>.</p>

</div>
</div>
<a id="ace629d5a578f32a43d94d2e51f9a53f0" name="ace629d5a578f32a43d94d2e51f9a53f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace629d5a578f32a43d94d2e51f9a53f0">&#9670;&nbsp;</a></span>compute_near_field_hmat_vmult_or_Tvmult_task_cost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_near_field_hmat_vmult_or_Tvmult_task_cost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compute the \(\mathcal{H}\)-matrix/vector multiplication or transposed \(\mathcal{H}\)-matrix/vector multiplication task cost for the current near field \(\mathcal{H}\)-matrix node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top_hmat_property</td><td>\(\mathcal{H}\)-matrix property of the top level \(\mathcal{H}\)-matrix node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task cost </dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l34610">34610</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>.</p>

</div>
</div>
<a id="a7ad8511dd6d1ff5081b9a6c69d8aa009" name="a7ad8511dd6d1ff5081b9a6c69d8aa009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad8511dd6d1ff5081b9a6c69d8aa009">&#9670;&nbsp;</a></span>compute_near_field_leaf_set_assembly_task_costs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_near_field_leaf_set_assembly_task_costs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>task_costs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compute the tasks costs for assembling matrix blocks in the near field leaf set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_costs</td><td>Vector of task costs for all matrix blocks in the near field leaf set. N.B. Its memory should be allocated before calling this function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l34835">34835</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="aca__plus_8hcu_source.html#l08455">fill_hmatrix_with_aca_plus_smp()</a>.</p>

</div>
</div>
<a id="a6a1442eeae359cb7f9cbcf70c2c92ae4" name="a6a1442eeae359cb7f9cbcf70c2c92ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1442eeae359cb7f9cbcf70c2c92ae4">&#9670;&nbsp;</a></span>compute_tvmult_contributing_index_ranges_from_all_threads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_tvmult_contributing_index_ranges_from_all_threads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>thread_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compute the intersection of column index ranges for each pair of leaf set intervals. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35054">35054</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a60be54e6d0592fb8f4e727ad490fd867" name="a60be54e6d0592fb8f4e727ad490fd867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60be54e6d0592fb8f4e727ad490fd867">&#9670;&nbsp;</a></span>compute_vmult_contributing_index_ranges_from_all_threads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_vmult_contributing_index_ranges_from_all_threads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>thread_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compute the intersection of row index ranges for each pair of leaf set intervals. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35024">35024</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ababd28a7322d6c3accef139c56636c9f" name="ababd28a7322d6c3accef139c56636c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababd28a7322d6c3accef139c56636c9f">&#9670;&nbsp;</a></span>compute_vmult_or_tvmult_thread_num()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_vmult_or_tvmult_thread_num </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_vmult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_tvmult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compute the number of threads to be used in <a class="el" href="classHMatrix.html#adbbf34180ab8dc8c09a200b32c636ea9">HMatrix::vmult</a> or <a class="el" href="classHMatrix.html#ab4da3bc44083f7bc4798a019928056dd">HMatrix::Tvmult</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of threads </dd></dl>
<p >Use the smaller value of TBB thread number and leaf set size, in case the leaf set size is very small.</p>
<p >During <a class="el" href="classHMatrix.html#adbbf34180ab8dc8c09a200b32c636ea9">HMatrix::vmult</a>, it is possible that the total number of rows in the \(\mathcal{H}\)-matrix is smaller than the thread number. In this case, the thread number is set to the number of rows.</p>
<p >During <a class="el" href="classHMatrix.html#ab4da3bc44083f7bc4798a019928056dd">HMatrix::Tvmult</a>, it is possible that the total number of columns in the \(\mathcal{H}\)-matrix is smaller than the thread number. In this case, the thread number is set to the number of columns.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35085">35085</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a82f1f56d79630de7c254bba1a5bdc82d" name="a82f1f56d79630de7c254bba1a5bdc82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f1f56d79630de7c254bba1a5bdc82d">&#9670;&nbsp;</a></span>convert_between_different_block_cluster_trees()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k2</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Convert an \(\mathcal{H}\)-matrix between two different block cluster trees \(T\) and \(T&#39;\), where \(T := T(I \times J, P)\) and \(T&#39;
:= T&#39;(I \times J, P&#39;)\). The two trees have incompatible partitions and do not contain each other. However, they are constructed on the same cluster trees \(T(I)\) and \(T(J)\). This enables us to make a <b>shallow</b> comparison of two block cluster nodes based on the pointer addresses related to the comprising clusters, which is useful for verify the equality of two block cluster nodes.</p>
<p >The procedures of this algorithm are as below. Assume the current \(\mathcal{H}\)-matrix to be converted is associated with the block cluster tree \(T\).</p>
<ol type="1">
<li>Extend \(T\) to be finer than \(T&#39;\), from which we get the new block cluster tree \(T&#39;&#39;\).</li>
<li>Refine the original \(\mathcal{H}\)-matrix with respect to the extended tree \(T&#39;&#39;\).</li>
<li>Get and keep a record of the leaf set of the block cluster tree \(T&#39;\), which will be used for matrix coarsening in the last step.</li>
<li>Extend \(T&#39;\) to the finer block cluster tree \(T&#39;&#39;\), from which we get \(\widetilde{T}&#39;\).</li>
<li>Build a new \(\mathcal{H}\)-matrix with respect to \(\widetilde{T}&#39;\) with the actual data migrated from the leaf nodes of the original \(\mathcal{H}\)-matrix.</li>
<li>Coarsen the new \(\mathcal{H}\)-matrix to the original partition of \(T&#39;\).</li>
<li>Delete the hierarchy of the original \(\mathcal{H}\)-matrix.</li>
<li>Assign the new \(\mathcal{H}\)-matrix object to the original \(\mathcal{H}\)-matrix object.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bct1</td><td>The block cluster tree which is associated with the current \(\mathcal{H}\)-matrix. </td></tr>
    <tr><td class="paramname">bct2</td><td>The block cluster tree to which the current \(\mathcal{H}\)-matrix is to be converted. </td></tr>
  </table>
  </dd>
</dl>
<p >Make a copy of the leaf set of the target block cluster tree <code>bct2</code>, which will be used for the final coarsening.</p>
<p >Extend the block cluster tree <code>bct1</code> associated with the current \(\mathcal{H}\)-matrix to the coarsest tree which is finer than the target block cluster tree <code>bct2</code>. If the block cluster tree has really been extended (because it is possible that <code>bct1</code> is already finer than <code>bct2</code>), refine the \(\mathcal{H}\)-matrix to its extended block cluster tree.</p>
<p >Extend <code>bct2</code> to the finer partition obtained from <code>bct1</code> as above (i.e. having been extended). N.B. Now the leaf set of <code>bct1</code> after refinement is the same as that of <code>bct2</code> after this extension.</p>
<p >Create a new \(\mathcal{H}\)-matrix with respect to the extended <code>bct2</code>, which accepts the data migrated from the leaf set of the current \(\mathcal{H}\)-matrix. N.B. The current \(\mathcal{H}\)-matrix has been refined to the super tree above.</p>
<dl class="section note">
<dt>Note </dt>
<dd><ul>
<li>
The actual data of an \(\mathcal{H}\)-matrix are stored in the leaf set nodes. </li>
<li>
This hierarchical structure of the new \(\mathcal{H}\)-matrix is built with respect to the extended block cluster tree <code>bct2</code>. </li>
<li>
The shallow copy constructor cannot be used here because the new \(\mathcal{H}\)-matrix has a different block cluster tree structure from the current \(\mathcal{H}\)-matrix, even though they have the same partition after tree extension. </li>
</ul>
</dd>
</dl>
<p >Coarsen the new \(\mathcal{H}\)-matrix to the original leaf set of <code>bct2</code>. Then rebuild its leaf set.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The structure of the block cluster tree associated with the \(\mathcal{H}\)-matrix is still same as before, which has more levels than the \(\mathcal{H}\)-matrix. Therefore, we should prune the block cluster tree to make it consistent with the \(\mathcal{H}\)-matrix.</dd>
</dl>
<p >Move the new \(\mathcal{H}\)-matrix to the current \(\mathcal{H}\)-matrix by shallow assignment.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l36166">36166</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l35914">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="hmatrix_8h_source.html#l35624">HMatrix&lt; spacedim, Number &gt;::coarsen_to_partition()</a>, <a class="el" href="block__cluster__tree_8h_source.html#l01739">BlockClusterTree&lt; spacedim, Number &gt;::extend_finer_than_partition()</a>, <a class="el" href="block__cluster__tree_8h_source.html#l01896">BlockClusterTree&lt; spacedim, Number &gt;::extend_to_finer_partition()</a>, <a class="el" href="block__cluster__tree_8h_source.html#l03769">BlockClusterTree&lt; spacedim, Number &gt;::get_leaf_set()</a>, <a class="el" href="hmatrix_8h_source.html#l35664">HMatrix&lt; spacedim, Number &gt;::link_hmat_nodes_on_same_levels()</a>, and <a class="el" href="block__cluster__tree_8h_source.html#l02092">BlockClusterTree&lt; spacedim, Number &gt;::prune_to_partition()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l12474">h_h_mmult_phase2()</a>.</p>

</div>
</div>
<a id="a00bdd40f7fcf5c912c34c427df518300" name="a00bdd40f7fcf5c912c34c427df518300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00bdd40f7fcf5c912c34c427df518300">&#9670;&nbsp;</a></span>convertToFullMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::convertToFullMatrix </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Convert an <a class="el" href="classHMatrix.html">HMatrix</a> to a full matrix by calling the internal recursive function.</p>
<dl class="section note">
<dt>Note </dt>
<dd>This function only has the verification purpose. In reality, a large dense matrix cannot be saved as a full matrix. </dd>
</dl>
<p >If the current \(\mathcal{H}\)-matrix is symmetric, after conversion, the obtained full matrix may not be symmetric anymore, because when constructing an \(\mathcal{H}\)-matrix based on a real mesh, the indices stored in a cluster are usually not continuous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Set the property of the full matrix according to the top level \(\mathcal{H}\)-matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l18155">18155</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a6f24998c7de1d0e336577be41c6281e3" name="a6f24998c7de1d0e336577be41c6281e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f24998c7de1d0e336577be41c6281e3">&#9670;&nbsp;</a></span>determine_mm_split_mode_from_Sigma_P()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tree_8h.html#a922ca07db9633957939f697a65aff11d">TreeNodeSplitMode</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::determine_mm_split_mode_from_Sigma_P</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check the consistency of the tree node split modes which are associated with the \(\mathcal{H}\)-matrix node pairs stored in the list \(\Sigma_P\) of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l36304">36304</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l12403">h_h_mmult_phase1_recursion()</a>.</p>

</div>
</div>
<a id="a66979dbdf56155c63f0706649e8545b9" name="a66979dbdf56155c63f0706649e8545b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66979dbdf56155c63f0706649e8545b9">&#9670;&nbsp;</a></span>distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Only non-leaf \(\mathcal{H}\)-matrix nodes need to be processed.</p>
<p >Since the current \(\mathcal{H}\)-matrix node has children, its type should be <code>HierarchicalMatrixType</code> and we make an assertion on it.</p>
<p >Distribute matrices in \(\Sigma_b^R\) and \(\Sigma_b^F\) of the current \(\mathcal{H}\)-matrix node to the leaf nodes which are its descendants. This is a recursive function call.</p>
<p >Distribute matrices in \(\Sigma_b^R\) and \(\Sigma_b^F\) of each child matrix of the current \(\mathcal{H}\)-matrix node to the leaf nodes which are its descendants.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l18686">18686</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l12474">h_h_mmult_phase2()</a>.</p>

</div>
</div>
<a id="a39e24569fe32027c840b160f9dcd1ad7" name="a39e24569fe32027c840b160f9dcd1ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e24569fe32027c840b160f9dcd1ad7">&#9670;&nbsp;</a></span>distribute_sigma_r_and_f_to_leaves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::distribute_sigma_r_and_f_to_leaves </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l18726">18726</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aeb19e987450fc02acea91dffd237e0a0" name="aeb19e987450fc02acea91dffd237e0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb19e987450fc02acea91dffd237e0a0">&#9670;&nbsp;</a></span>find_block_cluster_in_leaf_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;::iterator <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::find_block_cluster_in_leaf_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find a block cluster in the leaf set of the current \(\mathcal{H}\)-matrix and returns the iterator of the corresponding \(\mathcal{H}\)-matrix node in the leaf set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_cluster</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >Perform a shallow comparison, i.e. compare by pointer address, of the block clusters.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The data held by those previously found leaf nodes of the source \(\mathcal{H}\)-matrix have already been migrated to the leaf nodes of the new \(\mathcal{H}\)-matrix, which will make the data fields in these leaf nodes being empty. Hence, we will bypass them. </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l36027">36027</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a4d9e10d11ac2c5a929854ac7b3b15ad1" name="a4d9e10d11ac2c5a929854ac7b3b15ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9e10d11ac2c5a929854ac7b3b15ad1">&#9670;&nbsp;</a></span>find_block_cluster_in_leaf_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;::const_iterator <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::find_block_cluster_in_leaf_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_cluster</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find a block cluster in the leaf set of the current \(\mathcal{H}\)-matrix and returns the iterator of the corresponding \(\mathcal{H}\)-matrix node in the leaf set (const version).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_cluster</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >Perform a shallow comparison, i.e. compare by pointer address, of the block clusters.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The data held by those previously found leaf nodes of the source \(\mathcal{H}\)-matrix have already been migrated to the leaf nodes of the new \(\mathcal{H}\)-matrix, which will make the data fields in these leaf nodes being empty. Hence, we will bypass them. </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l36060">36060</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a1ab763860706b9cbef8f5e73d995f29a" name="a1ab763860706b9cbef8f5e73d995f29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab763860706b9cbef8f5e73d995f29a">&#9670;&nbsp;</a></span>find_col_diag_block_for_offdiag_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::find_col_diag_block_for_offdiag_block</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find the diagonal block corresponding to the column block cluster of the current \(\mathcal{H}\)-matrix node which is assumed in the lower triangular part of the whole matrix.</p>
<p ><b>The algorithm does not check internally whether the current \(\mathcal{H}\)-matrix node locates in the lower triangular part of the whole matrix. The user should ensure this presumption.</b></p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >We make an assertion here that the current \(\mathcal{H}\)-matrix node should not be on the top level in the \(\mathcal{H}\)-matrix hierarchy.</p>
<p >According to the currently adopted tensor product way of constructing block clusters from clusters, the diagonal block can only be the first or last sibling of the current \(\mathcal{H}\)-matrix node. Therefore, when the current \(\mathcal{H}\)-matrix node's <code>submatrix_index</code> is 1 (2), we will directly check if the first (last) sibling is a diagonal block on a same column.</p>
<p >We should also note that if an off-diagonal block is split into sub-blocks and such case will occur when the fine non-tensor product partition is adopted, none of its submatrices are diagonal blocks, even though the <code>submatrix_index</code> of which is 0 or 3.</p>
<p >When the first or last sibling of the current \(\mathcal{H}\)-matrix node is not a diagonal block, we will look for the corresponding diagonal block on a same column by first recursing back to the top level of the \(\mathcal{H}\)-matrix hierarchy then recursing forward to the current level.</p>
<p >When the current \(\mathcal{H}\)-matrix node is on the top level of the \(\mathcal{H}\)-matrix hierarchy, throw an error, because the diaognal block should have been found already.</p>
<p >Check if the last (3rd) sibling of the current \(\mathcal{H}\)-matrix node is a diagonal block.</p>
<dl class="section note">
<dt>Note</dt>
<dd>By default, the submatrices are organized in the following order. <code> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">0   </th><th class="markdownTableHeadNone">1    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">3   </td></tr>
</table>
</code></dd>
</dl>
<p >Go one recursion level up for further searching.</p>
<p >Check if the first sibling of the current \(\mathcal{H}\)-matrix node is a diagonal block.</p>
<p >Go one recursion level up for further searching.</p>
<p >Go one recursion level up for further searching.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l20581">20581</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04289">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="hmatrix_8h_source.html#l04323">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l20951">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank_off_diag_preserve_positive_definite()</a>.</p>

</div>
</div>
<a id="a1da518d5ca7e685e3e787f58dcad4e61" name="a1da518d5ca7e685e3e787f58dcad4e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da518d5ca7e685e3e787f58dcad4e61">&#9670;&nbsp;</a></span>find_row_diag_block_for_offdiag_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::find_row_diag_block_for_offdiag_block</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find the diagonal block corresponding to the row block cluster of the current \(\mathcal{H}\)-matrix node which is assumed in the lower triangular part of the whole matrix.</p>
<p ><b>The algorithm does not check internally whether the current \(\mathcal{H}\)-matrix node locates in the lower triangular part of the whole matrix. The user should ensure this presumption.</b></p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >We make an assertion here that the current \(\mathcal{H}\)-matrix node should not be on the top level in the \(\mathcal{H}\)-matrix hierarchy.</p>
<p >According to the currently adopted tensor product way of constructing block clusters from clusters, the diagonal block can only be the first or the last sibling of the current \(\mathcal{H}\)-matrix node. Therefore, when the current \(\mathcal{H}\)-matrix node's <code>submatrix_index</code> is 1 (2), we will directly check if the first (last) sibling is a diagonal block on a same row.</p>
<p >We should also note that if an off-diagonal block is split into sub-blocks and such case will occur when the fine non-tensor product partition is adopted, none of its submatrices are diagonal blocks, even though the <code>submatrix_index</code> of which is 0 or 3.</p>
<p >When the first or last sibling of the current \(\mathcal{H}\)-matrix node is not a diagonal block, we will look for the corresponding diagonal block on a same row by first recursing back to the top level of the \(\mathcal{H}\)-matrix hierarchy then recursing forward to the current level.</p>
<p >When the current \(\mathcal{H}\)-matrix node is on the top level of the \(\mathcal{H}\)-matrix hierarchy, throw an error.</p>
<p >Check if the first sibling of the current \(\mathcal{H}\)-matrix node is a diagonal block.</p>
<dl class="section note">
<dt>Note</dt>
<dd>By default, the submatrices are organized in the following order. <code> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">0   </th><th class="markdownTableHeadNone">1    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">3   </td></tr>
</table>
</code></dd>
</dl>
<p >Go one recursion level up for further searching.</p>
<p >Check if the last (3rd) sibling of the current \(\mathcal{H}\)-matrix node is a diagonal block.</p>
<p >Go one recursion level up for further searching.</p>
<p >Go one recursion level up for further searching.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l20419">20419</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04289">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="hmatrix_8h_source.html#l04323">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l20951">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank_off_diag_preserve_positive_definite()</a>.</p>

</div>
</div>
<a id="aa22b6f66ad982ae50668d696aaba7c24" name="aa22b6f66ad982ae50668d696aaba7c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22b6f66ad982ae50668d696aaba7c24">&#9670;&nbsp;</a></span>get_block_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_block_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the block type of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19656">19656</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="aca__plus_8hcu_source.html#l07151">fill_far_field_hmatrix_leaf_node_with_aca_plus()</a>, <a class="el" href="aca__plus_8hcu_source.html#l05981">fill_hmatrix_leaf_node_with_aca_plus()</a>, <a class="el" href="hmatrix_8h_source.html#l12592">h_h_mmult_from_leaf_node()</a>, <a class="el" href="hmatrix_8h_source.html#l13910">h_h_mTmult_from_leaf_node()</a>, <a class="el" href="hmatrix_8h_source.html#l15219">h_h_Tmmult_from_leaf_node()</a>, and <a class="el" href="aca__plus_8hcu_source.html#l07744">stabilize_near_field_hmatrices_for_hypersingular_kernel()</a>.</p>

</div>
</div>
<a id="a4a975c2033a702d47dd4c7e91d66811e" name="a4a975c2033a702d47dd4c7e91d66811e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a975c2033a702d47dd4c7e91d66811e">&#9670;&nbsp;</a></span>get_col_index_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; types::global_dof_index, 2 &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_col_index_range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the pointer to the global column index range.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The index range follows the internal DoF numbering.</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l36011">36011</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="aca__plus_8hcu_source.html#l07151">fill_far_field_hmatrix_leaf_node_with_aca_plus()</a>, <a class="el" href="aca__plus_8hcu_source.html#l05981">fill_hmatrix_leaf_node_with_aca_plus()</a>, and <a class="el" href="aca__plus_8hcu_source.html#l07744">stabilize_near_field_hmatrices_for_hypersingular_kernel()</a>.</p>

</div>
</div>
<a id="a8e8a1f31650cc5bed4cb2a88aca0e354" name="a8e8a1f31650cc5bed4cb2a88aca0e354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8a1f31650cc5bed4cb2a88aca0e354">&#9670;&nbsp;</a></span>get_col_index_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; types::global_dof_index, 2 &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_col_index_range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the pointer to the global column index range (const version).</p>
<dl class="section note">
<dt>Note</dt>
<dd>The index range follows the internal DoF numbering.</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l36019">36019</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a704afe558efd60e34c9cb1643293b40d" name="a704afe558efd60e34c9cb1643293b40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704afe558efd60e34c9cb1643293b40d">&#9670;&nbsp;</a></span>get_column_index_range_for_leaf_set_interval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_column_index_range_for_leaf_set_interval </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; int64_t, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>thread_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the minimum column index range which contains the column index sets of all \(\mathcal{H}\)-matrix nodes in the leaf set interval.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval</td><td>Closed interval in the leaf set </td></tr>
  </table>
  </dd>
</dl>
<p >Use the minimum of lower bound indices and maximum of upper bound indices to form the covering index range.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l34980">34980</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="afa499c9af9db42304394a8972e0950eb" name="afa499c9af9db42304394a8972e0950eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa499c9af9db42304394a8972e0950eb">&#9670;&nbsp;</a></span>get_far_field_leaf_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_far_field_leaf_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35980">35980</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a48cb754d4623b62920a6ece5d388f1d6" name="a48cb754d4623b62920a6ece5d388f1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cb754d4623b62920a6ece5d388f1d6">&#9670;&nbsp;</a></span>get_far_field_leaf_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_far_field_leaf_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35988">35988</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a9d914c27d4e990d476a4529b2daa64cd" name="a9d914c27d4e990d476a4529b2daa64cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d914c27d4e990d476a4529b2daa64cd">&#9670;&nbsp;</a></span>get_fullmatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_fullmatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the pointer to the full matrix of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19815">19815</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="aca__plus_8hcu_source.html#l05981">fill_hmatrix_leaf_node_with_aca_plus()</a>, and <a class="el" href="aca__plus_8hcu_source.html#l07744">stabilize_near_field_hmatrices_for_hypersingular_kernel()</a>.</p>

</div>
</div>
<a id="aed550b5b41a64c6f1bbcde4f8f7eca91" name="aed550b5b41a64c6f1bbcde4f8f7eca91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed550b5b41a64c6f1bbcde4f8f7eca91">&#9670;&nbsp;</a></span>get_fullmatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_fullmatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the pointer to the full matrix of the current \(\mathcal{H}\)-matrix node (const version). </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19823">19823</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ac5c9102fc04997c1ae3627185379d9bb" name="ac5c9102fc04997c1ae3627185379d9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c9102fc04997c1ae3627185379d9bb">&#9670;&nbsp;</a></span>get_leaf_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_leaf_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the reference to the leaf set of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35948">35948</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="aca__plus_8hcu_source.html#l07910">fill_hmatrix_with_aca_plus_serial()</a>.</p>

</div>
</div>
<a id="a851d7bb3632bc1d18538d4d1dd5f6393" name="a851d7bb3632bc1d18538d4d1dd5f6393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851d7bb3632bc1d18538d4d1dd5f6393">&#9670;&nbsp;</a></span>get_leaf_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_leaf_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the reference to the leaf set of the current \(\mathcal{H}\)-matrix node (const version). </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35956">35956</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aabe735f7712a10ba5325ff116f8ca1c7" name="aabe735f7712a10ba5325ff116f8ca1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe735f7712a10ba5325ff116f8ca1c7">&#9670;&nbsp;</a></span>get_m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;<a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">::size_type</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_m</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the number of rows of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19093">19093</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="abff89130116d62ea4159bc69ca11f8d5" name="abff89130116d62ea4159bc69ca11f8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff89130116d62ea4159bc69ca11f8d5">&#9670;&nbsp;</a></span>get_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;<a class="el" href="aca__plus_8hcu.html#a31f3d4d24e52e94ab4a4ad115a04fd0e">::size_type</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_n</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the number of columns of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19764">19764</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ab20e7d0b58512976e355e4bd617696cb" name="ab20e7d0b58512976e355e4bd617696cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20e7d0b58512976e355e4bd617696cb">&#9670;&nbsp;</a></span>get_n_col_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_n_col_blocks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the number of column blocks of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19111">19111</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>.</p>

</div>
</div>
<a id="a347c22d4965e748b9778d853ab72ef68" name="a347c22d4965e748b9778d853ab72ef68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347c22d4965e748b9778d853ab72ef68">&#9670;&nbsp;</a></span>get_n_row_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_n_row_blocks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the number of row blocks of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19101">19101</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>.</p>

</div>
</div>
<a id="ae99d7f686a41528a537a9857140c260c" name="ae99d7f686a41528a537a9857140c260c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99d7f686a41528a537a9857140c260c">&#9670;&nbsp;</a></span>get_near_field_leaf_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_near_field_leaf_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35964">35964</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a38a2c595359811a343c9a119035d7dc8" name="a38a2c595359811a343c9a119035d7dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a2c595359811a343c9a119035d7dc8">&#9670;&nbsp;</a></span>get_near_field_leaf_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_near_field_leaf_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35972">35972</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a2f60ad32ac22100cb44a963f2ec82349" name="a2f60ad32ac22100cb44a963f2ec82349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f60ad32ac22100cb44a963f2ec82349">&#9670;&nbsp;</a></span>get_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_property</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the property of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19121">19121</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l11964">f_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l12038">f_h_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l12107">f_h_Tmmult()</a>, <a class="el" href="aca__plus_8hcu_source.html#l05981">fill_hmatrix_leaf_node_with_aca_plus()</a>, <a class="el" href="hmatrix_8h_source.html#l11460">h_f_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11532">h_f_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11603">h_f_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l12592">h_h_mmult_from_leaf_node()</a>, <a class="el" href="hmatrix_8h_source.html#l13910">h_h_mTmult_from_leaf_node()</a>, <a class="el" href="hmatrix_8h_source.html#l15219">h_h_Tmmult_from_leaf_node()</a>, <a class="el" href="hmatrix_8h_source.html#l10444">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10601">h_rk_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10751">h_rk_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10959">rk_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11119">rk_h_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11273">rk_h_Tmmult()</a>, and <a class="el" href="aca__plus_8hcu_source.html#l07744">stabilize_near_field_hmatrices_for_hypersingular_kernel()</a>.</p>

</div>
</div>
<a id="a0189de6e276fbd3425c4a7ef132f5e16" name="a0189de6e276fbd3425c4a7ef132f5e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0189de6e276fbd3425c4a7ef132f5e16">&#9670;&nbsp;</a></span>get_rkmatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_rkmatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the pointer to the rank-k matrix of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19772">19772</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="aca__plus_8hcu_source.html#l07151">fill_far_field_hmatrix_leaf_node_with_aca_plus()</a>, and <a class="el" href="aca__plus_8hcu_source.html#l05981">fill_hmatrix_leaf_node_with_aca_plus()</a>.</p>

</div>
</div>
<a id="a64c81db6357d0e00b82fd523af001ae5" name="a64c81db6357d0e00b82fd523af001ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c81db6357d0e00b82fd523af001ae5">&#9670;&nbsp;</a></span>get_rkmatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_rkmatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the pointer to the rank-k matrix of the current \(\mathcal{H}\)-matrix node (const version). </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19780">19780</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a21d44c2527bc4a6230bf9b08d6cb2caf" name="a21d44c2527bc4a6230bf9b08d6cb2caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d44c2527bc4a6230bf9b08d6cb2caf">&#9670;&nbsp;</a></span>get_row_index_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; types::global_dof_index, 2 &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_row_index_range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the pointer to the global row index range.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The index range follows the internal DoF numbering.</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35995">35995</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="aca__plus_8hcu_source.html#l07151">fill_far_field_hmatrix_leaf_node_with_aca_plus()</a>, <a class="el" href="aca__plus_8hcu_source.html#l05981">fill_hmatrix_leaf_node_with_aca_plus()</a>, and <a class="el" href="aca__plus_8hcu_source.html#l07744">stabilize_near_field_hmatrices_for_hypersingular_kernel()</a>.</p>

</div>
</div>
<a id="a8c0363e92bb29490faf47f013b1a2364" name="a8c0363e92bb29490faf47f013b1a2364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0363e92bb29490faf47f013b1a2364">&#9670;&nbsp;</a></span>get_row_index_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; types::global_dof_index, 2 &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_row_index_range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the pointer to the global row index range (const version).</p>
<dl class="section note">
<dt>Note</dt>
<dd>The index range follows the internal DoF numbering.</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l36003">36003</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="af1b8a7933d2ee304a6e26cdef0e93347" name="af1b8a7933d2ee304a6e26cdef0e93347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b8a7933d2ee304a6e26cdef0e93347">&#9670;&nbsp;</a></span>get_row_index_range_for_leaf_set_interval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_row_index_range_for_leaf_set_interval </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; int64_t, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>thread_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the minimum row index range which contains the row index sets of all \(\mathcal{H}\)-matrix nodes in the leaf set interval.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval</td><td>Closed interval in the leaf set </td></tr>
  </table>
  </dd>
</dl>
<p >Use the minimum of lower bound indices and maximum of upper bound indices to form the covering index range.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l34936">34936</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a8b694355eaed1b888e7223d90eb0b81d" name="a8b694355eaed1b888e7223d90eb0b81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b694355eaed1b888e7223d90eb0b81d">&#9670;&nbsp;</a></span>get_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hmatrix__support_8h.html#a8358c4882bca00f7e887d9b44e633aa0">HMatrixSupport::State</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the state of the current \(\mathcal{H}\)-matrix node.</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19632">19632</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a0572b2c0484ce618db0034e3bc7988ed" name="a0572b2c0484ce618db0034e3bc7988ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0572b2c0484ce618db0034e3bc7988ed">&#9670;&nbsp;</a></span>get_submatrices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_submatrices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the reference to the vector of submatrices of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19831">19831</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a8f8e9bc437ab86296d78950081ea34cd" name="a8f8e9bc437ab86296d78950081ea34cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8e9bc437ab86296d78950081ea34cd">&#9670;&nbsp;</a></span>get_submatrices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_submatrices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the reference to the vector of submatrices of the current \(\mathcal{H}\)-matrix node (const version). </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19839">19839</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a22f8da3a2d1666a610cb7a7912c6c09f" name="a22f8da3a2d1666a610cb7a7912c6c09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f8da3a2d1666a610cb7a7912c6c09f">&#9670;&nbsp;</a></span>get_top_left_leaf_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_top_left_leaf_node</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pointer to the top left leaf node in the \(\mathcal{H}\)-matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the \(\mathcal{H}\)-matrix leaf node </dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35878">35878</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>.</p>

</div>
</div>
<a id="ad6b6a6e858acc668f762d3ac85d79e6d" name="ad6b6a6e858acc668f762d3ac85d79e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b6a6e858acc668f762d3ac85d79e6d">&#9670;&nbsp;</a></span>get_top_left_leaf_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_top_left_leaf_node</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pointer to the top left leaf node in the \(\mathcal{H}\)-matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the \(\mathcal{H}\)-matrix leaf node </dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35896">35896</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>.</p>

</div>
</div>
<a id="aadea9fa59f420d22b3b1c939f6b573cc" name="aadea9fa59f420d22b3b1c939f6b573cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadea9fa59f420d22b3b1c939f6b573cc">&#9670;&nbsp;</a></span>get_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the matrix type of the current \(\mathcal{H}\)-matrix node.</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19052">19052</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="aca__plus_8hcu_source.html#l07151">fill_far_field_hmatrix_leaf_node_with_aca_plus()</a>, <a class="el" href="aca__plus_8hcu_source.html#l05981">fill_hmatrix_leaf_node_with_aca_plus()</a>, and <a class="el" href="aca__plus_8hcu_source.html#l07744">stabilize_near_field_hmatrices_for_hypersingular_kernel()</a>.</p>

</div>
</div>
<a id="a658a9b4b4ed09d69e0dd5e83a6b3a076" name="a658a9b4b4ed09d69e0dd5e83a6b3a076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658a9b4b4ed09d69e0dd5e83a6b3a076">&#9670;&nbsp;</a></span>h_h_mmult_cross_split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::h_h_mmult_cross_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc_tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function implements <code>MM_C</code> in Hackbusch's \(\mathcal{H}\)-matrix book. </p>
<p >Split the block cluster \(b\) in \(T_{\rm ind}\).</p>
<p >Append the initialized child to the list of submatrices of <code>M</code>.</p>
<p >Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p >Append the initialized child to the list of submatrices of <code>M</code>.</p>
<p >Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p >Iterate over each multiplication subtask.</p>
<p >Create \(\mathcal{H}\)-matrices corresponding to the child block clusters after splitting.</p>
<p >\(\Sigma_{b_s(1)}^P := \Sigma_{b_s(1)}^P \cup
\{[\tilde{M}_1(1), \tilde{M}_2(1)], [\tilde{M}_1(2),
\tilde{M}_2(3)]\}\)</p>
<p >\(\Sigma_{b_s(2)}^P := \Sigma_{b_s(2)}^P \cup
\{[\tilde{M}_1(1), \tilde{M}_2(2)], [\tilde{M}_1(2),
\tilde{M}_2(4)]\}\)</p>
<p >\(\Sigma_{b_s(3)}^P := \Sigma_{b_s(3)}^P \cup
\{[\tilde{M}_1(3), \tilde{M}_2(1)], [\tilde{M}_1(4),
\tilde{M}_2(3)]\}\)</p>
<p >\(\Sigma_{b_s(4)}^P := \Sigma_{b_s(4)}^P \cup
\{[\tilde{M}_1(3), \tilde{M}_2(2)], [\tilde{M}_1(4),
\tilde{M}_2(4)]\}\)</p>
<p >Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p >Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p >Update the matrix type of the current \(\mathcal{H}\)-matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29027">29027</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="block__cluster__tree_8h_source.html#l00972">split_block_cluster_node()</a>.</p>

</div>
</div>
<a id="a37ab8944771c025a9ad4ff006c91f912" name="a37ab8944771c025a9ad4ff006c91f912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ab8944771c025a9ad4ff006c91f912">&#9670;&nbsp;</a></span>h_h_mmult_horizontal_split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::h_h_mmult_horizontal_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc_tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function implements <code>MM_H</code> in Hackbusch's \(\mathcal{H}\)-matrix book. </p>
<p >Split the block cluster \(b\) in \(T_{\rm ind}\).</p>
<p >Append the initialized child to the list of submatrices of <code>M</code>.</p>
<p >Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p >Iterate over each multiplication subtask.</p>
<p >Create \(\mathcal{H}\)-matrices corresponding to the child block clusters after splitting.</p>
<p >Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p >Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p >Update the matrix type of the current \(\mathcal{H}\)-matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l28811">28811</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="block__cluster__tree_8h_source.html#l00972">split_block_cluster_node()</a>.</p>

</div>
</div>
<a id="a168b6eea2e5b27528497850bf5ee2bbe" name="a168b6eea2e5b27528497850bf5ee2bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168b6eea2e5b27528497850bf5ee2bbe">&#9670;&nbsp;</a></span>h_h_mmult_reduction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::h_h_mmult_reduction</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Perform \(\mathcal{H}\)-matrix MM multiplication reduction. This is (7.21) in Hackbusch's \(\mathcal{H}\)-matrix book. </p>
<p >When one of the operands is either full matrix or rank-k matrix, perform direct multiplication.</p>
<p >Migrate the current \(\mathcal{H}\)-matrix node pair to the list <code>Sigma_P_cannot_reduced</code>.</p>
<p >Remove the current \(\mathcal{H}\)-matrix node pair from the original list in <code>M</code>.</p>
<p >Merge the elements in <code>Sigma_P_cannot_reduced</code> back to <code>Sigma_P</code> in <code>M</code> for further processing.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l28729">28729</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l12342">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l11894">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10890">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11411">rk_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l12403">h_h_mmult_phase1_recursion()</a>.</p>

</div>
</div>
<a id="a58b5ad565226b3547660248646358879" name="a58b5ad565226b3547660248646358879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b5ad565226b3547660248646358879">&#9670;&nbsp;</a></span>h_h_mmult_vertical_split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::h_h_mmult_vertical_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc_tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function implements <code>MM_V</code> in Hackbusch's \(\mathcal{H}\)-matrix book. </p>
<p >Split the block cluster \(b\) in \(T_{\rm ind}\).</p>
<p >Append the initialized child to the list of submatrices of <code>M</code>.</p>
<p >Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p >Iterate over each multiplication subtask.</p>
<p >Create \(\mathcal{H}\)-matrices corresponding to the child block clusters after splitting.</p>
<p >Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p >Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p >Update the matrix type of the current \(\mathcal{H}\)-matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l28919">28919</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="block__cluster__tree_8h_source.html#l00972">split_block_cluster_node()</a>.</p>

</div>
</div>
<a id="ab12dd46760596b0b15fdfa5d4ad0b014" name="ab12dd46760596b0b15fdfa5d4ad0b014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12dd46760596b0b15fdfa5d4ad0b014">&#9670;&nbsp;</a></span>Hvmult() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Hvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication \(y= \alpha \cdot
M^{\mathrm{H}} \cdot x\), where different strategies can be selected. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l28698">28698</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a6c94c022628ddfca8aa122ef34432e27" name="a6c94c022628ddfca8aa122ef34432e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c94c022628ddfca8aa122ef34432e27">&#9670;&nbsp;</a></span>Hvmult() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Hvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate \(\mathcal{H}\)-matrix/vector multiplication as \(y = y + \alpha \cdot M^H
\cdot x\) by starting from a block in the matrix and vector. Therefore, the starting \(\mathcal{H}\)-matrix is specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Result vector as a section of the corresponding global vector </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar factor before \(x\) </td></tr>
    <tr><td class="paramname">x</td><td>Input vector as a section of the corresponding global vector </td></tr>
    <tr><td class="paramname">starting_hmat</td><td>Top level \(\mathcal{H}\)-matrix </td></tr>
    <tr><td class="paramname">top_hmat_property</td><td>The \(\mathcal{H}\)-matrix property (of type <code>HMatrixSupport::Property</code>) of the top level \(\mathcal{H}\)-matrix node, which can be <code>general</code>, <code>symmetric</code>, <code>hermite_symmetric</code> and <code>lower_triangular</code> . </td></tr>
  </table>
  </dd>
</dl>
<p >When the current \(\mathcal{H}\)-matrix node is hierarchical, recursively call <code>Hvmult</code> of its children.</p>
<p >Here we comes to the transposed-matrix-vector multiplication with respect to a near field leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is general, perform the transposed-matrix-vector multiplication as usual.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be symmetric, when the top level \(\mathcal{H}\)-matrix node is symmetric.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be symmetric.</p>
<p >Perform the transposed-matrix-vector multiplication using the LAPACK function <code>symv</code> internally. In my implementation, only those lower triangular elements in a symmetric full matrix are used by the function.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(M^Tx\) and then perform the multiplication \(Mx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y_for_vmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, since the upper part is not saved and its contribution has already been considered when we handle the lower triangular block, we do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is Hermite symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be Hermite symmetric, when the top level \(\mathcal{H}\)-matrix node is Hermite symmetric.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be Hermite symmetric.</p>
<p >Perform the transposed-matrix-vector multiplication using the LAPACK function <code>symv</code> internally. In my implementation, only those lower triangular elements in a symmetric full matrix are used by the function.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(M^Tx\) and then perform the multiplication \(Mx\). This treatment considers both the contribution of the current matrix block as well as its Hermite symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y_for_vmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, since the upper part is not saved and its contribution has already been considered when we handle the lower triangular block, we do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is lower triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be lower triangular, when the top level \(\mathcal{H}\)-matrix node is lower triangular.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be lower triangular.</p>
<p >Perform the transposed-matrix-vector multiplication.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we perform the multiplication \(M^Tx\) as that for a general matrix.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, since the upper part is not saved and has no contribution to the result, we do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is upper triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be upper triangular, when the top level \(\mathcal{H}\)-matrix node is upper triangular.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be upper triangular.</p>
<p >Perform the transposed-matrix-vector multiplication.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, we perform the multiplication \(M^Tx\) as that for a general matrix.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we do nothing.</p>
<p >Here we comes to the transposed matrix-vector multiplication with respect to a far field leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is general, perform the transposed matrix-vector multiplication as usual.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(M^Tx\) and then perform the multiplication \(Mx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y_for_vmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is Hermite symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(M^Tx\) and then perform the multiplication \(Mx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y_for_vmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is lower triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we perform the multiplication \(M^Tx\).</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is upper triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, we perform the multiplication \(M^Tx\).</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, do nothing.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l27182">27182</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ad8a4720ce98a0e06cc0a6a5b6699dd7c" name="ad8a4720ce98a0e06cc0a6a5b6699dd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a4720ce98a0e06cc0a6a5b6699dd7c">&#9670;&nbsp;</a></span>Hvmult() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Hvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate \(\mathcal{H}\)-matrix/vector multiplication as \(y = y + \alpha \cdot M^H
\cdot x\) using the serial recursive mode.</p>
<p >The said <b>serial</b> means the TBB task parallelization is not adopted, but the multithreaded OpenBLAS is still used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Result vector </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar factor before \(x\) </td></tr>
    <tr><td class="paramname">x</td><td>Input vector </td></tr>
    <tr><td class="paramname">top_hmat_property</td><td>The \(\mathcal{H}\)-matrix property (of type <code>HMatrixSupport::Property</code>) of the top level \(\mathcal{H}\)-matrix, which can be <code>general</code>, <code>symmetric</code>, <code>hermite_symmetric</code> and <code>lower_triangular</code> . </td></tr>
  </table>
  </dd>
</dl>
<p >When the current \(\mathcal{H}\)-matrix node is hierarchical, recursively call <code>Hvmult</code> of its children.</p>
<p >Here we comes to the transposed-matrix-vector multiplication with respect to a near field leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is general, perform the transposed-matrix-vector multiplication as usual.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be symmetric, when the top level \(\mathcal{H}\)-matrix node is symmetric.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be symmetric.</p>
<p >Perform the transposed-matrix-vector multiplication using the LAPACK function <code>symv</code> internally. In my implementation, only those lower triangular elements in a symmetric full matrix are used by the function.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(M^Tx\) and then perform the multiplication \(Mx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y_for_vmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, since the upper part is not saved and its contribution has already been considered when we handle the lower triangular block, we do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is Hermite symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be Hermite symmetric, when the top level \(\mathcal{H}\)-matrix node is Hermite symmetric.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be Hermite symmetric.</p>
<p >Perform the transposed-matrix-vector multiplication using the LAPACK function <code>hemv</code> internally. In my implementation, only those lower triangular elements in a Hermite symmetric full matrix are used by the function.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(M^Tx\) and then perform the multiplication \(\overline{M}x\). This treatment considers both the contribution of the current matrix block as well as its Hermite symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y_for_vmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, since the upper part is not saved and its contribution has already been considered when we handle the lower triangular block, we do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is lower triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be lower triangular, when the top level \(\mathcal{H}\)-matrix node is lower triangular.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be lower triangular.</p>
<p >Perform the transposed-matrix-vector multiplication.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we perform the multiplication \(M^Tx\) as that for a general matrix.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, since the upper part is not saved and has no contribution to the result, we do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is upper triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be upper triangular, when the top level \(\mathcal{H}\)-matrix node is upper triangular.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be upper triangular.</p>
<p >Perform the transposed-matrix-vector multiplication.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, we perform the multiplication \(M^Tx\) as that for a general matrix.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we do nothing.</p>
<p >Here we comes to the transposed matrix-vector multiplication with respect to a far field leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is general, perform the transposed matrix-vector multiplication as usual.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(M^Tx\) and then perform the multiplication \(Mx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y_for_vmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is Hermite symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(M^Tx\) and then perform the multiplication \(Mx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y_for_vmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is lower triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we perform the multiplication \(M^Tx\).</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is upper triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, we perform the multiplication \(M^Tx\).</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, do nothing.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l26156">26156</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a7a43050c345bd3509a8f5c43aaa81d1b" name="a7a43050c345bd3509a8f5c43aaa81d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a43050c345bd3509a8f5c43aaa81d1b">&#9670;&nbsp;</a></span>Hvmult() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Hvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication \(y= M^{\mathrm{H}}
\cdot x\), where different strategies can be selected. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l28669">28669</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a1b2bc6ca001ca921f280614faeddd435" name="a1b2bc6ca001ca921f280614faeddd435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2bc6ca001ca921f280614faeddd435">&#9670;&nbsp;</a></span>Hvmult() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Hvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate \(\mathcal{H}\)-matrix/vector multiplication as \(y = y + M^H \cdot x\) by starting from a block in the matrix and vector. Therefore, the starting \(\mathcal{H}\)-matrix is specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Result vector as a section of the corresponding global vector </td></tr>
    <tr><td class="paramname">x</td><td>Input vector as a section of the corresponding global vector </td></tr>
    <tr><td class="paramname">starting_hmat</td><td>Top level \(\mathcal{H}\)-matrix </td></tr>
    <tr><td class="paramname">top_hmat_property</td><td>The \(\mathcal{H}\)-matrix property (of type <code>HMatrixSupport::Property</code>) of the top level \(\mathcal{H}\)-matrix node, which can be <code>general</code>, <code>symmetric</code>, <code>hermite_symmetric</code> and <code>lower_triangular</code> . </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l27169">27169</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a8b5e188e85cfb6e496b248623a2ac4c1" name="a8b5e188e85cfb6e496b248623a2ac4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5e188e85cfb6e496b248623a2ac4c1">&#9670;&nbsp;</a></span>Hvmult() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Hvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate \(\mathcal{H}\)-matrix/vector multiplication as \(y = y + M^H \cdot x\) using the serial recursive mode.</p>
<p >The said <b>serial</b> means the TBB task parallelization is not adopted, but the multithreaded OpenBLAS is still used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Result vector </td></tr>
    <tr><td class="paramname">x</td><td>Input vector </td></tr>
    <tr><td class="paramname">top_hmat_property</td><td>The \(\mathcal{H}\)-matrix property (of type <code>HMatrixSupport::Property</code>) of the top level \(\mathcal{H}\)-matrix, which can be <code>general</code>, <code>symmetric</code>, <code>hermite_symmetric</code> and <code>lower_triangular</code> . </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l26144">26144</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aae30964f21e645da51c2026d064b54ca" name="aae30964f21e645da51c2026d064b54ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae30964f21e645da51c2026d064b54ca">&#9670;&nbsp;</a></span>Hvmult_add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Hvmult_add </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication \(y= y + \alpha \cdot
M^{\mathrm{H}} \cdot x\) with adding, where different strategies can be selected. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l28714">28714</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aa8f71200095b99f4eec2f34ccfe9c3cb" name="aa8f71200095b99f4eec2f34ccfe9c3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f71200095b99f4eec2f34ccfe9c3cb">&#9670;&nbsp;</a></span>Hvmult_add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Hvmult_add </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication \(y= y +
M^{\mathrm{H}} \cdot x\) with adding, where different strategies can be selected. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l28683">28683</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a15331134773fc584b60a9c34c93eec87" name="a15331134773fc584b60a9c34c93eec87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15331134773fc584b60a9c34c93eec87">&#9670;&nbsp;</a></span>Hvmult_serial_iterative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 , typename Number3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Hvmult_serial_iterative </td>
          <td>(</td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number3&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication as \(y =
\beta y + \alpha \cdot M^H \cdot x\) by iterating over the leaf set. </p>
<p >The TBB task parallelization is not adopted, but the multithreaded OpenBLAS is still used.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Number2</td><td></td></tr>
    <tr><td class="paramname">Number3</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beta</td><td>Scalar factor before \(y\) </td></tr>
    <tr><td class="paramname">y</td><td>Result vector </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar factor before \(x\) </td></tr>
    <tr><td class="paramname">x</td><td>Input vector </td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be at the top level.</p>
<p >Scale \(y\).</p>
<p >Iterate over each \(\mathcal{H}\)-matrix node in the leaf set.</p>
<p >Restrict the global vector <code>x</code> to the local vector with respect to the transposed matrix block..</p>
<p >Merge back the result vector <code>local_y_for_Hvmult</code> to the global vector <code>y</code>.</p>
<p >Result vector and input vector with respect to the current matrix node.</p>
<p >Restrict the global vector <code>x</code> to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to the global vector <code>y</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l28248">28248</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ae892da432aa66cce8c7a5957bfad1524" name="ae892da432aa66cce8c7a5957bfad1524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae892da432aa66cce8c7a5957bfad1524">&#9670;&nbsp;</a></span>Hvmult_task_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 , typename Number3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Hvmult_task_parallel </td>
          <td>(</td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number3&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication as \(y = \beta y +
\alpha \cdot M^H \cdot x\) using TBB task parallelization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beta</td><td>Scalar factor before \(y\) </td></tr>
    <tr><td class="paramname">y</td><td>Result vector </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar factor before \(x\) </td></tr>
    <tr><td class="paramname">x</td><td>Input vector </td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be at the top level.</p>
<p >Only perform parallel multiplication when the thread number is larger than 1. Otherwise, switch to the iterative serial version.</p>
<p >Perform thread local scaling of the result vector and multiplications. The multiplication results are stored locally in each thread.</p>
<p >Local scaling: \(y_q = \beta y_q\).</p>
<p >Clear the local result vector before the multiplication begins.</p>
<p >Iterate over each \(\mathcal{H}\)-matrix node in the interval of the leaf set.</p>
<p >Restrict the global vector <code>x</code> to the local vector.</p>
<p >Merge back the result vector <code>local_y_for_Hvmult</code> obtained from the current leaf set matrix block to the thread local result vector.</p>
<p >Result vector and input vector with respect to the current matrix node.</p>
<p >Restrict the global vector <code>x</code> to the local vector.</p>
<p >Merge back the result vector <code>local_y</code> obtained from the current leaf set matrix node to the thread local result vector.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l28391">28391</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="af972cb62d436b8dca5d95a5b6e2ed964" name="af972cb62d436b8dca5d95a5b6e2ed964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af972cb62d436b8dca5d95a5b6e2ed964">&#9670;&nbsp;</a></span>invert_by_gauss_elim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::invert_by_gauss_elim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the inverse of the \(\mathcal{H}\)-matrix node via Gauss elimination by calling the recursive function <a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt;::_invert_by_gauss_elim.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M_inv</td><td></td></tr>
    <tr><td class="paramname">M_root</td><td>The \(\mathcal{H}\)-matrix node from which this recursive function is called for the first time. </td></tr>
    <tr><td class="paramname">M_root_bct</td><td>The block cluster tree associated with <code>M_root</code>. </td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Rebuild the leaf set of the current \(\mathcal{H}\)-matrix and its inverse.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30225">30225</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l35914">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, and <a class="el" href="hmatrix_8h_source.html#l35664">HMatrix&lt; spacedim, Number &gt;::link_hmat_nodes_on_same_levels()</a>.</p>

</div>
</div>
<a id="a74438781b4a0e1b3b1a3102200f468f1" name="a74438781b4a0e1b3b1a3102200f468f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74438781b4a0e1b3b1a3102200f468f1">&#9670;&nbsp;</a></span>is_current_hmat_node_nonemtpy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::is_current_hmat_node_nonemtpy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em> = <code>HMatrixSupport::Property::general</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check if the current \(\mathcal{H}\)-matrix node is non-emtpy.</p>
<p >A \(\mathcal{H}\)-matrix node is empty, i.e. it contains no actual data but only matrix block properties, under the following cases:</p><ol type="1">
<li>When the top level \(\mathcal{H}\)-matrix node has the <code>symmetric</code> property, only the diagonal and lower triangular blocks are stored. Hence, the upper triangular blocks are empty.</li>
<li>When the top level \(\mathcal{H}\)-matrix node has the <code>upper_triangular</code> property, the lower triangular blocks are empty.</li>
<li>When the top level \(\mathcal{H}\)-matrix node has the <code>lower_triangular</code> property, the upper triangular blocks are empty.</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>Whether the current \(\mathcal{H}\)-matrix node is non-empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l18409">18409</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ac1dcfe1628d551c13f2f54f850f748df" name="ac1dcfe1628d551c13f2f54f850f748df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1dcfe1628d551c13f2f54f850f748df">&#9670;&nbsp;</a></span>is_far_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::is_far_field</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >If the \(\mathcal{H}\)-matrix node belongs to the far field leaf set.</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19076">19076</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

</div>
</div>
<a id="a5463a24b07333c9820c1e0aa37ab65eb" name="a5463a24b07333c9820c1e0aa37ab65eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5463a24b07333c9820c1e0aa37ab65eb">&#9670;&nbsp;</a></span>is_leaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::is_leaf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >If the \(\mathcal{H}\)-matrix node blongs to the leaf set.</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19084">19084</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l33933">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_dag()</a>, and <a class="el" href="hmatrix_8h_source.html#l32796">HMatrix&lt; spacedim, Number &gt;::compute_lu_dag()</a>.</p>

</div>
</div>
<a id="af2b1f5aa80236d23aa948e05d6c8676d" name="af2b1f5aa80236d23aa948e05d6c8676d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b1f5aa80236d23aa948e05d6c8676d">&#9670;&nbsp;</a></span>is_near_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::is_near_field</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >If the \(\mathcal{H}\)-matrix node belongs to the near field leaf set.</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19068">19068</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>.</p>

</div>
</div>
<a id="a8bcc86e342c590738ee7ad92e1a102ce" name="a8bcc86e342c590738ee7ad92e1a102ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcc86e342c590738ee7ad92e1a102ce">&#9670;&nbsp;</a></span>is_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::is_root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >If the \(\mathcal{H}\)-matrix node is a root node.</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19060">19060</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix__vmult__strategy_8h_source.html#l01134">set_hmatrix_vmult_strategy_for_iterative_solver()</a>.</p>

</div>
</div>
<a id="a2ebe19839b8649eb14e8156b37e069fb" name="a2ebe19839b8649eb14e8156b37e069fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebe19839b8649eb14e8156b37e069fb">&#9670;&nbsp;</a></span>link_hmat_nodes_on_cross_from_diagonal_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::link_hmat_nodes_on_cross_from_diagonal_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Starting from a diagonal block, link \(\mathcal{H}\)-matrix nodes on a same level and same row as well as \(\mathcal{H}\)-matrix nodes on a same level and same column. This member function should only be called when the \(\mathcal{H}\)-matrix object is a diagonal block.</p>
<p >This is function is only needed by H-LU factorization at the moment. </p>
<p >Iterate over each \(\mathcal{H}\)-matrix node on the same level by starting from the current diagonal block.</p>
<p >Link same level \(\mathcal{H}\)-matrix blocks on a same row with respect to the diagonal block, when the top level \(\mathcal{H}\)-matrix is a general or upper triangular matrix.</p>
<p >Check if the current \(\mathcal{H}\)-matrix node is on the same row as the starting diagonal block.</p>
<p >When a same level block on a same row is found, its column index range must be larger than that of the diagonal block (but may not be contiguous).</p>
<p >Move the same row hmat node pointer forward.</p>
<p >Link same level \(\mathcal{H}\)-matrix blocks on a same column with respect to the diagonal block, when the top level \(\mathcal{H}\)-matrix is a general, symmetric, Hermite symmetric or lower triangular matrix.</p>
<p >Check if the current \(\mathcal{H}\)-matrix node is on the same column as the starting diagonal block.</p>
<p >When a same level block on a same column is found, its row index range must be larger than that of the diagonal block (but may not be contiguous).</p>
<p >Move the same column hmat node pointer forward.</p>
<p >Move the same level hmat node pointer forward.</p>
<p >Recursion into diagonal submatrices.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35747">35747</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04294">HMatrix&lt; spacedim, Number &gt;::next_same_level_hmat_node</a>, <a class="el" href="hmatrix_8h_source.html#l04306">HMatrix&lt; spacedim, Number &gt;::next_same_level_same_column_hmat_node</a>, <a class="el" href="hmatrix_8h_source.html#l04300">HMatrix&lt; spacedim, Number &gt;::next_same_level_same_row_hmat_node</a>, <a class="el" href="hmatrix_8h_source.html#l04318">HMatrix&lt; spacedim, Number &gt;::previous_same_level_same_column_hmat_node</a>, <a class="el" href="hmatrix_8h_source.html#l04312">HMatrix&lt; spacedim, Number &gt;::previous_same_level_same_row_hmat_node</a>, and <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>.</p>

</div>
</div>
<a id="ad9333fe8b56012040aa375723b533273" name="ad9333fe8b56012040aa375723b533273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9333fe8b56012040aa375723b533273">&#9670;&nbsp;</a></span>link_hmat_nodes_on_same_levels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::link_hmat_nodes_on_same_levels</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Link \(\mathcal{H}\)-matrix nodes on a same level according to the top level \(\mathcal{H}\)-matrix property. </p>
<p >When there is a subsequent \(\mathcal{H}\)-matrix node in the queue and if it is on a same level as the current \(\mathcal{H}\)-matrix node, link them.</p>
<p >Push submatrix nodes of the current \(\mathcal{H}\)-matrix node into the queue.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35664">35664</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04294">HMatrix&lt; spacedim, Number &gt;::next_same_level_hmat_node</a>, and <a class="el" href="hmatrix_8h_source.html#l04284">HMatrix&lt; spacedim, Number &gt;::submatrices</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l36166">HMatrix&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees()</a>, and <a class="el" href="hmatrix_8h_source.html#l30225">HMatrix&lt; spacedim, Number &gt;::invert_by_gauss_elim()</a>.</p>

</div>
</div>
<a id="a296b3d77a2a9ccb78e76085d2ffda8e5" name="a296b3d77a2a9ccb78e76085d2ffda8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296b3d77a2a9ccb78e76085d2ffda8e5">&#9670;&nbsp;</a></span>lu_assign_update_to_solve_and_factorize_dependencies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::lu_assign_update_to_solve_and_factorize_dependencies</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Build task dependencies between <code>update</code> tasks, <code>solve_upper</code> tasks <code>solve_lower</code> tasks and <code>factorize</code> tasks.</p>
<p >The following operations will be prformed:</p>
<ol type="1">
<li>Build <code>update</code> task to <code>solve_upper</code> or <code>solve_lower</code> task dependencies.</li>
<li>Transfer the <code>update</code> tasks of the current \(\mathcal{H}\)-matrix node to its descendants.</li>
<li>Build <code>update</code> task to <code>factorize</code> task dependencies.</li>
<li>Build task dependencies between <code>factorize</code> tasks on successive \(\mathcal{H}\)-matrix levels. </li>
</ol>
<p >Collect <code>update</code> task nodes from child \(\mathcal{H}\)-matrix nodes and build the task edges from <code>update</code> to <code>solve_upper</code> or <code>solve_lower</code>.</p>
<p >In this case, the \(\mathcal{H}\)-matrix node is either upper or lower triangular, which cannot be a diagonal block, nor of its descendants. Therefore, there will be no task edges from <code>update</code> to <code>factorize</code> anymore.</p>
<p >For the top level \(\mathcal{H}\)-matrix node, it is a diagonal block but has no factorization task with it. Therefore, here we check if the factorization task node exists.</p>
<p >Build the dependency between factorization task nodes on successive levels, i.e. after all diagonal blocks on a deeper level are factorized, their parent diagonal block can then be factorized.</p>
<p >After processing the diagonal block, the algorithm continues to shift down update task nodes to child \(\mathcal{H}\)-matrix nodes.</p>
<p >Shift down the <code>update</code> task nodes.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l33552">33552</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a7a7ccd8a95c9af8331f2491bd84121a3" name="a7a7ccd8a95c9af8331f2491bd84121a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7ccd8a95c9af8331f2491bd84121a3">&#9670;&nbsp;</a></span>lu_build_solve_lower_to_update_dependencies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::lu_build_solve_lower_to_update_dependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>update_block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create the task node dependencies from a <code>solve_lower</code> task to an <code>update</code> task. </p>
<p >If the current \(\mathcal{H}\)-matrix node has been associated with a <code>solve_lower</code> node, link it with the newest <code>update</code> node in the <code>update_block</code>.</p>
<p >Recursion into child matrices.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l33399">33399</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, and <a class="el" href="hmatrix_8h_source.html#l04419">HMatrix&lt; spacedim, Number &gt;::update_lu_or_cholesky_graph_nodes</a>.</p>

</div>
</div>
<a id="ae964afb855e244317f9b68df774c0113" name="ae964afb855e244317f9b68df774c0113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae964afb855e244317f9b68df774c0113">&#9670;&nbsp;</a></span>lu_build_update_to_factorize_dependencies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::lu_build_update_to_factorize_dependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>factorize_block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create the task node dependencies from <code>update</code> task to <code>factorize</code> task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factorize_node</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Recursion into child matrices.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l33439">33439</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04409">HMatrix&lt; spacedim, Number &gt;::factorize_lu_or_cholesky_graph_node</a>, and <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>.</p>

</div>
</div>
<a id="a1f8d00d75e5238f237d15bc8ba5345dd" name="a1f8d00d75e5238f237d15bc8ba5345dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8d00d75e5238f237d15bc8ba5345dd">&#9670;&nbsp;</a></span>lu_build_update_to_solve_upper_or_lower_dependencies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::lu_build_update_to_solve_upper_or_lower_dependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>solve_upper_or_lower_block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create the task node dependencies from <code>update</code> task to <code>solve_upper</code> task or <code>solve_lower</code> task by starting from a \(\mathcal{H}\)-matrix node which is itself associated with a <code>solve_upper</code> or <code>solve_lower</code> task node. </p>
<p >Recursion into child matrices.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l33475">33475</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, and <a class="el" href="hmatrix_8h_source.html#l04414">HMatrix&lt; spacedim, Number &gt;::solve_upper_or_lower_lu_or_cholesky_graph_node</a>.</p>

</div>
</div>
<a id="a62bf4feff6b7c2dc0f32d3eb4868a6a9" name="a62bf4feff6b7c2dc0f32d3eb4868a6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bf4feff6b7c2dc0f32d3eb4868a6a9">&#9670;&nbsp;</a></span>lu_factorize_diagonal_block_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::lu_factorize_diagonal_block_task </td>
          <td>(</td>
          <td class="paramtype">tbb::flow::graph &amp;&#160;</td>
          <td class="paramname"><em>dag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mutex &amp;&#160;</td>
          <td class="paramname"><em>log_stream_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a task node for the LU factorization of the current diagonal block. It only has actual computation when the current \(\mathcal{H}\)-matrix node belongs to the leaf set. </p>
<p >Only a diagonal block can be directly factorized.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and the LU factorization can be directly applied to it using LAPACK.</p>
<p >N.B. The LU factorization performed by LAPACK has row partial pivoting.</p>
<p >After the LU factorization, L and U matrices are stored in the same full matrix. Hence, this operation is in situ.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l33172">33172</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l32796">HMatrix&lt; spacedim, Number &gt;::compute_lu_dag()</a>.</p>

</div>
</div>
<a id="ac54cb4e40086a5ac8d1effac05ab64fe" name="ac54cb4e40086a5ac8d1effac05ab64fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54cb4e40086a5ac8d1effac05ab64fe">&#9670;&nbsp;</a></span>lu_or_cholesky_build_solve_upper_to_update_dependencies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::lu_or_cholesky_build_solve_upper_to_update_dependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>update_block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create the task node dependencies from a <code>solve_upper</code> task to an <code>update</code> task. </p>
<p >If the current \(\mathcal{H}\)-matrix node has been associated with a <code>solve_upper</code> node, link it with the newest <code>update</code> node in the <code>update_block</code>.</p>
<p >Recursion into child matrices.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l33357">33357</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04355">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, and <a class="el" href="hmatrix_8h_source.html#l04419">HMatrix&lt; spacedim, Number &gt;::update_lu_or_cholesky_graph_nodes</a>.</p>

</div>
</div>
<a id="ab18244798da62ef79736267a31e8b7e5" name="ab18244798da62ef79736267a31e8b7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18244798da62ef79736267a31e8b7e5">&#9670;&nbsp;</a></span>lu_solve_lower_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::lu_solve_lower_task </td>
          <td>(</td>
          <td class="paramtype">tbb::flow::graph &amp;&#160;</td>
          <td class="paramname"><em>dag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mutex &amp;&#160;</td>
          <td class="paramname"><em>log_stream_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Solve the problem of \(LX=Z\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dag</td><td></td></tr>
    <tr><td class="paramname">Z</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be a diagonal block, while \(Z\) is not.</p>
<p >There should be no <code>solve_upper</code> or <code>solve_lower</code> task associated with the \(\mathcal{H}\)-matrix node \(Z\).</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l33267">33267</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, and <a class="el" href="hmatrix_8h_source.html#l04414">HMatrix&lt; spacedim, Number &gt;::solve_upper_or_lower_lu_or_cholesky_graph_node</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l32796">HMatrix&lt; spacedim, Number &gt;::compute_lu_dag()</a>.</p>

</div>
</div>
<a id="abca060b26379cd6f346f7c7befe814bf" name="abca060b26379cd6f346f7c7befe814bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca060b26379cd6f346f7c7befe814bf">&#9670;&nbsp;</a></span>lu_solve_upper_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::lu_solve_upper_task </td>
          <td>(</td>
          <td class="paramtype">tbb::flow::graph &amp;&#160;</td>
          <td class="paramname"><em>dag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mutex &amp;&#160;</td>
          <td class="paramname"><em>log_stream_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Solve the problem of \(XU=Z\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dag</td><td></td></tr>
    <tr><td class="paramname">Z</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be a diagonal block, while \(Z\) is not.</p>
<p >There should be no <code>solve_upper</code> or <code>solve_lower</code> task associated with the \(\mathcal{H}\)-matrix node \(Z\).</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l33224">33224</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04269">HMatrix&lt; spacedim, Number &gt;::block_type</a>, <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>, and <a class="el" href="hmatrix_8h_source.html#l04414">HMatrix&lt; spacedim, Number &gt;::solve_upper_or_lower_lu_or_cholesky_graph_node</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l32796">HMatrix&lt; spacedim, Number &gt;::compute_lu_dag()</a>.</p>

</div>
</div>
<a id="ade6d48cb0d859820ac38df388f991911" name="ade6d48cb0d859820ac38df388f991911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6d48cb0d859820ac38df388f991911">&#9670;&nbsp;</a></span>lu_update_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::lu_update_task </td>
          <td>(</td>
          <td class="paramtype">tbb::flow::graph &amp;&#160;</td>
          <td class="paramname"><em>dag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>diag_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>diag_column_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>diag_row_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mutex &amp;&#160;</td>
          <td class="paramname"><em>log_stream_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create the task node for updating the current \(\mathcal{H}\)-matrix node. The task node will be added to the list of update nodes associated with the current \(\mathcal{H}\)-matrix node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dag</td><td></td></tr>
    <tr><td class="paramname">same_level_column_block</td><td>It corresponds to the \(\mathcal{H}\)-matrix node \(L_{ri}\). </td></tr>
    <tr><td class="paramname">same_level_row_block</td><td>It corresponds to the \(\mathcal{H}\)-matrix node \(U_{is}\). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l33309">33309</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04367">HMatrix&lt; spacedim, Number &gt;::col_index_range</a>, and <a class="el" href="hmatrix_8h_source.html#l04361">HMatrix&lt; spacedim, Number &gt;::row_index_range</a>.</p>

</div>
</div>
<a id="adb8cd16d63388b514c016eb998d7e902" name="adb8cd16d63388b514c016eb998d7e902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8cd16d63388b514c016eb998d7e902">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::memory_consumption</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determine an estimate for the memory consumption (in bytes) of the whole \(\mathcal{H}\)-matrix hierarchy.</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l36408">36408</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a0a396e5a5035c4d4637c99cff9825ac5" name="a0a396e5a5035c4d4637c99cff9825ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a396e5a5035c4d4637c99cff9825ac5">&#9670;&nbsp;</a></span>memory_consumption_of_current_hmat_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::memory_consumption_of_current_hmat_node</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determine an estimate for the memory consumption (in bytes) of the current \(\mathcal{H}\)-matrix node.</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p >If the current \(\mathcal{H}\)-matrix node is a leaf node, get the memory for the associated matrix.</p>
<p >Count the memory for other members in the current \(\mathcal{H}\)-matrix node.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l36364">36364</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

</div>
</div>
<a id="aacba927cf5e79d0fe36ba73b710dd509" name="aacba927cf5e79d0fe36ba73b710dd509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacba927cf5e79d0fe36ba73b710dd509">&#9670;&nbsp;</a></span>memory_consumption_of_far_field_leaf_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::memory_consumption_of_far_field_leaf_set</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determine an estimate for the memory consumption (in bytes) of H-matrices in the far field leaf set. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l36455">36455</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ab30c2033a1fe84c92029044aecb48926" name="ab30c2033a1fe84c92029044aecb48926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30c2033a1fe84c92029044aecb48926">&#9670;&nbsp;</a></span>memory_consumption_of_leaf_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::memory_consumption_of_leaf_set</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determine an estimate for the memory consumption (in bytes) of H-matrices in the leaf set. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l36425">36425</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ab1c439e1d5d4ac0b1a939197031b73dc" name="ab1c439e1d5d4ac0b1a939197031b73dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c439e1d5d4ac0b1a939197031b73dc">&#9670;&nbsp;</a></span>memory_consumption_of_near_field_leaf_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::memory_consumption_of_near_field_leaf_set</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determine an estimate for the memory consumption (in bytes) of H-matrices in the near field leaf set. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l36440">36440</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aa956917ff6ea23e3cce01e575e0fe4b1" name="aa956917ff6ea23e3cce01e575e0fe4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa956917ff6ea23e3cce01e575e0fe4b1">&#9670;&nbsp;</a></span>mmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>adding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of two \(\mathcal{H}\)-matrices, the result of which will be appended to the target matrix <code>C</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">bct_a</td><td></td></tr>
    <tr><td class="paramname">bct_b</td><td></td></tr>
    <tr><td class="paramname">bct_c</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">adding</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29298">29298</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l29431">HMatrix&lt; spacedim, Number &gt;::add()</a>.</p>

</div>
</div>
<a id="afa763338d356defaa27703af609c99ac" name="afa763338d356defaa27703af609c99ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa763338d356defaa27703af609c99ac">&#9670;&nbsp;</a></span>mmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplication of two \(\mathcal{H}\)-matrices \(C = A \cdot B\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">bct_a</td><td></td></tr>
    <tr><td class="paramname">bct_b</td><td></td></tr>
    <tr><td class="paramname">bct_c</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section">
<dt>Work flow </dt>
<dd><p class="startdd"></p>
<ul>
<li>
<p class="startli">Release the resource of the result matrix.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Initialize the induced block cluster tree \(T_{\rm ind}\) for the result matrix with a single root node.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Associate with the root node of the induced block cluster tree \(T_{\rm ind}\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Perform recursive multiplication while constructing the induced block cluster tree \(T_{\rm ind}\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">After the construction of the induced block cluster tree \(T_{\rm ind}\), rebuild its leaf set as well as near field and far field sets, and update the tree depth and maximum level.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Build the leaf set of the result matrix.</p>
<p class="endli"></p>
</li>
</ul>
</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29207">29207</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="block__cluster__tree_8h_source.html#l03786">BlockClusterTree&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="hmatrix_8h_source.html#l35914">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="block__cluster__tree_8h_source.html#l03981">BlockClusterTree&lt; spacedim, Number &gt;::calc_depth_and_max_level()</a>, <a class="el" href="block__cluster__tree_8h_source.html#l03719">BlockClusterTree&lt; spacedim, Number &gt;::categorize_near_and_far_field_sets()</a>, <a class="el" href="tree_8h_source.html#l00899">TreeNode&lt; T, N &gt;::get_data_reference()</a>, <a class="el" href="block__cluster__tree_8h_source.html#l04038">BlockClusterTree&lt; spacedim, Number &gt;::get_n_min()</a>, <a class="el" href="block__cluster__tree_8h_source.html#l02127">BlockClusterTree&lt; spacedim, Number &gt;::get_root()</a>, <a class="el" href="hmatrix_8h_source.html#l12403">h_h_mmult_phase1_recursion()</a>, <a class="el" href="hmatrix_8h_source.html#l12474">h_h_mmult_phase2()</a>, <a class="el" href="hmatrix_8h_source.html#l04455">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="hmatrix_8h_source.html#l18885">HMatrix&lt; spacedim, Number &gt;::release()</a>, and <a class="el" href="hmatrix_8h_source.html#l04383">HMatrix&lt; spacedim, Number &gt;::Tind</a>.</p>

</div>
</div>
<a id="a803bffdbc9cae08918593254afccbb39" name="a803bffdbc9cae08918593254afccbb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803bffdbc9cae08918593254afccbb39">&#9670;&nbsp;</a></span>mmult_level_conserving() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::mmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Level conserving \(\mathcal{H}\)-matrix multiplication with a factored multiplied to the matrix product, the result of which will be appended to the target matrix <code>C</code>, i.e. \(C = C + \alpha \cdot A B\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29335">29335</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aca1081a7c682ba916d9fe4aa9c39ccc4" name="aca1081a7c682ba916d9fe4aa9c39ccc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1081a7c682ba916d9fe4aa9c39ccc4">&#9670;&nbsp;</a></span>mmult_level_conserving() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::mmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Level conserving \(\mathcal{H}\)-matrix multiplication, the result of which will be appended to the target matrix <code>C</code>, i.e. \(C = C + AB\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29322">29322</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l16039">h_h_mmult_level_conserving()</a>.</p>

</div>
</div>
<a id="a03a1a1b175d315371967719b97772d19" name="a03a1a1b175d315371967719b97772d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a1a1b175d315371967719b97772d19">&#9670;&nbsp;</a></span>mmult_level_conserving_for_parallel_lu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::mmult_level_conserving_for_parallel_lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29349">29349</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a7b80a79d32414d2bd3fe24bc2891981a" name="a7b80a79d32414d2bd3fe24bc2891981a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b80a79d32414d2bd3fe24bc2891981a">&#9670;&nbsp;</a></span>mTmult_level_conserving() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::mTmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Level conserving \(\mathcal{H}\)-matrix multiplication with the second operand being transposed, the result of which will be multiplied by a factor and then appended to the target matrix <code>C</code>, i.e. \(C = C + \alpha \cdot A B^T\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29376">29376</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a24219f800e4e43e658cb85c8a792a661" name="a24219f800e4e43e658cb85c8a792a661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24219f800e4e43e658cb85c8a792a661">&#9670;&nbsp;</a></span>mTmult_level_conserving() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::mTmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Level conserving \(\mathcal{H}\)-matrix multiplication with the second operand being transposed, the result of which will be appended to the target matrix <code>C</code>, i.e. \(C = C + A B^T\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29363">29363</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l16558">h_h_mTmult_level_conserving()</a>.</p>

</div>
</div>
<a id="aaf9b5368ed1505c886ef3364ba148cbd" name="aaf9b5368ed1505c886ef3364ba148cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9b5368ed1505c886ef3364ba148cbd">&#9670;&nbsp;</a></span>mTmult_level_conserving_for_parallel_cholesky()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::mTmult_level_conserving_for_parallel_cholesky </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29390">29390</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a83958971f40409b3b2a192b71eae1513" name="a83958971f40409b3b2a192b71eae1513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83958971f40409b3b2a192b71eae1513">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Assignment via deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l18140">18140</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l17518">copy_hmatrix()</a>.</p>

</div>
</div>
<a id="a6a8fe1da532131cb665bf2f3e15f5edf" name="a6a8fe1da532131cb665bf2f3e15f5edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8fe1da532131cb665bf2f3e15f5edf">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assignment via shallow copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p ><b>This test prevents self-assignment.</b></p>
<p ><b>When the block cluster node corresponding to the current \(\mathcal{H}\)-matrix node is the root node and the \(\mathcal{H}\)-matrix has no children, the leaf set should be rebuilt because it previously stored the \(\mathcal{H}\)-matrix node pointer of <code>H</code>.</b></p>
<p ><b>N.B. In \(\mathcal{H}\)-matrix algebraic operations, there will be the case that an \(\mathcal{H}\)-matrix node is created with respect to a non-root block cluster node. Even though the \(\mathcal{H}\)-matrix node itself has no parent, its associated block cluster node has parent. In this case, the leaf set will not be rebuilt.</b></p>
<p >Since there is only one node in the \(\mathcal{H}\)-matrix hierarchy, there is no need to link nodes on same levels.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l18095">18095</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l17421">copy_hmatrix_node()</a>, and <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix__symm__preconditioner_8h_source.html#l00303">HMatrixSymmPreconditioner&lt; spacedim, Number &gt;::operator=()</a>.</p>

</div>
</div>
<a id="ae170394e8f48f5b99d4cc4f7954dfdec" name="ae170394e8f48f5b99d4cc4f7954dfdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae170394e8f48f5b99d4cc4f7954dfdec">&#9670;&nbsp;</a></span>prepare_for_vmult_or_tvmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::prepare_for_vmult_or_tvmult </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_vmult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_tvmult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Prepare thread data for task parallel \(\mathcal{H}\)-matrix/vector multiplication, including <code>vmult</code> , <code>Tvmult</code> and <code>Hvmult</code> .</p>
<p >This function is called once before multiple calls of task parallel versions of <code>vmult</code> , <code>Tvmult</code> or <code>Hvmult</code> by an iterative solver.</p>
<p >The \(\mathcal{H}\)-matrix calling this function should be at the top level. When this \(\mathcal{H}\)-matrix is symmetric or Hermite symmetric, both <code>is_vmult</code> and <code>is_tvmult</code> should be set to <code>true</code>, since each lower triangular matrix block as well as its counterpart upper triangular matrix block should be multiplied with the vector.</p>
<p >Even though the \(\mathcal{H}\)-matrix is not symmetric or Hermite symmetric, <code>vmult</code> , <code>Tvmult</code> or <code>Hvmult</code> may be called consecutively by an iterative solver. This scenario appears in the problem with mixed boundary condition. Then, the two flags should also be set to <code>true</code> .</p>
<p >For a general \(\mathcal{H}\)-matrix, if <code>vmult</code> is called, <code>is_vmult</code> should be set to <code>true</code> . If <code>Tvmult</code> or <code>Hvmult</code> is called, <code>is_tvmult</code> should be set to <code>true</code> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is_vmult</td><td>Flag for enabling <code>vmult</code>. </td></tr>
    <tr><td class="paramname">is_tvmult</td><td>Flag for enabling <code>Tvmult</code> or <code>Hvmult</code> . </td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be at the top level.</p>
<p >Only when the thread number is larger than 1, there will be actual data preparation.</p>
<p >Compute the task costs for all leaf \(\mathcal{H}\)-matrix nodes.</p>
<p >Generate the cost function for sequence partition.</p>
<p >Compute the index range of the local result vector.</p>
<p >Initialize local result vector.</p>
<p >Compute the index range related to the result vector on this thread.</p>
<p >Compute the index range of the local result vector.</p>
<p >Initialize local result vector.</p>
<p >Compute the index range related to the result vector on this thread.</p>
<p >Compute the index ranges within result vector, which have contributions from other threads.</p>
<p >Compute the index ranges within result vector, which have contributions from other threads.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35129">35129</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a6def1971478e41bf08cd5df77f9873ed" name="a6def1971478e41bf08cd5df77f9873ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6def1971478e41bf08cd5df77f9873ed">&#9670;&nbsp;</a></span>print_as_formatted_full_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::print_as_formatted_full_matrix </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>zero_string</em> = <code>&quot;0&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>denominator</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Print the \(\mathcal{H}\)-matrix as a <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code> to Octave mat format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">precision</td><td></td></tr>
    <tr><td class="paramname">scientific</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">zero_string</td><td></td></tr>
    <tr><td class="paramname">denominator</td><td></td></tr>
    <tr><td class="paramname">threshold</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19992">19992</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="lapack__full__matrix__ext_8h_source.html#l06887">LAPACKFullMatrixExt&lt; Number &gt;::print_formatted_to_mat()</a>.</p>

</div>
</div>
<a id="aab0c393acf1c416ebc7ab05ca85d9e49" name="aab0c393acf1c416ebc7ab05ca85d9e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0c393acf1c416ebc7ab05ca85d9e49">&#9670;&nbsp;</a></span>print_current_matrix_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::print_current_matrix_info </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Print the current \(\mathcal{H}\)-matrix node information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Print the size of \(\Sigma_b^P\), \(\Sigma_b^R\) and \(\Sigma_b^F\).</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19913">19913</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a7e849f7e8f35e3ebdfcb2dbb7ad4ad01" name="a7e849f7e8f35e3ebdfcb2dbb7ad4ad01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e849f7e8f35e3ebdfcb2dbb7ad4ad01">&#9670;&nbsp;</a></span>print_formatted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::print_formatted </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>zero_string</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>denominator</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Print the \(\mathcal{H}\)-matrix data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">precision</td><td></td></tr>
    <tr><td class="paramname">scientific</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">zero_string</td><td></td></tr>
    <tr><td class="paramname">denominator</td><td></td></tr>
    <tr><td class="paramname">threshold</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19847">19847</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00070">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="ab41e8ad6d96d27dffc21fddb8cde4544" name="ab41e8ad6d96d27dffc21fddb8cde4544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41e8ad6d96d27dffc21fddb8cde4544">&#9670;&nbsp;</a></span>print_leaf_set_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::print_leaf_set_info </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Print the leaf set information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l20017">20017</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="laplace__bem_8priv_8hcu_source.html#l01250">LaplaceBEM&lt; dim, spacedim, RangeNumberType, KernelNumberType &gt;::Priv::compute_stabilization_terms_for_D1_hmat()</a>.</p>

</div>
</div>
<a id="ad8f87883cf49080706233441c0e09171" name="ad8f87883cf49080706233441c0e09171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f87883cf49080706233441c0e09171">&#9670;&nbsp;</a></span>print_matrix_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::print_matrix_info </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Print the \(\mathcal{H}\)-matrix hierarchy information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19900">19900</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a1a659ef16f75b771cadfbdf4561cc57d" name="a1a659ef16f75b771cadfbdf4561cc57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a659ef16f75b771cadfbdf4561cc57d">&#9670;&nbsp;</a></span>print_matrix_info_as_dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::print_matrix_info_as_dot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Print the \(\mathcal{H}\)-matrix hierarchy information as directional graph in Graphviz dot format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Write the header of the Graphviz dot file.</p>
<p >Define the node style.</p>
<p >Add comment nodes.</p>
<p >Finalize the Graphviz dot file.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19958">19958</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ad2b353962226c78910d6ddb6b5b8e460" name="ad2b353962226c78910d6ddb6b5b8e460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b353962226c78910d6ddb6b5b8e460">&#9670;&nbsp;</a></span>refine_to_supertree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::refine_to_supertree</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Refine the current \(\mathcal{H}\)-matrix, whose associated block cluster tree has been extended. The operation has no accuracy loss.</p>
<p >This member function implements the operator \(\mathcal{T}_{P&#39;
\leftarrow P}^{\mathcal{H} \leftarrow \mathcal{H}}\) for the case \(T(I
\times J, P&#39;) \supset T(I \times J, P)\) in (7.9) in Hackbusch's \(\mathcal{H}\)-matrix book. Because there is no internal check about this, users should ensure that the original block cluster tree associated with this \(\mathcal{H}\)-matrix hierarchy has really been extended. </p>
<dl class="section">
<dt>Work flow </dt>
<dd><p class="startdd"></p>
<p class="interdd">Iterate over the leaf set of the \(\mathcal{H}\)-matrix hierarchy.</p>
<p class="interdd">Refine from the current \(\mathcal{H}\)-matrix leaf node.</p>
<p class="interdd">After the refinement operation, we check the number of child matrices of the current \(\mathcal{H}\)-matrix leaf node.</p>
<p class="interdd">If the current \(\mathcal{H}\)-matrix leaf node has a non-empty collection of submatrices, it has really been refined. Then delete its originally associated matrix data, either a full matrix or a rank-k matrix, and modify its matrix type as <code>HierarchicalMatrixType</code>.</p>
<p class="interdd">After the refinement operation for all the leaf nodes of the original \(\mathcal{H}\)-matrix hierarchy finishes, rebuild the leaf set of the new \(\mathcal{H}\)-matrix hierarchy.</p>
<p class="enddd"></p>
</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l36093">36093</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>, and <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

</div>
</div>
<a id="a3d8b3b5ffd2e97045467baab87652dd2" name="a3d8b3b5ffd2e97045467baab87652dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8b3b5ffd2e97045467baab87652dd2">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>property</em> = <code>HMatrixSupport::Property::general</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type</em> = <code>HMatrixSupport::BlockType::diagonal_block</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reinitialize the hierarchical structure without data from the root node of a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree.">BlockClusterTree</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bct</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51f9bf00d44b3a39d10b9d9812333820" name="a51f9bf00d44b3a39d10b9d9812333820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f9bf00d44b3a39d10b9d9812333820">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, real_type &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>property</em> = <code>HMatrixSupport::Property::general</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type</em> = <code>HMatrixSupport::BlockType::undefined_block</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reinitialize the hierarchical structure without data from a <a class="el" href="classTreeNode.html" title="Class for general tree node.">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree.">BlockClusterTree</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bc_node</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l18074">18074</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>.</p>

</div>
</div>
<a id="a812e8276888b2ad866edf7ce9b286839" name="a812e8276888b2ad866edf7ce9b286839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812e8276888b2ad866edf7ce9b286839">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::release</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Release the memory and status of the \(\mathcal{H}\)-matrix hierarchy. </p>
<p >The deletion of <code>submatrix</code> will call the destructor of this sub-HMatrix, which will further recursively call the destructor of the submatrices of this sub-HMatrix. Hence, this destructor is intrinsically recursive.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l18885">18885</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00070">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l29207">HMatrix&lt; spacedim, Number &gt;::mmult()</a>.</p>

</div>
</div>
<a id="a9e023f39b1f8916117a63557895a91b4" name="a9e023f39b1f8916117a63557895a91b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e023f39b1f8916117a63557895a91b4">&#9670;&nbsp;</a></span>remove_hmat_pair_from_mm_product_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Remove a pair of \(\mathcal{H}\)-matrix nodes from the list of matrix-matrix product subtasks to be performed, i.e. from the list <code><a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix::Sigma_P</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l36264">36264</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l12342">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11894">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10890">h_rk_mmult_for_h_h_mmult()</a>, and <a class="el" href="hmatrix_8h_source.html#l11411">rk_h_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="aa3f7b64b8d16939811a923060c29ec88" name="aa3f7b64b8d16939811a923060c29ec88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f7b64b8d16939811a923060c29ec88">&#9670;&nbsp;</a></span>remove_hmat_pair_from_mm_product_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Remove a pair of \(\mathcal{H}\)-matrix nodes from the list of matrix-matrix product subtasks to be performed, i.e. from the list <code><a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix::Sigma_P</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l36286">36286</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aeb0722edd8560ac7dfee0ca5259d0935" name="aeb0722edd8560ac7dfee0ca5259d0935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0722edd8560ac7dfee0ca5259d0935">&#9670;&nbsp;</a></span>set_block_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::set_block_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the block type of all \(\mathcal{H}\)-matrix nodes in the \(\mathcal{H}\)-matrix hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_type</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >When the current \(\mathcal{H}\)-matrix block is <code>undefined_block</code>, all child \(\mathcal{H}\)-matrices are <code>undefined_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>diagonal_block</code>, the first and fourth child \(\mathcal{H}\)-matrices are <code>diagonal_block</code>, while the second child \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code> and the third child \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>upper_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>upper_triangular_block</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix is <code>lower_triangular_block</code>, all child \(\mathcal{H}\)-matrices are <code>lower_triangular_block</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19673">19673</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a896ce340a65c96b0947736a5235d18fb" name="a896ce340a65c96b0947736a5235d18fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896ce340a65c96b0947736a5235d18fb">&#9670;&nbsp;</a></span>set_current_matrix_block_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::set_current_matrix_block_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a>&#160;</td>
          <td class="paramname"><em>block_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Set the block type of the current \(\mathcal{H}\)-matrix node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_type</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19664">19664</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a0910b5065c2edeb9135ded2010aacc7e" name="a0910b5065c2edeb9135ded2010aacc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0910b5065c2edeb9135ded2010aacc7e">&#9670;&nbsp;</a></span>set_current_matrix_property() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::set_current_matrix_property </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Set the property of the current \(\mathcal{H}\)-matrix node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19129">19129</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a6a807ab7d80f124e5713f5c1a25b03e1" name="a6a807ab7d80f124e5713f5c1a25b03e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a807ab7d80f124e5713f5c1a25b03e1">&#9670;&nbsp;</a></span>set_current_matrix_property() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::set_current_matrix_property </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the property of the current \(\mathcal{H}\)-matrix node according to the property of the associated full matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19138">19138</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="lapack__full__matrix__ext_8h_source.html#l06702">LAPACKFullMatrixExt&lt; Number &gt;::get_property()</a>.</p>

</div>
</div>
<a id="ae37523f6e2ffc646f48b2a93e1e80f92" name="ae37523f6e2ffc646f48b2a93e1e80f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37523f6e2ffc646f48b2a93e1e80f92">&#9670;&nbsp;</a></span>set_current_matrix_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::set_current_matrix_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a8358c4882bca00f7e887d9b44e633aa0">HMatrixSupport::State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the state of the current \(\mathcal{H}\)-matrix node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Set the state of the associated full matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19565">19565</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>.</p>

</div>
</div>
<a id="a6a1e7c2802c14c86080b84005bea3cf0" name="a6a1e7c2802c14c86080b84005bea3cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1e7c2802c14c86080b84005bea3cf0">&#9670;&nbsp;</a></span>set_default_vmult_strategy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::set_default_vmult_strategy</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the default strategy for the top level H-matrix/vector multiplication, which influences <code>vmult</code>, <code>Tvmult</code> and <code>Hvmult</code>. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l21032">21032</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a85e034ae910d91c3c46fc2028bdc5e18" name="a85e034ae910d91c3c46fc2028bdc5e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e034ae910d91c3c46fc2028bdc5e18">&#9670;&nbsp;</a></span>set_leaf_set_traversal_method()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::set_leaf_set_traversal_method </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615">SpaceFillingCurveType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l00140">140</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aac0d7f72ac23e856efd7d5f0b0bff4df" name="aac0d7f72ac23e856efd7d5f0b0bff4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0d7f72ac23e856efd7d5f0b0bff4df">&#9670;&nbsp;</a></span>set_property() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::set_property </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Recursively set the property of all \(\mathcal{H}\)-matrix nodes in the \(\mathcal{H}\)-matrix hierarchy.</p>
<dl class="section note">
<dt>Note</dt>
<dd>This recursive operation relies on appropriately set block types.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >When a \(\mathcal{H}\)-matrix node's property is <code>general</code>, all of its descendants have this same property.</p>
<p >Set the current \(\mathcal{H}\)-matrix node property to be <code>general</code>.</p>
<p >Set the same property for each submatrix, if there are any.</p>
<p >If the current \(\mathcal{H}\)-matrix node is symmetric, it should belong to the diagonal part. Hence we make an assertion.</p>
<p >When the current \(\mathcal{H}\)-matrix node is not a leaf node, we currently only handle the situation where there are four child matrices.</p>
<dl class="section note">
<dt>Note</dt>
<dd>Because <code>AssertDimension</code> is a macro, the second argument <code><a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">BlockClusterTree&lt;spacedim, real_type&gt;::child_num</a></code> should be protected by a pair of brackets.</dd>
</dl>
<p >In my implementation of block cluster tree and \(\mathcal{H}\)-matrix construction, the first and the fourth child matrices belong to the diagonal part, the second child matrix belongs to the upper triangular part and the third child matrix belongs to the lower triangular part.</p>
<h2><code> </code></h2>
<p ><code> </p><h2>|0 | 1| </h2>
<p></code></p>
<p ><code> </p><h2>|2 | 3| </h2>
<p></code></p>
<p ><code> </code></p>
<p >After the assertion about block type has been made, set the property of each submatrix recursively.</p>
<p >When the current \(\mathcal{H}\)-matrix node is a leaf node, because it must be a diagonal block, it should be a full matrix.</p>
<p >If the current \(\mathcal{H}\)-matrix node is Hermite symmetric, it should belong to the diagonal part. Hence we make an assertion.</p>
<p >When the current \(\mathcal{H}\)-matrix node is not a leaf node, we currently only handle the situation where there are four child matrices.</p>
<dl class="section note">
<dt>Note</dt>
<dd>Because <code>AssertDimension</code> is a macro, the second argument <code><a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">BlockClusterTree&lt;spacedim, real_type&gt;::child_num</a></code> should be protected by a pair of brackets.</dd>
</dl>
<p >In my implementation of block cluster tree and \(\mathcal{H}\)-matrix construction, the first and the fourth child matrices belong to the diagonal part, the second child matrix belongs to the upper triangular part and the third child matrix belongs to the lower triangular part.</p>
<h2><code> </code></h2>
<p ><code> </p><h2>|0 | 1| </h2>
<p></code></p>
<p ><code> </p><h2>|2 | 3| </h2>
<p></code></p>
<p ><code> </code></p>
<p >After the assertion about block type has been made, set the property of each submatrix recursively.</p>
<p >When the current \(\mathcal{H}\)-matrix node is a leaf node, because it must be a diagonal block, it should be a full matrix.</p>
<p >If the current \(\mathcal{H}\)-matrix node is upper triangular, it should belong to the diagonal part. Hence we make an assertion.</p>
<p >When the current \(\mathcal{H}\)-matrix node is not a leaf node, we currently only handle the situation where there are four child matrices.</p>
<dl class="section note">
<dt>Note</dt>
<dd>Because <code>AssertDimension</code> is a macro, the second argument <code><a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">BlockClusterTree&lt;spacedim, real_type&gt;::child_num</a></code> should be protected by a pair of brackets.</dd>
</dl>
<p >In my implementation of block cluster tree and \(\mathcal{H}\)-matrix construction, the first and the fourth child matrices belong to the diagonal part, the second child matrix belongs to the upper triangular part and the third child matrix belongs to the lower triangular part.</p>
<p >After the assertion about block type has been made, set the property of each submatrix recursively.</p>
<p >When the current \(\mathcal{H}\)-matrix node is a leaf node, because it is a diagonal block, it should be a full matrix.</p>
<p >If the current \(\mathcal{H}\)-matrix node is lower triangular, it should belong to the diagonal part. Hence we make an assertion.</p>
<p >When the current \(\mathcal{H}\)-matrix node is not a leaf node, we currently only handle the situation where there are four child matrices.</p>
<dl class="section note">
<dt>Note</dt>
<dd>Because <code>AssertDimension</code> is a macro, the second argument <code><a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">BlockClusterTree&lt;spacedim, real_type&gt;::child_num</a></code> should be protected by a pair of brackets.</dd>
</dl>
<p >In my implementation of block cluster tree and \(\mathcal{H}\)-matrix construction, the first and the fourth child matrices belong to the diagonal part, the second child matrix belongs to the upper triangular part and the third child matrix belongs to the lower triangular part.</p>
<p >After the assertion about block type has been made, set the property of each submatrix recursively.</p>
<p >When the current \(\mathcal{H}\)-matrix node is a leaf node, because it is a diagonal block, it should be a full matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19178">19178</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>.</p>

</div>
</div>
<a id="a00b19edf2d99ada13990fdbfe4b7bd90" name="a00b19edf2d99ada13990fdbfe4b7bd90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b19edf2d99ada13990fdbfe4b7bd90">&#9670;&nbsp;</a></span>set_property() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::set_property </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the property of all \(\mathcal{H}\)-matrix nodes in the \(\mathcal{H}\)-matrix hierarchy. The property of the top level \(\mathcal{H}\)-matrix node is determined from the associated full matrix.</p>
<dl class="section note">
<dt>Note</dt>
<dd>This recursive operation relies on appropriately set block types.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Determine the current \(\mathcal{H}\)-matrix node property from the given full matrix.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19552">19552</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ad7f87f1cd5637e27b33c02aec0dbbfbe" name="ad7f87f1cd5637e27b33c02aec0dbbfbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f87f1cd5637e27b33c02aec0dbbfbe">&#9670;&nbsp;</a></span>set_property_for_converted_fullmatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::set_property_for_converted_fullmatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Set the matrix property of the converted full matrix based on the property of the current \(\mathcal{H}\)-matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l20210">20210</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="lapack__full__matrix__ext_8h_source.html#l06679">LAPACKFullMatrixExt&lt; Number &gt;::set_property()</a>.</p>

</div>
</div>
<a id="ac8b53f819723d341285ab93b7cc32f7f" name="ac8b53f819723d341285ab93b7cc32f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b53f819723d341285ab93b7cc32f7f">&#9670;&nbsp;</a></span>set_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::set_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a8358c4882bca00f7e887d9b44e633aa0">HMatrixSupport::State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Recursively set the state of all \(\mathcal{H}\)-matrix nodes in the \(\mathcal{H}\)-matrix hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >All submatrices inherit the same state from their parent.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l19640">19640</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l33785">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_factorization()</a>, and <a class="el" href="hmatrix_8h_source.html#l32473">HMatrix&lt; spacedim, Number &gt;::compute_lu_factorization()</a>.</p>

</div>
</div>
<a id="af096bc12ca77bb1a71282fa1ce03ad23" name="af096bc12ca77bb1a71282fa1ce03ad23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af096bc12ca77bb1a71282fa1ce03ad23">&#9670;&nbsp;</a></span>set_vmult_strategy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::set_vmult_strategy </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classHMatrixVmultStrategy.html">HMatrixVmultStrategy</a>&lt; spacedim, Number &gt; &gt;&#160;</td>
          <td class="paramname"><em>strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the strategy for the top level H-matrix/vector multiplication, which influences <code>vmult</code>, <code>Tvmult</code> and <code>Hvmult</code>. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l21042">21042</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aa81db0ff79182302de83d693bab9f9e3" name="aa81db0ff79182302de83d693bab9f9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81db0ff79182302de83d693bab9f9e3">&#9670;&nbsp;</a></span>solve_block_triangular_by_backward_substitution() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_block_triangular_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_block_diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the block upper triangular matrix \(Ux=b\) by backward substitution. The result vector will overwrite the RHS vector <code>b</code>.</p>
<p >It has two differences from the version for solving an upper triangular \(\mathcal{H}\)-matrix,</p>
<ol type="1">
<li>when the block upper triangular matrix is unit, each of its diagonal blocks in the leaf set, which must be a full matrix, should be an identity matrix instead of an upper triangular full matrix with unit diagonal, i.e. \(L\vert_{\tau\times\tau} = I\) for \(\tau\times\tau
\in P\). In this case, there is no need to actually solve it.</li>
<li>when the block upper triangular matrix is not unit, its diagonal blocks in the leaf set should be general full matrices instead of upper triangular full matrices. In this case, a general linear system solver should be adopted to solve it.</li>
</ol>
<p ><b>Even though the member variables of the current class will be not be modified, the actual heap memory data related to full matrix in the leaf set will be changed, since LU factorization will be performed.</b></p>
<p ><b>The vector <code>b</code> is <b>global</b>, which can be directly accessed by DoF indices in the cluster's index range.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be square.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be solved via LU factorization.</p>
<p >In this case, the diagonal block in the leaf set should be an identity matrix, the solution <code>x</code> is the same as the right hand side vector <code>b</code>, so here we do nothing.</p>
<p >In this case, the diagonal block in the leaf set should be general full matrix and forward substitution cannot be applied any more. Instead, LU factorization is adopted.</p>
<p >Restrict vector <code>b</code> to the column cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p >Solve the full matrix using LU factorization.</p>
<p >Copy back the restricted vector <code>local_b</code> to the <b>global</b> vector <code>b</code>.</p>
<p >Iterate over each block row of the matrix.</p>
<p >For the type of the loop variable <code>i</code>, if <code>unsigned int</code> is used, when <code>i</code> is zero, <code>i--</code> produces the largest integer that <code>unsigned int</code> can represent, which is larger than zero. Then the loop will not stop.</p>
<p >Iterate each block column after the i'th column, i.e. after the diagonal submatrix block.</p>
<p >Solve the current diagonal block using backward substitution.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l32033">32033</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a113c6b3209c415501f721bc55766d880" name="a113c6b3209c415501f721bc55766d880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113c6b3209c415501f721bc55766d880">&#9670;&nbsp;</a></span>solve_block_triangular_by_backward_substitution() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_block_triangular_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_block_diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the block upper triangular matrix \(Ux=b\) by backward substitution. The result vector will overwrite the RHS vector <code>b</code>.</p>
<p >It has two differences from the version for solving an upper triangular \(\mathcal{H}\)-matrix,</p>
<ol type="1">
<li>when the block upper triangular matrix is unit, each of its diagonal blocks in the leaf set, which must be a full matrix, should be an identity matrix instead of an upper triangular full matrix with unit diagonal, i.e. \(L\vert_{\tau\times\tau} = I\) for \(\tau\times\tau
\in P\). In this case, there is no need to actually solve it.</li>
<li>when the block upper triangular matrix is not unit, its diagonal blocks in the leaf set should be general full matrices instead of upper triangular full matrices. In this case, a general linear system solver should be adopted to solve it.</li>
</ol>
<p ><b>Even though the member variables of the current class will be not be modified, the actual heap memory data related to full matrix in the leaf set will be changed, since LU factorization will be performed.</b></p>
<p ><b>The vector <code>b</code> is <b>local</b>, i.e. associated with a cluster. Therefore, the starting \(\mathcal{H}\)-matrix should be explicitly specified.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">starting_hmat</td><td></td></tr>
    <tr><td class="paramname">is_unit_block_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be square.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be solved via LU factorization.</p>
<p >In this case, the diagonal block in the leaf set should be an identity matrix, the solution <code>x</code> is the same as the right hand side vector <code>b</code>, so here we do nothing.</p>
<p >In this case, the diagonal block in the leaf set should be general full matrix and forward substitution cannot be applied any more. Instead, LU factorization is adopted.</p>
<p >Restrict vector <code>b</code> to the column cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p >Solve the full matrix using LU factorization.</p>
<p >Copy back the restricted vector <code>local_b</code> to the <b>global</b> vector <code>b</code>.</p>
<p >Iterate over each block row of the matrix.</p>
<p >For the type of the loop variable <code>i</code>, if <code>unsigned int</code> is used, when <code>i</code> is zero, <code>i--</code> produces the largest integer that <code>unsigned int</code> can represent, which is larger than zero. Then the loop will not stop.</p>
<p >Iterate each block column after the i'th column, i.e. after the diagonal submatrix block.</p>
<p >Solve the current diagonal block using backward substitution.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l32146">32146</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a69432f004b60ade76aaabf2c94dd205c" name="a69432f004b60ade76aaabf2c94dd205c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69432f004b60ade76aaabf2c94dd205c">&#9670;&nbsp;</a></span>solve_block_triangular_by_backward_substitution() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_block_triangular_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_block_diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the block upper triangular matrix \(Ux=b\) by backward substitution.</p>
<p >It has two differences from the version for solving an upper triangular \(\mathcal{H}\)-matrix,</p>
<ol type="1">
<li>when the block upper triangular matrix is unit, each of its diagonal blocks in the leaf set, which must be a full matrix, should be an identity matrix instead of an upper triangular full matrix with unit diagonal, i.e. \(L\vert_{\tau\times\tau} = I\) for \(\tau\times\tau
\in P\). In this case, there is no need to actually solve it.</li>
<li>when the block upper triangular matrix is not unit, its diagonal blocks in the leaf set should be general full matrices instead of upper triangular full matrices. In this case, a general linear system solver should be adopted to solve it.</li>
</ol>
<p ><b>Even though the member variables of the current class will be not be modified, the actual heap memory data related to full matrix in the leaf set will be changed, since LU factorization will be performed.</b></p>
<p ><b>The vector <code>b</code> is <b>global</b>, which can be directly accessed by DoF indices in the cluster's index range.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">is_unit_block_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l32134">32134</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="adf3f278df6f64dc3e140f5fbf47e42a5" name="adf3f278df6f64dc3e140f5fbf47e42a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3f278df6f64dc3e140f5fbf47e42a5">&#9670;&nbsp;</a></span>solve_block_triangular_by_backward_substitution() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_block_triangular_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_block_diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the block upper triangular matrix \(Ux=b\) by backward substitution.</p>
<p >It has two differences from the version for solving an upper triangular \(\mathcal{H}\)-matrix,</p>
<ol type="1">
<li>when the block upper triangular matrix is unit, each of its diagonal blocks in the leaf set, which must be a full matrix, should be an identity matrix instead of an upper triangular full matrix with unit diagonal, i.e. \(L\vert_{\tau\times\tau} = I\) for \(\tau\times\tau
\in P\). In this case, there is no need to actually solve it.</li>
<li>when the block upper triangular matrix is not unit, its diagonal blocks in the leaf set should be general full matrices instead of upper triangular full matrices. In this case, a general linear system solver should be adopted to solve it.</li>
</ol>
<p ><b>Even though the member variables of the current class will be not be modified, the actual heap memory data related to full matrix in the leaf set will be changed, since LU factorization will be performed.</b></p>
<p ><b>The vector <code>b</code> is <b>local</b>, i.e. associated with a cluster. Therefore, the starting \(\mathcal{H}\)-matrix should be explicitly specified.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">starting_hmat</td><td></td></tr>
    <tr><td class="paramname">is_unit_block_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l32254">32254</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ab8b64d4a5b7120a2599ec3e3e0708775" name="ab8b64d4a5b7120a2599ec3e3e0708775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b64d4a5b7120a2599ec3e3e0708775">&#9670;&nbsp;</a></span>solve_block_triangular_by_forward_substitution() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_block_triangular_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_block_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the block lower triangular matrix \(Lx=b\) by forward substitution.</p>
<p >It has two differences from the version for solving a lower triangular \(\mathcal{H}\)-matrix,</p>
<ol type="1">
<li>when the block lower triangular matrix is unit, each of its diagonal blocks in the leaf set, which must be a full matrix, should be an identity matrix instead of a lower triangular full matrix with unit diagonal, i.e. \(L\vert_{\tau\times\tau} = I\) for \(\tau\times\tau
\in P\). In this case, there is no need to actually solve it.</li>
<li>when the block lower triangular matrix is not unit, its diagonal blocks in the leaf set should be general full matrices instead of lower triangular full matrices. In this case, a general linear system solver should be adopted to solve it.</li>
</ol>
<p ><b>Even though the member variables of the current class will be not be modified, the actual heap memory data related to full matrix in the leaf set will be changed, since LU factorization will be performed.</b></p>
<p ><b>The vector <code>b</code> is <b>global</b>, which can be directly accessed by DoF indices in the cluster's index range.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be square.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be solved via LU factorization.</p>
<p >In this case, the diagonal block in the leaf set should be an identity matrix, the solution <code>x</code> is the same as the right hand side vector <code>b</code>, so here we do nothing.</p>
<p >In this case, the diagonal block in the leaf set should be general full matrix and forward substitution cannot be applied any more. Instead, LU factorization is adopted.</p>
<p >Restrict vector <code>b</code> to the column cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p >Solve the full matrix using LU factorization.</p>
<p >Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p >Iterate over each block row of the matrix.</p>
<p >Iterate each block column before the i'th column, i.e. before the diagonal submatrix block.</p>
<p >Solve the current diagonal block using forward substitution recursively.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l31560">31560</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a0436e9d29e57d1c4d69c6821b5a93519" name="a0436e9d29e57d1c4d69c6821b5a93519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0436e9d29e57d1c4d69c6821b5a93519">&#9670;&nbsp;</a></span>solve_block_triangular_by_forward_substitution() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_block_triangular_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_block_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the block lower triangular matrix \(Lx=b\) by forward substitution. The result vector will overwrite the RHS vector <code>b</code>.</p>
<p >It has two differences from the version for solving a lower triangular \(\mathcal{H}\)-matrix,</p>
<ol type="1">
<li>when the block lower triangular matrix is unit, each of its diagonal blocks in the leaf set, which must be a full matrix, should be an identity matrix instead of a lower triangular full matrix with unit diagonal, i.e. \(L\vert_{\tau\times\tau} = I\) for \(\tau\times\tau
\in P\). In this case, there is no need to actually solve it.</li>
<li>when the block lower triangular matrix is not unit, its diagonal blocks in the leaf set should be general full matrices instead of lower triangular full matrices. In this case, a general linear system solver should be adopted to solve it.</li>
</ol>
<p ><b>Even though the member variables of the current class will be not be modified, the actual heap memory data related to full matrix in the leaf set will be changed, since LU factorization will be performed.</b></p>
<p ><b>The vector <code>b</code> is <b>local</b>, i.e. associated with a cluster. Therefore, the starting \(\mathcal{H}\)-matrix should be explicitly specified.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">starting_hmat</td><td></td></tr>
    <tr><td class="paramname">is_unit_block_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be square.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be solved via LU factorization.</p>
<p >In this case, the diagonal block in the leaf set should be an identity matrix, the solution <code>x</code> is the same as the right hand side vector <code>b</code>, so here we do nothing.</p>
<p >In this case, the diagonal block in the leaf set should be general full matrix and forward substitution cannot be applied any more. Instead, LU factorization is adopted.</p>
<p >Restrict vector <code>b</code> to the column cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p >Solve the full matrix using LU factorization.</p>
<p >Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p >Iterate over each block row of the matrix.</p>
<p >Iterate each block column before the i'th column, i.e. before the diagonal submatrix block.</p>
<p >Solve the current diagonal block using forward substitution recursively.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l31668">31668</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aa8046a87be454c81d4a884b53150685a" name="aa8046a87be454c81d4a884b53150685a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8046a87be454c81d4a884b53150685a">&#9670;&nbsp;</a></span>solve_block_triangular_by_forward_substitution() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_block_triangular_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_block_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the block lower triangular matrix \(Lx=b\) by forward substitution.</p>
<p ><b>The vector <code>b</code> is <b>global</b>, which can be directly accessed by DoF indices in the cluster's index range.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">is_unit_block_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l31656">31656</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a8b82f66044e334adea7eefac058f5f88" name="a8b82f66044e334adea7eefac058f5f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b82f66044e334adea7eefac058f5f88">&#9670;&nbsp;</a></span>solve_block_triangular_by_forward_substitution() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_block_triangular_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_block_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the block lower triangular matrix \(Lx=b\) by forward substitution.</p>
<p >It has two differences from the version for solving a lower triangular \(\mathcal{H}\)-matrix,</p>
<ol type="1">
<li>when the block lower triangular matrix is unit, each of its diagonal blocks in the leaf set, which must be a full matrix, should be an identity matrix instead of a lower triangular full matrix with unit diagonal, i.e. \(L\vert_{\tau\times\tau} = I\) for \(\tau\times\tau
\in P\). In this case, there is no need to actually solve it.</li>
<li>when the block lower triangular matrix is not unit, its diagonal blocks in the leaf set should be general full matrices instead of lower triangular full matrices. In this case, a general linear system solver should be adopted to solve it.</li>
</ol>
<p ><b>Even though the member variables of the current class will be not be modified, the actual heap memory data related to full matrix in the leaf set will be changed, since LU factorization will be performed.</b></p>
<p ><b>The vector <code>b</code> is <b>local</b>, i.e. associated with a cluster. Therefore, the starting \(\mathcal{H}\)-matrix should be explicitly specified.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">starting_hmat</td><td></td></tr>
    <tr><td class="paramname">is_unit_block_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l31771">31771</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ac7231b00a53ef6b860d774d1daad738f" name="ac7231b00a53ef6b860d774d1daad738f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7231b00a53ef6b860d774d1daad738f">&#9670;&nbsp;</a></span>solve_by_backward_substitution() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the upper triangular matrix \(Ux=b\) by backward substitution.</p>
<p >The right hand side vector \(b\) will be overwritten by the solution vector \(x\).</p>
<p ><b>The vector <code>b</code> is <b>global</b>, which can be directly accessed by DoF indices in the cluster's index range.</b></p>
<dl class="section note">
<dt>Note</dt>
<dd>N.B. The default value for <code>is_unit_diagonal</code> is <code>false</code>, while in <code>solve_by_forward_substitution</code>, this the default value is <code>true</code>. This is because the matrix to be solved is usually derived from a LU factorization, which ensures the lower triangular matrix has unit diagonal while the upper triangular matrix does not.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side vector and after execution, it stores the result vector. </td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be square.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via backward substitution.</p>
<p >Restrict vector <code>b</code> to the column cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p >Perform backward substitution for the full matrix.</p>
<p >Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p >Iterate over each block row of the matrix.</p>
<p >For the type of the loop variable <code>i</code>, if <code>unsigned int</code> is used, when <code>i</code> is zero, <code>i--</code> produces the largest integer that <code>unsigned int</code> can represent, which is larger than zero. Then the loop will not stop.</p>
<p >Iterate each block column after the i'th column, i.e. after the diagonal submatrix block.</p>
<p >Solve the current diagonal block using backward substitution recursively.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l31834">31834</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="af0f6334bf7f44c2351b4899c64344a23" name="af0f6334bf7f44c2351b4899c64344a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f6334bf7f44c2351b4899c64344a23">&#9670;&nbsp;</a></span>solve_by_backward_substitution() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the upper triangular matrix \(Ux=b\) by backward substitution.</p>
<p >The right hand side vector \(b\) will be overwritten by the solution vector \(x\).</p>
<p ><b>The vector <code>b</code> is <b>local</b>, i.e. associated with a cluster. Therefore, the starting \(\mathcal{H}\)-matrix should be explicitly specified.</b></p>
<dl class="section note">
<dt>Note</dt>
<dd>N.B. The default value for <code>is_unit_diagonal</code> is <code>false</code>, while in <code>solve_by_forward_substitution</code>, this the default value is <code>true</code>. This is because the matrix to be solved is usually derived from a LU factorization, which ensures the lower triangular matrix has unit diagonal while the upper triangular matrix does not.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">starting_hmat</td><td></td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be square.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via backward substitution.</p>
<p >Restrict vector <code>b</code> to the column cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p >Perform backward substitution for the full matrix.</p>
<p >Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p >Iterate over each block row of the matrix.</p>
<p >For the type of the loop variable <code>i</code>, if <code>unsigned int</code> is used, when <code>i</code> is zero, <code>i--</code> produces the largest integer that <code>unsigned int</code> can represent, which is larger than zero. Then the loop will not stop.</p>
<p >Iterate each block column after the i'th column, i.e. after the diagonal submatrix block.</p>
<p >Solve the current diagonal block using backward substitution.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l31930">31930</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ab89582b86090d18d33f7ae04deda1f5f" name="ab89582b86090d18d33f7ae04deda1f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89582b86090d18d33f7ae04deda1f5f">&#9670;&nbsp;</a></span>solve_by_backward_substitution() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the upper triangular matrix \(Ux=b\) by backward substitution.</p>
<p ><b>The vector <code>b</code> is <b>global</b>, which can be directly accessed by DoF indices in the cluster's index range.</b></p>
<dl class="section note">
<dt>Note</dt>
<dd>N.B. The default value for <code>is_unit_diagonal</code> is <code>false</code>, while in <code>solve_by_forward_substitution</code>, this the default value is <code>true</code>. This is because the matrix to be solved is usually derived from a LU factorization, which ensures the lower triangular matrix has unit diagonal while the upper triangular matrix does not.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l31918">31918</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a059a847185207f9dff8a5b20b5498a2b" name="a059a847185207f9dff8a5b20b5498a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059a847185207f9dff8a5b20b5498a2b">&#9670;&nbsp;</a></span>solve_by_backward_substitution() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the upper triangular matrix \(Ux=b\) by backward substitution.</p>
<p ><b>The vector <code>b</code> is <b>local</b>, i.e. associated with a cluster. Therefore, the starting \(\mathcal{H}\)-matrix should be explicitly specified.</b></p>
<dl class="section note">
<dt>Note</dt>
<dd>N.B. The default value for <code>is_unit_diagonal</code> is <code>false</code>, while in <code>solve_by_forward_substitution</code>, this the default value is <code>true</code>. This is because the matrix to be solved is usually derived from a LU factorization, which ensures the lower triangular matrix has unit diagonal while the upper triangular matrix does not.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">starting_hmat</td><td></td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l32020">32020</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aeee2443c3f85cd6a961e77e5287e43f9" name="aeee2443c3f85cd6a961e77e5287e43f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee2443c3f85cd6a961e77e5287e43f9">&#9670;&nbsp;</a></span>solve_by_forward_substitution() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the lower triangular matrix \(Lx=b\) by forward substitution.</p>
<p >The right hand side vector \(b\) will be overwritten by the solution vector \(x\).</p>
<p ><b>The vector <code>b</code> is <b>global</b>, which can be directly accessed by DoF indices in the cluster's index range.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side global vector. After execution, it stores the result vector. </td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be square.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via forward substitution.</p>
<p >Restrict vector <code>b</code> to the column cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p >Perform forward substitution for the full matrix. N.B. The right hand side vector should be permuted if the current lower triangular matrix is obtained from the row pivoted LU factorization.</p>
<p >Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p >Iterate over each block row of the matrix.</p>
<p >Iterate each block column before the i'th column, i.e. before the diagonal submatrix block.</p>
<p >Solve the current diagonal block using forward substitution recursively.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30244">30244</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ae0d79f163311ae5390a58afc93cbeb29" name="ae0d79f163311ae5390a58afc93cbeb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d79f163311ae5390a58afc93cbeb29">&#9670;&nbsp;</a></span>solve_by_forward_substitution() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the lower triangular matrix \(Lx=b\) by forward substitution.</p>
<p >The right hand side vector \(b\) will be overwritten by the solution vector \(x\).</p>
<p ><b>The vector <code>b</code> is <b>local</b>, i.e. associated with a cluster. Therefore, the \(\mathcal{H}\)-matrix passed at the beginning of the recursion should be explicitly specified.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side global vector. After execution, it stores the result vector. </td></tr>
    <tr><td class="paramname">starting_hmat</td><td></td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be square.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via forward substitution.</p>
<p >Restrict vector <code>b</code> to the column cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p >Perform forward substitution for the full matrix. N.B. The right hand side vector should be permuted if the current lower triangular matrix is obtained from the row pivoted LU factorization.</p>
<p >Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p >Iterate over each block row of the matrix.</p>
<p >Iterate each block column before the i'th column, i.e. before the diagonal submatrix block.</p>
<p >Solve the current diagonal block using forward substitution recursively.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30342">30342</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a4c226aaa96ad7b1a7f0c1507d43bba89" name="a4c226aaa96ad7b1a7f0c1507d43bba89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c226aaa96ad7b1a7f0c1507d43bba89">&#9670;&nbsp;</a></span>solve_by_forward_substitution() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the lower triangular matrix \(Lx=b\) by forward substitution.</p>
<p ><b>The vector <code>b</code> is <b>global</b>, which can be directly accessed by DoF indices in the cluster's index range.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td>Right hand side global vector. </td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30329">30329</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aae066471c31c11d7a33b03f6374a28bf" name="aae066471c31c11d7a33b03f6374a28bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae066471c31c11d7a33b03f6374a28bf">&#9670;&nbsp;</a></span>solve_by_forward_substitution() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the lower triangular matrix \(Lx=b\) by forward substitution.</p>
<p ><b>The vector <code>b</code> is <b>local</b>, i.e. associated with a cluster. Therefore, the starting \(\mathcal{H}\)-matrix should be explicitly specified.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">starting_hmat</td><td></td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30434">30434</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ad5d490a19746c5ecf2dff44e8a865459" name="ad5d490a19746c5ecf2dff44e8a865459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d490a19746c5ecf2dff44e8a865459">&#9670;&nbsp;</a></span>solve_by_forward_substitution_matrix_valued() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the matrix-valued problem \(L\vert_{\tau\times\tau}X\vert_{\tau\times\sigma}=Z\vert_{\tau\times\sigma}\) using forward substitution.</p>
<p ><b>1. The problem to be solved is restricted to specific block clusters. Hence, when this recursive algorithm for forward substitution comes to a leaf node of \(Z\), it implies the column vectors stored in \(Z\) are to be accessed via local indices.</p><ol type="1">
<li>The right hand side matrix \(Z\) will be modified in this algorithm during the update stage: \(Z \big\vert_{\tau[i]\times\sigma[j]} \coloneqq Z
\big\vert_{\tau[i]\times\sigma[j]} - L \big\vert_{\tau[i]\times\tau[k]}X
\big\vert_{\tau[k]\times\sigma[j]}\).</li>
</ol>
<p></b></p>
<p ><b></p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td></td></tr>
    <tr><td class="paramname">Z</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>
<p></b></p>
<p >When the current \(\mathcal{H}\)-matrix node of <code>X</code> or <code>Z</code> is a full matrix, we need to solve a multiple RHS vector problem.</p>
<p >Iterate over each column of <code>X</code> and <code>Z</code>.</p>
<p >Solve the current lower triangular \(\mathcal{H}\)-matrix \(L\vert_{\tau,\tau}X\vert_{\tau,j}=Z\vert_{\tau,j}\) using the forward substitution for \(\mathcal{H}\)-matrices.</p>
<p >Merge back the solution vector <code>X_col</code> into <code>X</code>, while the matrix <code>Z</code> is intact.</p>
<p >When the current \(\mathcal{H}\)-matrix node of <code>X</code> or <code>Z</code> is a rank-k matrix, we iterate over each column of its component matrix <code>A</code> and solve a multiple RHS problem. The resulted solution matrix <code>A'</code> is just the component matrix <code>A</code> of the rank-k matrix <code>X</code>.</p>
<p >Copy the data of the rank-k matrix <code>Z</code> to the rank-k matrix <code>X</code>. The component matrix <code>B</code> of <code>X</code> will be intact, while the component matrix <code>A</code> of X will be solved by using the forward substitution for \(\mathcal{H}\)-matrices.</p>
<p >This can be further elucidated as: because \(L\vert_{\tau\times\tau}X\vert_{\tau\times\sigma} =
Z\vert_{\tau\times\sigma}\), where \(Z\vert_{\tau\times\sigma}
= AB^T\). Since \(X\) is also a rank-k matrix, let \(X=A&#39;B^T\). Hence, the component matrix \(A&#39;\) of \(X\) can be solved as \(L\vert_{\tau\times\tau}A&#39;=A\).</p>
<p >Merge back the column vector of <code>A'</code> into <code>A'</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node of <code>X</code> or <code>Z</code> does not belong to the leaf set, perform a recursive forward substitution based on the submatrix structure of the current \(\mathcal{H}\)-matrix \(L\).</p>
<p >The number of row blocks and column blocks of \(L\vert_{\tau\times\tau}\) should be the same.</p>
<p >Number of row blocks of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\), which should be the same as the number of row or column blocks of \(L\vert_{\tau\times\tau}\).</p>
<p >Number of column blocks of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\).</p>
<dl class="section note">
<dt>Note</dt>
<dd>N.B. <code>n_row_blocks</code> does not have to be equal to <code>n_col_blocks</code>, since <code>X</code> or <code>Z</code> may be rectangular.</dd>
</dl>
<p >Iterate over each block row of \(L\vert_{\tau\times\tau}\).</p>
<p >Iterate over each child cluster node of the cluster \(\sigma\), i.e. each block column of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\).</p>
<p >Iterate over each block column before the i'th column in \(L\vert_{\tau\times\tau}\).</p>
<p >Go down one level of recursion and solve the current diagonal block matrix \(L\vert_{\tau_i\times\tau_i}\).</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30447">30447</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a17604ea8298c81150980ffd1a65e7249" name="a17604ea8298c81150980ffd1a65e7249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17604ea8298c81150980ffd1a65e7249">&#9670;&nbsp;</a></span>solve_by_forward_substitution_matrix_valued() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the matrix-valued problem \(L\vert_{\tau\times\tau}X\vert_{\tau\times\sigma}=Z\vert_{\tau\times\sigma}\) using forward substitution.</p>
<p >This version is in situ, i.e. the solution is directly saved into \(Z\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >When the current \(\mathcal{H}\)-matrix node of <code>Z</code> is a full matrix, we need to solve a multiple RHS vector problem.</p>
<p >Iterate over each column of <code>Z</code>.</p>
<p >Solve the current lower triangular \(\mathcal{H}\)-matrix \(L\vert_{\tau,\tau}X\vert_{\tau,j}=Z\vert_{\tau,j}\) using the forward substitution for \(\mathcal{H}\)-matrices.</p>
<p >Merge back the solution vector <code>Z_col</code> into <code>Z</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node of <code>X</code> or <code>Z</code> is a rank-k matrix, we iterate over each column of its component matrix <code>A</code> and solve a multiple RHS problem. The resulted solution matrix <code>A'</code> is just the component matrix <code>A</code> of the rank-k matrix <code>X</code>.</p>
<p >Copy the data of the rank-k matrix <code>Z</code> to the rank-k matrix <code>X</code>. The component matrix <code>B</code> of <code>X</code> will be intact, while the component matrix <code>A</code> of X will be solved by using the forward substitution for \(\mathcal{H}\)-matrices.</p>
<p >This can be further elucidated as: because \(L\vert_{\tau\times\tau}X\vert_{\tau\times\sigma} =
Z\vert_{\tau\times\sigma}\), where \(Z\vert_{\tau\times\sigma}
= AB^T\). Since \(X\) is also a rank-k matrix, let \(X=A&#39;B^T\). Hence, the component matrix \(A&#39;\) of \(X\) can be solved as \(L\vert_{\tau\times\tau}A&#39;=A\).</p>
<p >Merge back the column vector of <code>A'</code> into <code>A'</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node of <code>X</code> or <code>Z</code> does not belong to the leaf set, perform a recursive forward substitution based on the submatrix structure of the current \(\mathcal{H}\)-matrix \(L\).</p>
<p >The number of row blocks and column blocks of \(L\vert_{\tau\times\tau}\) should be the same.</p>
<p >Number of row blocks of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\), which should be the same as the number of row or column blocks of \(L\vert_{\tau\times\tau}\).</p>
<p >Number of column blocks of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\).</p>
<p >Iterate over each block row of \(L\vert_{\tau\times\tau}\).</p>
<p >Iterate over each child cluster node of the cluster \(\sigma\), i.e. each block column of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\).</p>
<p >Iterate over each block column before the i'th column in \(L\vert_{\tau\times\tau}\).</p>
<p >Go down one level of recursion and solve the current diagonal block matrix \(L\vert_{\tau_i\times\tau_i}\).</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30612">30612</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ac5582db8445ec15c69bc4bfdda19d547" name="ac5582db8445ec15c69bc4bfdda19d547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5582db8445ec15c69bc4bfdda19d547">&#9670;&nbsp;</a></span>solve_cholesky()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the whole linear system formed by the current \(\mathcal{H}\)-matrix, which should have been applied the Cholesky factorization. The right hand side vector <code>b</code> should be accessed via global indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35409">35409</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a054ad84d52a9ee6df9df3bda0a17cfb7" name="a054ad84d52a9ee6df9df3bda0a17cfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054ad84d52a9ee6df9df3bda0a17cfb7">&#9670;&nbsp;</a></span>solve_cholesky_by_backward_substitution() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve \(L^T x=b\) by backward substitution.</p>
<p >The right hand side vector \(b\) will be overwritten by the solution vector \(x\).</p>
<p ><b>The vector <code>b</code> is <b>global</b>, which can be directly accessed by DoF indices in the cluster's index range.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side vector and after execution, it stores the result vector. </td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be square.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via backward substitution.</p>
<p >Restrict vector <code>b</code> to the <b>row</b> cluster of the current \(\mathcal{H}\)-matrix node, since the actual matrix to be solved is the transposition of the current matrix.</p>
<p >Perform backward substitution for the full matrix, where the transposed matrix is solved. N.B. Since the current lower triangular matrix is obtained from Cholesky factorization, it is not unit diagonal.</p>
<p >Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p >Iterate over each block column of the matrix.</p>
<p >Iterate each row column after the j'th row, i.e. after the diagonal submatrix block.</p>
<p >Since the transpose of the current matrix is to be solved, <code>Tvmult</code> is used here instead of <code>vmult</code>.</p>
<p >Solve the current diagonal block using backward substitution recursively.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l32269">32269</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a26ac0a0f9c4ac7d9383a210ee0165039" name="a26ac0a0f9c4ac7d9383a210ee0165039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ac0a0f9c4ac7d9383a210ee0165039">&#9670;&nbsp;</a></span>solve_cholesky_by_backward_substitution() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve \(L^T x=b\) by backward substitution.</p>
<p >The right hand side vector \(b\) will be overwritten by the solution vector \(x\).</p>
<p ><b>The vector <code>b</code> is <b>local</b>, i.e. associated with a cluster. Therefore, the starting \(\mathcal{H}\)-matrix should be explicitly specified.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">starting_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be square.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via backward substitution.</p>
<p >Restrict vector <code>b</code> to the <b>row</b> cluster of the current \(\mathcal{H}\)-matrix node, since the actual matrix to be solved is the transposition of the current matrix.</p>
<p >Perform backward substitution for the full matrix, where the transposed matrix is solved.</p>
<p >Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p >Iterate over each block column of the matrix.</p>
<p >Iterate each row column after the j'th row, i.e. after the diagonal submatrix block.</p>
<p >Since the transpose of the current matrix is to be solved, <code>Tvmult</code> is used here instead of <code>vmult</code>.</p>
<p >Solve the current diagonal block using backward substitution recursively.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l32369">32369</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a880948492a7df252f3696219f6966703" name="a880948492a7df252f3696219f6966703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880948492a7df252f3696219f6966703">&#9670;&nbsp;</a></span>solve_cholesky_by_backward_substitution() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve \(L^T x=b\) by backward substitution.</p>
<p ><b>The vector <code>b</code> is <b>global</b>, which can be directly accessed by DoF indices in the cluster's index range.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Result vector. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l32358">32358</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a8a92a883d001a278b042db59fa99eef6" name="a8a92a883d001a278b042db59fa99eef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a92a883d001a278b042db59fa99eef6">&#9670;&nbsp;</a></span>solve_cholesky_by_backward_substitution() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve \(L^T x=b\) by backward substitution.</p>
<p ><b>The vector <code>b</code> is <b>local</b>, i.e. associated with a cluster. Therefore, the starting \(\mathcal{H}\)-matrix should be explicitly specified.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">starting_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l32461">32461</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a09beb710b79d47e34ff3283424cf2a22" name="a09beb710b79d47e34ff3283424cf2a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09beb710b79d47e34ff3283424cf2a22">&#9670;&nbsp;</a></span>solve_cholesky_by_forward_substitution() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the lower triangular matrix \(Lx=b\) by forward substitution, where \(L\) is obtained from a Cholesky decomposition. Hence, \(L\) is not normed.</p>
<p >This function directly calls <code>solve_by_forward_substitution</code>(Vector&lt;Number&gt; &amp;b, const bool is_unit_diagonal = false) with <code>is_unit_diagonal</code> being <code>false</code>.</p>
<p ><b>The vector <code>b</code> is <b>global</b>, which can be directly accessed by DoF indices in the cluster's index range.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side vector and after execution, it stores the result vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l31786">31786</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aff8e5445922ed3d1313e87bd795e4f57" name="aff8e5445922ed3d1313e87bd795e4f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8e5445922ed3d1313e87bd795e4f57">&#9670;&nbsp;</a></span>solve_cholesky_by_forward_substitution() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the lower triangular matrix \(Lx=b\) by forward substitution, where \(L\) is obtained from a Cholesky decomposition. Hence, \(L\) is not normed.</p>
<p ><b>The vector <code>b</code> is <b>local</b>, i.e. associated with a cluster.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side vector and after execution, it stores the result vector. </td></tr>
    <tr><td class="paramname">starting_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l31809">31809</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a59d32edbfaac9221dc5e219640c3ecd3" name="a59d32edbfaac9221dc5e219640c3ecd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d32edbfaac9221dc5e219640c3ecd3">&#9670;&nbsp;</a></span>solve_cholesky_by_forward_substitution() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the lower triangular matrix \(Lx=b\) by forward substitution, where \(L\) is obtained from a Cholesky decomposition. Hence, \(L\) is not normed.</p>
<p >This function directly calls <code>void</code> solve_by_forward_substitution(Vector&lt;Number&gt; &amp; x, const Vector&lt;Number&gt; &amp;b, const bool is_unit_diagonal = false) const with <code>is_unit_diagonal</code> being <code>false</code>.</p>
<p ><b>The vector <code>b</code> is <b>global</b>, which can be directly accessed by DoF indices in the cluster's index range.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Solution vector. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l31797">31797</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ac9406e2cb64246b738c0f4e10cd4eef9" name="ac9406e2cb64246b738c0f4e10cd4eef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9406e2cb64246b738c0f4e10cd4eef9">&#9670;&nbsp;</a></span>solve_cholesky_by_forward_substitution() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the lower triangular matrix \(Lx=b\) by forward substitution, where \(L\) is obtained from a Cholesky decomposition. Hence, \(L\) is not normed.</p>
<p ><b>The vector <code>b</code> is <b>local</b>, i.e. associated with a cluster.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">starting_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l31821">31821</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ac8fa863c5b7f78be13dd3cbfd3780b92" name="ac8fa863c5b7f78be13dd3cbfd3780b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fa863c5b7f78be13dd3cbfd3780b92">&#9670;&nbsp;</a></span>solve_cholesky_by_forward_substitution_matrix_valued() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_forward_substitution_matrix_valued </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the matrix-valued problem \(L\vert_{\tau\times\tau}X\vert_{\tau\times\sigma}=Z\vert_{\tau\times\sigma}\) using forward substitution, where \(L\vert_{\tau\times\tau}\) is obtained from a Cholesky decomposition. Hence, \(L\vert_{\tau\times\tau}\) is not normed.</p>
<p >This function directly calls <code>solve_by_forward_substitution_matrix_valued</code>( HMatrix&lt;spacedim, Number&gt; &amp;X, HMatrix&lt;spacedim, Number&gt; &amp;Z, const unsigned int fixed_rank, const bool is_unit_diagonal = false) with <code>is_unit_diagonal</code> being <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td></td></tr>
    <tr><td class="paramname">Z</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30755">30755</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aaeb99ec3f920d4ba9e13d5e6597e26cf" name="aaeb99ec3f920d4ba9e13d5e6597e26cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb99ec3f920d4ba9e13d5e6597e26cf">&#9670;&nbsp;</a></span>solve_cholesky_by_forward_substitution_matrix_valued() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_forward_substitution_matrix_valued </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30766">30766</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ae857d662e39096b416bbcef1a62c67b1" name="ae857d662e39096b416bbcef1a62c67b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae857d662e39096b416bbcef1a62c67b1">&#9670;&nbsp;</a></span>solve_cholesky_transpose_by_forward_substitution_matrix_valued() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the matrix-valued problem \(X\vert_{\tau\times\sigma}U\vert_{\sigma\times\sigma} =
Z\vert_{\tau\times\sigma}\), where the upper triangular \(\mathcal{H}\)-matrix \(U\vert_{\sigma\times\sigma}\) is obtained from a Cholesky factorization, i.e. it is the the transpose of \(L\).</p>
<p >Since only the lower triangular part of a Cholesky factorization is stored or effective, \(U\vert_{\sigma\times\sigma} =
L^T\vert_{\sigma\times\sigma}\). Therefore, a transposed system is solved using forward substitution, i.e. \(U^T\vert_{\sigma\times\sigma}X^T\vert_{\sigma\times\tau} =
L\vert_{\sigma\times\sigma}X^T\vert_{\sigma\times\tau} =
Z^T\vert_{\sigma\times\tau}\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td></td></tr>
    <tr><td class="paramname">Z</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix is \(L\vert_{\sigma\times\sigma}\) and the equation is \(L\vert_{\sigma\times\sigma}X\vert_{\sigma\times\tau}^T =
X\vert_{\sigma\times\tau}^T\), the column dimension of \(L\) should be the same as the column dimension of \(X\).</p>
<p >When the current \(\mathcal{H}\)-matrix node of <code>X</code> or <code>Z</code> is a full matrix, we need to solve a multiple RHS vector problem.</p>
<p >Iterate over each row of <code>X</code> and <code>Z</code>.</p>
<p >Solve the problem \(L\vert_{\sigma\times\sigma}X\vert_{\sigma,i}^{\mathrm{T}} =
Z\vert_{\sigma,i}^{\mathrm{T}}\) using the forward substitution for \(\mathcal{H}\)-matrices, while the lower triangular matrix is not unit, since it is obtained from Cholesky factorization.</p>
<p >Merge back the solution vector <code>X_row</code> into <code>X</code>, while the matrix <code>Z</code> is intact.</p>
<p >Solve the lower triangular \(\mathcal{H}\)-matrix using the forward substitution for \(\mathcal{H}\)-matrices, while the matrix does not have unit diagonal.</p>
<p >Merge back the column vector into the component matrix \(B&#39;\).</p>
<p >When the current \(\mathcal{H}\)-matrix node of <code>X</code> or <code>Z</code> does not belong to the leaf set, perform a recursive forward substitution based on the submatrix structure of the current \(\mathcal{H}\)-matrix \(L\).</p>
<p >The number of row blocks and column blocks of \(L\vert_{\sigma\times\sigma}\) should be the same.</p>
<p >Number of row blocks of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\).</p>
<p >Number of column blocks of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\), which should be the same as the number of row or column blocks of \(L\vert_{\sigma\times\sigma}\).</p>
<dl class="section note">
<dt>Note</dt>
<dd>N.B. <code>n_row_blocks</code> does not have to be equal to <code>n_col_blocks</code>, since <code>X</code> or <code>Z</code> may be rectangular.</dd>
</dl>
<p >Iterate over each block row of \(L\vert_{\sigma\times\sigma}\), which is also each block column of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\).</p>
<p >Iterate over each child cluster node of the cluster \(\tau\), i.e. each block row of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\).</p>
<p >Iterate over each block column before the j'th column in \(L\vert_{\sigma\times\sigma}\).</p>
<p >N.B. Here we are actually computing: </p><p class="formulaDsp">
\[
Z\vert_{\tau[i]\times\sigma[j]} :=
Z\vert_{\tau[i]\times\sigma[j]} -
X\vert_{\tau[i]\times\sigma[k]} \cdot
\left(L\vert_{\sigma[j]\times\sigma[k]}\right)^T \]
</p>
<p >Go down one level of recursion and solve the current diagonal block matrix \(U\vert_{\sigma_i \times
\sigma_i}\).</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l31252">31252</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="aeaa9ccfc3a44cd2b3b6e68845e78d2b4" name="aeaa9ccfc3a44cd2b3b6e68845e78d2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa9ccfc3a44cd2b3b6e68845e78d2b4">&#9670;&nbsp;</a></span>solve_cholesky_transpose_by_forward_substitution_matrix_valued() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The current \(\mathcal{H}\)-matrix is \(L\vert_{\sigma\times\sigma}\) and the equation is \(L\vert_{\sigma\times\sigma}X\vert_{\sigma\times\tau}^T =
Z\vert_{\sigma\times\tau}^T\), the column dimension of \(L\) should be the same as the column dimension of \(Z\).</p>
<p >When the current \(\mathcal{H}\)-matrix node of <code>Z</code> is a full matrix, we need to solve a multiple RHS vector problem.</p>
<p >Iterate over each row of <code>Z</code>.</p>
<p >Solve the problem \(L\vert_{\sigma\times\sigma}X\vert_{\sigma,i} =
Z\vert_{\sigma,i}\) using the forward substitution for \(\mathcal{H}\)-matrices, while the lower triangular matrix is not unit, since it is obtained from Cholesky factorization.</p>
<p >Merge back the solution vector <code>Z_row</code> into <code>Z</code>.</p>
<p >Solve the lower triangular \(\mathcal{H}\)-matrix using the forward substitution for \(\mathcal{H}\)-matrices, while the matrix does not have unit diagonal.</p>
<p >Merge back the column vector into the component matrix \(B\).</p>
<p >When the current \(\mathcal{H}\)-matrix node of <code>Z</code> does not belong to the leaf set, perform a recursive forward substitution based on the submatrix structure of the current \(\mathcal{H}\)-matrix \(L\).</p>
<p >The number of row blocks and column blocks of \(L\vert_{\sigma\times\sigma}\) should be the same.</p>
<p >Number of row blocks of \(Z\vert_{\tau\times\sigma}\).</p>
<p >Number of column blocks of \(Z\vert_{\tau\times\sigma}\), which should be the same as the number of row or column blocks of \(L\vert_{\sigma\times\sigma}\).</p>
<p >Iterate over each block row of \(L\vert_{\sigma\times\sigma}\), which is also each block column of \(Z\vert_{\tau\times\sigma}\).</p>
<p >Iterate over each child cluster node of the cluster \(\tau\), i.e. each block row of \(Z\vert_{\tau\times\sigma}\).</p>
<p >Iterate over each block column before the j'th column in \(L\vert_{\sigma\times\sigma}\).</p>
<p >N.B. Here we are actually computing: </p><p class="formulaDsp">
\[
Z\vert_{\tau[i]\times\sigma[j]} :=
Z\vert_{\tau[i]\times\sigma[j]} -
X\vert_{\tau[i]\times\sigma[k]} \cdot
\left(L\vert_{\sigma[j]\times\sigma[k]}\right)^T \]
</p>
<p >Go down one level of recursion and solve the current diagonal block matrix \(U\vert_{\sigma_i \times
\sigma_i}\).</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l31418">31418</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a83e9dd55091e7eaed11ffb803321c49d" name="a83e9dd55091e7eaed11ffb803321c49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e9dd55091e7eaed11ffb803321c49d">&#9670;&nbsp;</a></span>solve_lu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_lu </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the whole linear system formed by the current \(\mathcal{H}\)-matrix, which should have been applied the LU factorization. The right hand side vector <code>b</code> should be accessed via global indices.</p>
<dl class="section note">
<dt>Note</dt>
<dd>After LU factorization, the obtained <code>L</code> has unit diagonal while <code>U</code> does not.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l35394">35394</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a624fc153099a20572a655457d4f81b70" name="a624fc153099a20572a655457d4f81b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624fc153099a20572a655457d4f81b70">&#9670;&nbsp;</a></span>solve_transpose_by_forward_substitution() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the transpose of an upper triangular matrix \(U^Tx=b\) by forward substitution.</p>
<p >The right hand side vector \(b\) will be overwritten by the solution vector \(x\).</p>
<p ><b>The vector <code>b</code> is <b>global</b>, which can be directly accessed by DoF indices in the cluster's index range.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side vector and after execution, it stores the result vector. </td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be square.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix, whose transpose can be directly solved via forward substitution.</p>
<p >Restrict vector <code>b</code> to the row cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p >Perform forward substitution for the transpose of the full matrix. N.B. The right hand side vector will not be permuted.</p>
<p >Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p >Iterate over each block column of the matrix, which is equivalent to block row of its transpose.</p>
<p >Iterate each block row before the j'th row, i.e. before the diagonal submatrix block.</p>
<p >Solve the current diagonal block using forward substitution recursively.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30776">30776</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a42baae78ace516023e7c6cb79f2ffcdb" name="a42baae78ace516023e7c6cb79f2ffcdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42baae78ace516023e7c6cb79f2ffcdb">&#9670;&nbsp;</a></span>solve_transpose_by_forward_substitution() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the transpose of an upper triangular matrix \(U^Tx=b\) by forward substitution.</p>
<p >The right hand side vector \(b\) will be overwritten by the solution vector \(x\).</p>
<p ><b>The vector <code>b</code> is <b>local</b>, i.e. associated with a cluster. Therefore, the starting \(\mathcal{H}\)-matrix should be explicitly specified.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">starting_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be square.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix, whose transpose can be directly solved via forward substitution.</p>
<p >Restrict vector <code>b</code> to the row cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p >Perform forward substitution for the transpose of the full matrix. N.B. The right hand side vector will not be permuted.</p>
<p >Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p >Iterate over each block column of the matrix, which is equivalent to block row of its transpose.</p>
<p >Iterate each block row before the j'th row, i.e. before the diagonal submatrix block.</p>
<p >Solve the current diagonal block using forward substitution recursively.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30864">30864</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a94f9bb1bc4e584fc5f29541be6b85ef1" name="a94f9bb1bc4e584fc5f29541be6b85ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f9bb1bc4e584fc5f29541be6b85ef1">&#9670;&nbsp;</a></span>solve_transpose_by_forward_substitution() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the transpose of an upper triangular matrix \(U^Tx=b\) by forward substitution.</p>
<p ><b>The vector <code>b</code> is <b>global</b>, which can be directly accessed by DoF indices in the cluster's index range.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Result vector. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30853">30853</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ab0e9f424455af6e874743e5c315c728b" name="ab0e9f424455af6e874743e5c315c728b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e9f424455af6e874743e5c315c728b">&#9670;&nbsp;</a></span>solve_transpose_by_forward_substitution() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the transpose of an upper triangular matrix \(U^Tx=b\) by forward substitution.</p>
<p ><b>The vector <code>b</code> is <b>local</b>, i.e. associated with a cluster. Therefore, the starting \(\mathcal{H}\)-matrix should be explicitly specified.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">starting_hmat</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30948">30948</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a6532f857a821aa6f58087bb2b92b910f" name="a6532f857a821aa6f58087bb2b92b910f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6532f857a821aa6f58087bb2b92b910f">&#9670;&nbsp;</a></span>solve_transpose_by_forward_substitution_matrix_valued() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the matrix-valued problem \(X\vert_{\tau\times\sigma}U\vert_{\sigma\times\sigma} =
Z\vert_{\tau\times\sigma}\).</p>
<p >A transposed system is solved, i.e. \(U^T\vert_{\sigma\times\sigma}X^T\vert_{\sigma\times\tau} =
Z^T\vert_{\sigma\times\tau}\). Then \(U^T\vert_{\sigma\times\sigma}\) is a lower triangular \(\mathcal{H}\)-matrix and a similar procedure as that in the matrix-valued forward substitution can be applied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td></td></tr>
    <tr><td class="paramname">Z</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >When the current \(\mathcal{H}\)-matrix node of <code>X</code> or <code>Z</code> is a full matrix, we need to solve a multiple RHS problem.</p>
<p >Iterate over each row of <code>X</code> and <code>Z</code>.</p>
<p >Solve the problem \(X\vert_{i,\sigma}U\vert_{\sigma\times\sigma} =
Z\vert_{i,\sigma}\) using the transposed forward substitution for \(\mathcal{H}\)-matrices.</p>
<p >Merge back the solution vector <code>X_row</code> into <code>X</code>, while the matrix <code>Z</code> is intact.</p>
<p >Solve the problem using the transposed forward substitution for \(\mathcal{H}\)-matrices.</p>
<p >Merge back the column vector of <code>B'</code> into the component matrix \(B&#39;\) that is contained in the rank-k matrix \(X\vert_{\tau\times\sigma}\).</p>
<p >When the current \(\mathcal{H}\)-matrix node of <code>X</code> or <code>Z</code> does not belong to the leaf set, perform a recursive forward substitution on the transposed matrix \(U^T\), which is based on the submatrix structure of the current \(\mathcal{H}\)-matrix \(U\).</p>
<p >The number of row blocks and column blocks of \(L\vert_{\tau\times\tau}\) should be the same.</p>
<p >Number of row blocks of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\).</p>
<p >Number of column blocks of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\), which should be the same as the number of row or column blocks of \(U\vert_{\sigma\times\sigma}\).</p>
<dl class="section note">
<dt>Note</dt>
<dd>N.B. The number of row and column blocks in \(X\) and \(Z\) should be consistent respectively. But <code>n_row_blocks</code> does not have to be equal to <code>n_col_blocks</code>, since <code>X</code> or <code>Z</code> may be rectangular.</dd>
</dl>
<p >Iterate over each block column of \(U\vert_{\sigma\times\sigma}\), which is equivalent to over each row column of its transpose.</p>
<p >Iterate over each child cluster node of the cluster \(\tau\), i.e. each block row of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\), which is equivalent to iterating over each block column of their transposed matrices.</p>
<p >Iterate over each block row before the j'th row in \(U\vert_{\sigma\times\sigma}\), which is equivalent to over each block column before the j'th column in its transpose.</p>
<p >Go down one level of recursion and solve the current diagonal block matrix \(U\vert_{\sigma_j\times\sigma_j}\).</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l30960">30960</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l04372">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="hmatrix_8h_source.html#l04377">HMatrix&lt; spacedim, Number &gt;::n</a>, and <a class="el" href="hmatrix_8h_source.html#l04252">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a1fbd5d02a1cf3df14dca830bf6118a62" name="a1fbd5d02a1cf3df14dca830bf6118a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbd5d02a1cf3df14dca830bf6118a62">&#9670;&nbsp;</a></span>solve_transpose_by_forward_substitution_matrix_valued() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the matrix-valued problem \(X\vert_{\tau\times\sigma}U\vert_{\sigma\times\sigma} =
Z\vert_{\tau\times\sigma}\).</p>
<p >This version is in situ, i.e. the solution is directly saved into \(Z\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >When the current \(\mathcal{H}\)-matrix node of <code>Z</code> is a full matrix, we need to solve a multiple RHS problem.</p>
<p >Iterate over each row of <code>Z</code>.</p>
<p >Solve the problem \(X\vert_{i,\sigma}U\vert_{\sigma\times\sigma} =
Z\vert_{i,\sigma}\) using the transposed forward substitution for \(\mathcal{H}\)-matrices.</p>
<p >Merge back the solution vector <code>Z_row</code> into <code>Z</code>.</p>
<p >Solve the problem using the transposed forward substitution for \(\mathcal{H}\)-matrices.</p>
<p >Merge back the column vector into the component matrix \(B\).</p>
<p >When the current \(\mathcal{H}\)-matrix node of <code>Z</code> does not belong to the leaf set, perform a recursive forward substitution on the transposed matrix \(U^T\), which is based on the submatrix structure of the current \(\mathcal{H}\)-matrix \(U\).</p>
<p >The number of row blocks and column blocks of \(L\vert_{\tau\times\tau}\) should be the same.</p>
<p >Number of row blocks of \(Z\vert_{\tau\times\sigma}\).</p>
<p >Number of column blocks of \(Z\vert_{\tau\times\sigma}\), which should be the same as the number of row or column blocks of \(U\vert_{\sigma\times\sigma}\).</p>
<p >Iterate over each block column of \(U\vert_{\sigma\times\sigma}\), which is equivalent to over each row column of its transpose.</p>
<p >Iterate over each child cluster node of the cluster \(\tau\), i.e. each block row of \(Z\vert_{\tau\times\sigma}\), which is equivalent to iterating over each block column of their transposed matrices.</p>
<p >Iterate over each block row before the j'th row in \(U\vert_{\sigma\times\sigma}\), which is equivalent to over each block column before the j'th column in its transpose.</p>
<p >Go down one level of recursion and solve the current diagonal block matrix \(U\vert_{\sigma_j\times\sigma_j}\).</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l31119">31119</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ad342f70d049da229a7347b98e2a72d37" name="ad342f70d049da229a7347b98e2a72d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad342f70d049da229a7347b98e2a72d37">&#9670;&nbsp;</a></span>Tmmult_level_conserving() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tmmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Level conserving \(\mathcal{H}\)-matrix multiplication with the first operand being transposed, the result of which will be multiplied by a factor and then appended to the target matrix <code>C</code>, i.e. \(C = C + \alpha \cdot A^T B\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29417">29417</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aff160828042444659db036ae2144a03d" name="aff160828042444659db036ae2144a03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff160828042444659db036ae2144a03d">&#9670;&nbsp;</a></span>Tmmult_level_conserving() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tmmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_result_matrix_store_tril_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Level conserving \(\mathcal{H}\)-matrix multiplication with the first operand being transposed, the result of which will be appended to the target matrix <code>C</code>, i.e. \(C = C + A^T B\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_result_matrix_store_tril_only</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l29404">29404</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l17073">h_h_Tmmult_level_conserving()</a>.</p>

</div>
</div>
<a id="a64be687cacd167efc12b892aa154dcd3" name="a64be687cacd167efc12b892aa154dcd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64be687cacd167efc12b892aa154dcd3">&#9670;&nbsp;</a></span>truncate_to_rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::truncate_to_rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>new_rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Truncate all rank-k matrices in the leaf set of the \(\mathcal{H}\)-matrix to rank-k matrices with the given <code>new_rank</code>, while the full matrices in the leaf set, i.e. those near-field matrices, are kept intact.</p>
<dl class="section note">
<dt>Note </dt>
<dd>This method implements the operator \(\mathcal{T}_{r \leftarrow
s}^{\mathcal{H}}\) in (7.5) in Hackbusch's \(\mathcal{H}\)-matrix book. </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Do nothing.</p>
<p >Truncate the <a class="el" href="classRkMatrix.html">RkMatrix</a> in-place.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l20744">20744</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00070">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a421beeb0b30d63f286a7905db394bdab" name="a421beeb0b30d63f286a7905db394bdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421beeb0b30d63f286a7905db394bdab">&#9670;&nbsp;</a></span>truncate_to_rank_diag_preserve_positive_definite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::truncate_to_rank_diag_preserve_positive_definite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>new_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_only_handle_tril</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Truncate all rank-k matrices in the leaf set of the \(\mathcal{H}\)-matrix to rank-k matrices with the given <code>new_rank</code>, while the full matrices in the leaf set, i.e. those near-field matrices, are kept intact. In this version, the initial \(\mathcal{H}\)-matrix is a diagonal block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >At present, it is prescribed that the block cluster tree should be a quad tree.</p>
<p >Make an assertion that the first and last submatrices of the current \(\mathcal{H}\)-matrix node are really diagonal blocks.</p>
<p >Do nothing.</p>
<p >Rank-k matrix should not appear as a diagonal block.</p>
<p >Do nothing.</p>
<p >Rank-k matrix should not appear as a diagonal block.</p>
<p >The error matrices will be added to the diagonal blocks when handling the bottom left block, i.e. <code>submatrices</code>[2]. So here we do nothing after rank truncation of the rank-k matrix.</p>
<p >Do nothing.</p>
<p >Since the first and last submatrices of the current \(\mathcal{H}\)-matrix node are diagonal blocks, directly add the error matrices into them.</p>
<p >Do nothing.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l20793">20793</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00070">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a88546d9ca48a3c1a2a0874545cc4c8df" name="a88546d9ca48a3c1a2a0874545cc4c8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88546d9ca48a3c1a2a0874545cc4c8df">&#9670;&nbsp;</a></span>truncate_to_rank_off_diag_preserve_positive_definite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::truncate_to_rank_off_diag_preserve_positive_definite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>new_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_compensate_diag_blocks</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Truncate all rank-k matrices in the leaf set of the \(\mathcal{H}\)-matrix to rank-k matrices with the given <code>new_rank</code>, while the full matrices in the leaf set, i.e. those near-field matrices, are kept intact. In this version, the initial \(\mathcal{H}\)-matrix is an off-diagonal block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >At present, it is prescribed that the block cluster tree should be a quad tree.</p>
<p >Handle the four lower triangular blocks.</p>
<p >Do nothing.</p>
<p >Find the diagonal \(\mathcal{H}\)-matrix node having the same column cluster as the current \(\mathcal{H}\)-matrix node.</p>
<p >Find the diagonal \(\mathcal{H}\)-matrix node having the same row cluster as the current \(\mathcal{H}\)-matrix node.</p>
<p >Perform error compensation for preserving the positive definiteness.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l20951">20951</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l30122">HMatrix&lt; spacedim, Number &gt;::addsym_diag()</a>, <a class="el" href="hmatrix_8h_source.html#l20581">HMatrix&lt; spacedim, Number &gt;::find_col_diag_block_for_offdiag_block()</a>, <a class="el" href="hmatrix_8h_source.html#l20419">HMatrix&lt; spacedim, Number &gt;::find_row_diag_block_for_offdiag_block()</a>, <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00070">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a938473855f9e95358d00ee7ea14f6c51" name="a938473855f9e95358d00ee7ea14f6c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938473855f9e95358d00ee7ea14f6c51">&#9670;&nbsp;</a></span>truncate_to_rank_preserve_positive_definite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::truncate_to_rank_preserve_positive_definite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>new_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_only_handle_tril</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Truncate all rank-k matrices in the leaf set of the \(\mathcal{H}\)-matrix to rank-k matrices with the given <code>new_rank</code>, while the full matrices in the leaf set, i.e. those near-field matrices, are kept intact.</p>
<p ><b>The original \(\mathcal{H}\)-matrix is assumed to be symmetric and positive definite (SPD). When rank truncation is performed for far field rank-k matrices, the truncation error matrix components will be added to diagonal blocks according to the stabilization method proposed in Bebendorf, M., and W. Hackbusch. 2007. “Stabilized Rounded Addition of Hierarchical Matrices.” Numerical Linear Algebra with Applications 14 (5): 407–23. <a href="https://doi.org/10.1002/nla.525">https://doi.org/10.1002/nla.525</a>.</b></p>
<dl class="section note">
<dt>Note </dt>
<dd>This method implements the operator \(\mathcal{T}_{r \leftarrow
s}^{\mathcal{H}}\) in (7.5) in Hackbusch's \(\mathcal{H}\)-matrix book. </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_rank</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l20782">20782</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a05bae1198a6f79a4aae86de495795e47" name="a05bae1198a6f79a4aae86de495795e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05bae1198a6f79a4aae86de495795e47">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication \(y= \alpha \cdot
M^{\mathrm{T}} \cdot x\), where different strategies can be selected. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l26113">26113</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a644b2ceec8129d8ed5c162601fef9402" name="a644b2ceec8129d8ed5c162601fef9402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644b2ceec8129d8ed5c162601fef9402">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate \(\mathcal{H}\)-matrix/vector multiplication as \(y = y + \alpha \cdot M^T
\cdot x\) by starting from a block in the matrix and vector. Therefore, the starting \(\mathcal{H}\)-matrix is specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Result vector as a section of the corresponding global vector </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar factor before \(x\) </td></tr>
    <tr><td class="paramname">x</td><td>Input vector as a section of the corresponding global vector </td></tr>
    <tr><td class="paramname">starting_hmat</td><td>Top level \(\mathcal{H}\)-matrix </td></tr>
    <tr><td class="paramname">top_hmat_property</td><td>The \(\mathcal{H}\)-matrix property (of type <code>HMatrixSupport::Property</code>) of the top level \(\mathcal{H}\)-matrix node, which can be <code>general</code>, <code>symmetric</code>, <code>hermite_symmetric</code> and <code>lower_triangular</code> . </td></tr>
  </table>
  </dd>
</dl>
<p >When the current \(\mathcal{H}\)-matrix node is hierarchical, recursively call <code>Tvmult</code> of its children.</p>
<p >Here we comes to the transposed-matrix-vector multiplication with respect to a near field leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is general, perform the transposed-matrix-vector multiplication as usual.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be symmetric, when the top level \(\mathcal{H}\)-matrix node is symmetric.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be symmetric.</p>
<p >Perform the transposed-matrix-vector multiplication using the LAPACK function <code>symv</code> internally. In my implementation, only those lower triangular elements in a symmetric full matrix are used by the function.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(M^Tx\) and then perform the multiplication \(Mx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y_for_vmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, since the upper part is not saved and its contribution has already been considered when we handle the lower triangular block, we do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is Hermite symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be Hermite symmetric, when the top level \(\mathcal{H}\)-matrix node is Hermite symmetric.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be Hermite symmetric.</p>
<p >Perform the transposed-matrix-vector multiplication using the LAPACK function <code>symv</code> internally. In my implementation, only those lower triangular elements in a symmetric full matrix are used by the function.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(M^Tx\) and then perform the multiplication \(Mx\). This treatment considers both the contribution of the current matrix block as well as its Hermite symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y_for_vmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, since the upper part is not saved and its contribution has already been considered when we handle the lower triangular block, we do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is lower triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be lower triangular, when the top level \(\mathcal{H}\)-matrix node is lower triangular.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be lower triangular.</p>
<p >Perform the transposed-matrix-vector multiplication.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we perform the multiplication \(M^Tx\) as that for a general matrix.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, since the upper part is not saved and has no contribution to the result, we do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is upper triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be upper triangular, when the top level \(\mathcal{H}\)-matrix node is upper triangular.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be upper triangular.</p>
<p >Perform the transposed-matrix-vector multiplication.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, we perform the multiplication \(M^Tx\) as that for a general matrix.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we do nothing.</p>
<p >Here we comes to the transposed matrix-vector multiplication with respect to a far field leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is general, perform the transposed matrix-vector multiplication as usual.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(M^Tx\) and then perform the multiplication \(Mx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y_for_vmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is Hermite symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(M^Tx\) and then perform the multiplication \(Mx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y_for_vmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is lower triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we perform the multiplication \(M^Tx\).</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is upper triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, we perform the multiplication \(M^Tx\).</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, do nothing.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l24664">24664</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a3a87e1448e004e1028409aa35e3b2f81" name="a3a87e1448e004e1028409aa35e3b2f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a87e1448e004e1028409aa35e3b2f81">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication as \(y = y + \alpha
\cdot M^T \cdot x\) using the serial recursive mode.</p>
<p >The said <b>serial</b> means the TBB task parallelization is not adopted, but the multithreaded OpenBLAS is still used.</p>
<p >Because the matrix \(M\) is transposed, the roles for <code>row_index_range</code> and <code>col_index_range</code> should be swapped. Also refer to <code><a class="el" href="classHMatrix.html#adbbf34180ab8dc8c09a200b32c636ea9">HMatrix::vmult</a></code>.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The input vector <code>x</code> and result vector <code>y</code> are built with respect to corresponding root cluster nodes and should be directly accessed via <b>global</b> DoF indices.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Result vector </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar factor before \(x\) </td></tr>
    <tr><td class="paramname">x</td><td>Input vector </td></tr>
    <tr><td class="paramname">top_hmat_property</td><td>The \(\mathcal{H}\)-matrix property (of type <code>HMatrixSupport::Property</code>) of the top level \(\mathcal{H}\)-matrix, which can be <code>general</code>, <code>symmetric</code>, <code>hermite_symmetric</code> and <code>lower_triangular</code> . </td></tr>
  </table>
  </dd>
</dl>
<p >When the current \(\mathcal{H}\)-matrix node is hierarchical, recursively call <code>Tvmult</code> of its children.</p>
<p >Here we comes to the transposed-matrix-vector multiplication with respect to a near field leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is general, perform the transposed-matrix-vector multiplication as usual.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be symmetric, when the top level \(\mathcal{H}\)-matrix node is symmetric.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be symmetric.</p>
<p >Perform the transposed-matrix-vector multiplication using the LAPACK function <code>symv</code> internally. In my implementation, only those lower triangular elements in a symmetric full matrix are used by the function.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(M^Tx\) and then perform the multiplication \(Mx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y_for_vmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, since the upper part is not saved and its contribution has already been considered when we handle the lower triangular block, we do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is Hermite symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be Hermite symmetric, when the top level \(\mathcal{H}\)-matrix node is Hermite symmetric.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be Hermite symmetric.</p>
<p >Perform the transposed-matrix-vector multiplication using the LAPACK function <code>hemv</code> internally. In my implementation, only those lower triangular elements in a Hermite symmetric full matrix are used by the function.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(M^Tx\) and then perform the multiplication \(\overline{M}x\). This treatment considers both the contribution of the current matrix block as well as its Hermite symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y_for_vmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, since the upper part is not saved and its contribution has already been considered when we handle the lower triangular block, we do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is lower triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be lower triangular, when the top level \(\mathcal{H}\)-matrix node is lower triangular.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be lower triangular.</p>
<p >Perform the transposed-matrix-vector multiplication.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we perform the multiplication \(M^Tx\) as that for a general matrix.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, since the upper part is not saved and has no contribution to the result, we do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is upper triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be upper triangular, when the top level \(\mathcal{H}\)-matrix node is upper triangular.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be upper triangular.</p>
<p >Perform the transposed-matrix-vector multiplication.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, we perform the multiplication \(M^Tx\) as that for a general matrix.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we do nothing.</p>
<p >Here we comes to the transposed matrix-vector multiplication with respect to a far field leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is general, perform the transposed matrix-vector multiplication as usual.</p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(M^Tx\) and then perform the multiplication \(Mx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y_for_vmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is Hermite symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(M^Tx\) and then perform the multiplication \(Mx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y_for_vmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is lower triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we perform the multiplication \(M^Tx\).</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is upper triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, we perform the multiplication \(M^Tx\).</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, do nothing.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l23677">23677</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a72e5255eb5ce46136d0e2b195c82f016" name="a72e5255eb5ce46136d0e2b195c82f016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e5255eb5ce46136d0e2b195c82f016">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication \(y= M^{\mathrm{T}}
\cdot x\), where different strategies can be selected. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l26084">26084</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a1ac8968a871a1ceea6715cdaad53679b" name="a1ac8968a871a1ceea6715cdaad53679b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac8968a871a1ceea6715cdaad53679b">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate \(\mathcal{H}\)-matrix/vector multiplication as \(y = y + M^T \cdot x\) by starting from a block in the matrix and vector. Therefore, the starting \(\mathcal{H}\)-matrix is specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Result vector as a section of the corresponding global vector </td></tr>
    <tr><td class="paramname">x</td><td>Input vector as a section of the corresponding global vector </td></tr>
    <tr><td class="paramname">starting_hmat</td><td>Top level \(\mathcal{H}\)-matrix </td></tr>
    <tr><td class="paramname">top_hmat_property</td><td>The \(\mathcal{H}\)-matrix property (of type <code>HMatrixSupport::Property</code>) of the top level \(\mathcal{H}\)-matrix node, which can be <code>general</code>, <code>symmetric</code>, <code>hermite_symmetric</code> and <code>lower_triangular</code> . </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l24651">24651</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ab4da3bc44083f7bc4798a019928056dd" name="ab4da3bc44083f7bc4798a019928056dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4da3bc44083f7bc4798a019928056dd">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication as \(y = y + M^T
\cdot x\) using the serial recursive mode.</p>
<p >The said <b>serial</b> means the TBB task parallelization is not adopted, but the multithreaded OpenBLAS is still used.</p>
<p >Because the matrix \(M\) is transposed, the roles for <code>row_index_range</code> and <code>col_index_range</code> should be swapped. Also refer to <code><a class="el" href="classHMatrix.html#adbbf34180ab8dc8c09a200b32c636ea9">HMatrix::vmult</a></code>.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The input vector <code>x</code> and result vector <code>y</code> are built with respect to corresponding root cluster nodes and should be directly accessed via <b>global</b> DoF indices.</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Result vector </td></tr>
    <tr><td class="paramname">x</td><td>Input vector </td></tr>
    <tr><td class="paramname">top_hmat_property</td><td>The \(\mathcal{H}\)-matrix property (of type <code>HMatrixSupport::Property</code>) of the top level \(\mathcal{H}\)-matrix, which can be <code>general</code>, <code>symmetric</code>, <code>hermite_symmetric</code> and <code>lower_triangular</code> . </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l23665">23665</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l11964">f_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l12107">f_h_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11603">h_f_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10751">h_rk_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10959">rk_h_mmult()</a>, and <a class="el" href="hmatrix_8h_source.html#l11273">rk_h_Tmmult()</a>.</p>

</div>
</div>
<a id="a499e785209cdda063fe05a677b0dd083" name="a499e785209cdda063fe05a677b0dd083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499e785209cdda063fe05a677b0dd083">&#9670;&nbsp;</a></span>Tvmult_add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication \(y= y + \alpha \cdot
M^{\mathrm{T}} \cdot x\) with adding, where different strategies can be selected. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l26129">26129</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="af42722bdec9d1af24cc3f4ad03296ce6" name="af42722bdec9d1af24cc3f4ad03296ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42722bdec9d1af24cc3f4ad03296ce6">&#9670;&nbsp;</a></span>Tvmult_add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication \(y= y +
M^{\mathrm{T}} \cdot x\) with adding, where different strategies can be selected. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l26098">26098</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a512208d62ab73b3106789dc26da041eb" name="a512208d62ab73b3106789dc26da041eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512208d62ab73b3106789dc26da041eb">&#9670;&nbsp;</a></span>Tvmult_serial_iterative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 , typename Number3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tvmult_serial_iterative </td>
          <td>(</td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number3&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication as \(y = \beta y +
\alpha \cdot M^T \cdot x\) by iterating over the leaf set.</p>
<p >The TBB task parallelization is not adopted, but the multithreaded OpenBLAS is still used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beta</td><td>Scalar factor before \(y\) </td></tr>
    <tr><td class="paramname">y</td><td>Result vector </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar factor before \(x\) </td></tr>
    <tr><td class="paramname">x</td><td>Input vector </td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be at the top level.</p>
<p >Scale \(y\).</p>
<p >Iterate over each \(\mathcal{H}\)-matrix node in the leaf set.</p>
<p >Restrict the global vector <code>x</code> to the local vector with respect to the transposed matrix block..</p>
<p >Merge back the result vector <code>local_y_for_Tvmult</code> to the global vector <code>y</code>.</p>
<p >Result vector and input vector with respect to the current matrix node.</p>
<p >Restrict the global vector <code>x</code> to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to the global vector <code>y</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l25689">25689</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a20cc513bffdab39bb4ce6e818d23452a" name="a20cc513bffdab39bb4ce6e818d23452a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20cc513bffdab39bb4ce6e818d23452a">&#9670;&nbsp;</a></span>Tvmult_task_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 , typename Number3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tvmult_task_parallel </td>
          <td>(</td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number3&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication as \(y = \beta y +
\alpha \cdot M^T \cdot x\) using TBB task paralellization.</p>
<p >Because the matrix \(M\) is transposed, the roles for <code>row_index_range</code> and <code>col_index_range</code> should be swapped. Also refer to <code><a class="el" href="classHMatrix.html#a8c68f0bc71bc6904b5a5d93ec82262e8">HMatrix::vmult_task_parallel</a></code>.</p>
<dl class="section note">
<dt>Note</dt>
<dd><ol type="1">
<li>The algorithm iterates over each \(\mathcal{H}\)-matrix node in the leaf set.</li>
<li>The input vector <code>x</code> and result vector <code>y</code> are built with respect to corresponding root cluster nodes and should be directly accessed via <b>global</b> DoF indices.</li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beta</td><td>Scalar factor before \(y\) </td></tr>
    <tr><td class="paramname">y</td><td>Result vector </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar factor before \(x\) </td></tr>
    <tr><td class="paramname">x</td><td>Input vector </td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be at the top level.</p>
<p >Only perform parallel multiplication when the thread number is larger than 1. Otherwise, switch to the iterative serial version.</p>
<p >Perform thread local scaling of the result vector and multiplications. The multiplication results are stored locally in each thread.</p>
<p >Local scaling: \(y_q = \beta y_q\).</p>
<p >Clear the local result vector before the multiplication begins.</p>
<p >Iterate over each \(\mathcal{H}\)-matrix node in the interval of the leaf set.</p>
<p >Restrict the global vector <code>x</code> to the local vector.</p>
<p >Merge back the result vector <code>local_y_for_Tvmult</code> obtained from the current leaf set matrix block to the thread local result vector.</p>
<p >Result vector and input vector with respect to the current matrix node.</p>
<p >Restrict the global vector <code>x</code> to the local vector.</p>
<p >Merge back the result vector <code>local_y</code> obtained from the current leaf set matrix node to the thread local result vector.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l25821">25821</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a477c9c01a7ca957b710b978c972cac7c" name="a477c9c01a7ca957b710b978c972cac7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477c9c01a7ca957b710b978c972cac7c">&#9670;&nbsp;</a></span>vmult() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication \(y= \alpha M \cdot
x\), where different strategies can be selected. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l23634">23634</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a0f01d982409cbd87263acf44cdd28944" name="a0f01d982409cbd87263acf44cdd28944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f01d982409cbd87263acf44cdd28944">&#9670;&nbsp;</a></span>vmult() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate \(\mathcal{H}\)-matrix/vector multiplication as \(y = y + \alpha \cdot M
\cdot x\) by starting from a block in the matrix and vector and using the serial recursive mode. Therefore, the starting \(\mathcal{H}\)-matrix should be explicitly specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Result vector as a section of the corresponding global vector </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar factor before \(x\) </td></tr>
    <tr><td class="paramname">x</td><td>Input vector as a section of the corresponding global vector </td></tr>
    <tr><td class="paramname">starting_hmat</td><td>Top level \(\mathcal{H}\)-matrix </td></tr>
    <tr><td class="paramname">top_hmat_property</td><td>The \(\mathcal{H}\)-matrix property (of type <code>HMatrixSupport::Property</code>) of the top level \(\mathcal{H}\)-matrix node, which can be <code>general</code>, <code>symmetric</code>, <code>hermite_symmetric</code> and <code>lower_triangular</code> . </td></tr>
  </table>
  </dd>
</dl>
<p >When the current \(\mathcal{H}\)-matrix node is hierarchical, recursively call <code>vmult</code> of its children.</p>
<p >Here we comes to the matrix-vector multiplication with respect to a near field leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is general, perform the matrix-vector multiplication as usual.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be symmetric, when the top level \(\mathcal{H}\)-matrix node is symmetric.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be symmetric.</p>
<p >Perform the matrix-vector multiplication using the LAPACK function <code>symv</code>. In my implementation, only those lower triangular elements in a symmetric full matrix are used by the function.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(Mx\) and then perform the multiplication \(M^Tx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped when handling \(M^Tx\).</b></p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current transposed matrix block.</p>
<p >Merge back the result vector <code>local_y_for_Tvmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is Hermite symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be Hermite symmetric, when the top level \(\mathcal{H}\)-matrix node is Hermite symmetric.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be Hermite symmetric.</p>
<p >Perform the matrix-vector multiplication using the LAPACK function <code>hemv</code> internally. In my implementation, only those lower triangular elements in a Hermite symmetric full matrix are used by the function.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(Mx\) and then perform the multiplication \(M^Tx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current transposed matrix block.</p>
<p >Merge back the result vector <code>local_y_for_Hvmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is lower triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be lower triangular, when the top level \(\mathcal{H}\)-matrix node is lower triangular.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be lower triangular.</p>
<p >Perform the matrix-vector multiplication using the LAPACK function <code>trmv</code> internally.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we simply perform the multiplication \(Mx\) by treating the current matrix as general.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, we do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is upper triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be upper triangular, when the top level \(\mathcal{H}\)-matrix node is upper triangular.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be upper triangular.</p>
<p >Perform the matrix-vector multiplication using the LAPACK function <code>trmv</code> internally.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we do nothing.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, we simply perform the multiplication \(Mx\) by treating the current matrix as general.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Here we comes to the matrix-vector multiplication with respect to a far field leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is general, perform the matrix-vector multiplication as usual.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(Mx\) and then perform the multiplication \(M^Tx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped when handling \(M^Tx\).</b></p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current transposed matrix block.</p>
<p >Merge back the result vector <code>local_y_for_Tvmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is Hermite symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(Mx\) and then perform the multiplication \(M^Hx\). This treatment considers both the contribution of the current matrix block as well as its Hermite symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be Hermite transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current Hermite transposed matrix block.</p>
<p >Merge back the result vector <code>local_y_for_Hvmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is lower triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A rank-k matrix node can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we simply perform the multiplication \(Mx\) as that for a general matrix.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is upper triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A rank-k matrix node can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, do nothing.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, we simply perform the multiplication \(Mx\) as that for a general matrix.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l22066">22066</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a8232db1cb74fdf791264e8e05a12341b" name="a8232db1cb74fdf791264e8e05a12341b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8232db1cb74fdf791264e8e05a12341b">&#9670;&nbsp;</a></span>vmult() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate \(\mathcal{H}\)-matrix/vector multiplication as \(y = y + \alpha \cdot M \cdot
x\) using the serial recursive mode.</p>
<p >The said <b>serial</b> means the TBB task parallelization is not adopted, but the multithreaded OpenBLAS is still used.</p>
<dl class="section note">
<dt>Note</dt>
<dd><ol type="1">
<li>The recursive algorithm for \(\mathcal{H}\)-matrix/vector multiplication needs to collect the results from different components in the leaf set and corresponding vector block in \(x\). More importantly, there will be a series of such results contributing to a same block in the result vector \(y\). Therefore, if the interface of this function is designed with the parameter <code>add</code> as that in the <code>vmult</code> function of <code>LAPACKFullMatrix</code> in deal.ii, in all recursive calls of <code>vmult</code> except the first one, this <code>add</code> flag should be set to <code>true</code>, irrespective of the original flag value passed into the first call of <code>vmult</code>. Hence, we do not include the <code>add</code> flag in the <code>vmult</code> function.</li>
<li>The input vector <code>x</code> and result vector <code>y</code> are built with respect to corresponding root cluster nodes and should be directly accessed via <b>global</b> DoF indices.</li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Result vector </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar factor before \(x\) </td></tr>
    <tr><td class="paramname">x</td><td>Input vector </td></tr>
    <tr><td class="paramname">top_hmat_property</td><td>The \(\mathcal{H}\)-matrix property (of type <code>HMatrixSupport::Property</code>) of the top level \(\mathcal{H}\)-matrix node, which can be <code>general</code>, <code>symmetric</code>, <code>hermite_symmetric</code> and <code>lower_triangular</code> . </td></tr>
  </table>
  </dd>
</dl>
<p >When the current \(\mathcal{H}\)-matrix node is hierarchical, recursively call <code>vmult</code> of its children.</p>
<p >Here we comes to the matrix-vector multiplication with respect to a near field leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is general, perform the matrix-vector multiplication as usual.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be symmetric, when the top level \(\mathcal{H}\)-matrix node is symmetric.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be symmetric.</p>
<p >Perform the matrix-vector multiplication using the LAPACK function <code>symv</code> internally. In my implementation, only those lower triangular elements in a symmetric full matrix are used by the function.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(Mx\) and then perform the multiplication \(M^Tx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped when handling \(M^Tx\).</b></p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current transposed matrix block.</p>
<p >Merge back the result vector <code>local_y_for_Tvmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is Hermite symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be Hermite symmetric, when the top level \(\mathcal{H}\)-matrix node is Hermite symmetric.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be Hermite symmetric.</p>
<p >Perform the matrix-vector multiplication using the LAPACK function <code>hemv</code> internally. In my implementation, only those lower triangular elements in a Hermite symmetric full matrix are used by the function.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(Mx\) and then perform the multiplication \(M^Hx\). This treatment considers both the contribution of the current matrix block as well as its Hermite symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be Hermite transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current transposed matrix block.</p>
<p >Merge back the result vector <code>local_y_for_Hvmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, since the upper part is not saved and its contribution has already been considered when we handle the lower triangular block, we do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is lower triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be lower triangular, when the top level \(\mathcal{H}\)-matrix node is lower triangular.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be lower triangular.</p>
<p >Perform the matrix-vector multiplication using the LAPACK function <code>trmv</code> internally.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we simply perform the multiplication \(Mx\) by treating the current matrix as general.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, we do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is upper triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A leaf \(\mathcal{H}\)-matrix node belonging to the diagonal block should also be upper triangular, when the top level \(\mathcal{H}\)-matrix node is upper triangular.</p>
<p >The full matrix associated with the current \(\mathcal{H}\)-matrix node should also be upper triangular.</p>
<p >Perform the matrix-vector multiplication using the LAPACK function <code>trmv</code> internally.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we do nothing.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, we simply perform the multiplication \(Mx\) by treating the current matrix as general.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Here we comes to the matrix-vector multiplication with respect to a far field leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is general, perform the matrix-vector multiplication as usual.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(Mx\) and then perform the multiplication \(M^Tx\). This treatment considers both the contribution of the current matrix block as well as its symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be transposed, the roles of row indices and column indices should also be swapped when handling \(M^Tx\).</b></p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current transposed matrix block.</p>
<p >Merge back the result vector <code>local_y_for_Tvmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is Hermite symmetric, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >When the current \(\mathcal{H}\)-matrix node is rank-k matrix, it can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we first perform the multiplication \(Mx\) and then perform the multiplication \(M^Hx\). This treatment considers both the contribution of the current matrix block as well as its Hermite symmetric counterpart.</p>
<p ><b>Not only should the full matrix itself be Hermite transposed, the roles of row indices and column indices should also be swapped.</b></p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >Restrict vector x to the current Hermite transposed matrix block.</p>
<p >Merge back the result vector <code>local_y_for_Hvmult</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is lower triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A rank-k matrix node can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, we simply perform the multiplication \(Mx\) as that for a general matrix.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, do nothing.</p>
<p >When the top level \(\mathcal{H}\)-matrix node is upper triangular, the operation depends on the block type of the current leaf \(\mathcal{H}\)-matrix node.</p>
<p >A rank-k matrix node can never belong to the diagonal part.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the lower triangular part, do nothing.</p>
<p >When the current \(\mathcal{H}\)-matrix node belongs to the upper triangular part, we simply perform the multiplication \(Mx\) as that for a general matrix.</p>
<p >Restrict vector x to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to <code>y</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l21064">21064</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aa11b5761aba86606effd14b4bdf31912" name="aa11b5761aba86606effd14b4bdf31912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11b5761aba86606effd14b4bdf31912">&#9670;&nbsp;</a></span>vmult() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication \(y= M \cdot x\), where different strategies can be selected. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l23605">23605</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a385f2c2bd3344106ca7be36cb07911ab" name="a385f2c2bd3344106ca7be36cb07911ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385f2c2bd3344106ca7be36cb07911ab">&#9670;&nbsp;</a></span>vmult() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate \(\mathcal{H}\)-matrix/vector multiplication as \(y = y + M \cdot x\) by starting from a block in the matrix and vector and using the serial recursive mode. Therefore, the starting \(\mathcal{H}\)-matrix should be explicitly specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Result vector as a section of the corresponding global vector </td></tr>
    <tr><td class="paramname">x</td><td>Input vector as a section of the corresponding global vector </td></tr>
    <tr><td class="paramname">starting_hmat</td><td>Top level \(\mathcal{H}\)-matrix </td></tr>
    <tr><td class="paramname">top_hmat_property</td><td>The \(\mathcal{H}\)-matrix property (of type <code>HMatrixSupport::Property</code>) of the top level \(\mathcal{H}\)-matrix node, which can be <code>general</code>, <code>symmetric</code>, <code>hermite_symmetric</code> and <code>lower_triangular</code> . </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l22053">22053</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="adbbf34180ab8dc8c09a200b32c636ea9" name="adbbf34180ab8dc8c09a200b32c636ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbbf34180ab8dc8c09a200b32c636ea9">&#9670;&nbsp;</a></span>vmult() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a>&#160;</td>
          <td class="paramname"><em>top_hmat_property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate \(\mathcal{H}\)-matrix/vector multiplication as \(y = y + M \cdot x\) using the serial recursive mode.</p>
<p >The said <b>serial</b> means the TBB task parallelization is not adopted, but the multithreaded OpenBLAS is still used.</p>
<dl class="section note">
<dt>Note</dt>
<dd><ol type="1">
<li>The recursive algorithm for \(\mathcal{H}\)-matrix/vector multiplication needs to collect the results from different components in the leaf set and corresponding vector block in \(x\). More importantly, there will be a series of such results contributing to a same block in the result vector \(y\). Therefore, if the interface of this function is designed with the parameter <code>add</code> as that in the <code>vmult</code> function of <code>LAPACKFullMatrix</code> in deal.ii, in all recursive calls of <code>vmult</code> except the first one, this <code>add</code> flag should be set to <code>true</code>, irrespective of the original flag value passed into the first call of <code>vmult</code>. Hence, we do not include the <code>add</code> flag in the <code>vmult</code> function.</li>
<li>The input vector <code>x</code> and result vector <code>y</code> are built with respect to corresponding root cluster nodes and should be directly accessed via <b>global</b> DoF indices.</li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Result vector </td></tr>
    <tr><td class="paramname">x</td><td>Input vector </td></tr>
    <tr><td class="paramname">top_hmat_property</td><td>The \(\mathcal{H}\)-matrix property (of type <code>HMatrixSupport::Property</code>) of the top level \(\mathcal{H}\)-matrix node, which can be <code>general</code>, <code>symmetric</code>, <code>hermite_symmetric</code> and <code>lower_triangular</code> . </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l21052">21052</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l12038">f_h_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11460">h_f_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11532">h_f_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10444">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10601">h_rk_mTmult()</a>, and <a class="el" href="hmatrix_8h_source.html#l11119">rk_h_mTmult()</a>.</p>

</div>
</div>
<a id="aca8292d39103f6ee9fd817121aa2235b" name="aca8292d39103f6ee9fd817121aa2235b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8292d39103f6ee9fd817121aa2235b">&#9670;&nbsp;</a></span>vmult_add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult_add </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication \(y= y + \alpha M
\cdot x\) with adding, where different strategies can be selected. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l23650">23650</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aa3bd65c4b094859f2cab51943387ef07" name="aa3bd65c4b094859f2cab51943387ef07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bd65c4b094859f2cab51943387ef07">&#9670;&nbsp;</a></span>vmult_add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult_add </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication \(y= y + M \cdot x\) with adding, where different strategies can be selected. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l23619">23619</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="afe4ac818aa34c9b7f8311e85871f04a8" name="afe4ac818aa34c9b7f8311e85871f04a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4ac818aa34c9b7f8311e85871f04a8">&#9670;&nbsp;</a></span>vmult_serial_iterative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 , typename Number3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult_serial_iterative </td>
          <td>(</td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number3&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication as \(y = \beta y +
\alpha \cdot M \cdot x\) by iterating over the leaf set.</p>
<p >The TBB task parallelization is not adopted, but the multithreaded OpenBLAS is still used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beta</td><td>Scalar factor before \(y\) </td></tr>
    <tr><td class="paramname">y</td><td>Result vector </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar factor before \(x\) </td></tr>
    <tr><td class="paramname">x</td><td>Input vector </td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be at the top level.</p>
<p >Scale \(y\).</p>
<p >Iterate over each \(\mathcal{H}\)-matrix node in the leaf set.</p>
<p >Result vector and input vector with respect to the current matrix node.</p>
<p >Restrict the global vector <code>x</code> to the current matrix block.</p>
<p >Merge back the result vector <code>local_y</code> to the global vector <code>y</code>.</p>
<p >When the top level \(\mathcal{H}\)-matrix is symmetric and the current leaf \(\mathcal{H}\)-matrix block type is <code>lower_triangular_block</code>, <code>Tvmult</code> should also be performed.</p>
<p >Restrict the global vector <code>x</code> to the local vector with respect to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y_for_Tvmult</code> to the global vector <code>y</code>.</p>
<p >When the top level \(\mathcal{H}\)-matrix is Hermite symmetric and the current leaf \(\mathcal{H}\)-matrix block type is <code>lower_triangular_block</code>, <code>Hvmult</code> should also be performed.</p>
<p >Restrict the global vector <code>x</code> to the local vector with respect to the transposed matrix block.</p>
<p >Merge back the result vector <code>local_y_for_Hvmult</code> to the global vector <code>y</code>.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l23104">23104</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a8c68f0bc71bc6904b5a5d93ec82262e8" name="a8c68f0bc71bc6904b5a5d93ec82262e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c68f0bc71bc6904b5a5d93ec82262e8">&#9670;&nbsp;</a></span>vmult_task_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 , typename Number3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult_task_parallel </td>
          <td>(</td>
          <td class="paramtype">const Number2&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number3&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate the top level \(\mathcal{H}\)-matrix/vector multiplication as \(y = \beta y +
\alpha \cdot M \cdot x\) using TBB task parallelization.</p>
<dl class="section note">
<dt>Note</dt>
<dd><ol type="1">
<li>The algorithm iterates over each \(\mathcal{H}\)-matrix node in the leaf set.</li>
<li>The input vector <code>x</code> and result vector <code>y</code> are built with respect to corresponding root cluster nodes and should be directly accessed via <b>global</b> DoF indices.</li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beta</td><td>Scalar factor before \(y\) </td></tr>
    <tr><td class="paramname">y</td><td>Result vector </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar factor before \(x\) </td></tr>
    <tr><td class="paramname">x</td><td>Input vector </td></tr>
  </table>
  </dd>
</dl>
<p >The current \(\mathcal{H}\)-matrix node should be at the top level.</p>
<p >Only perform parallel multiplication when the thread number is larger than 1. Otherwise, switch to the iterative serial version.</p>
<p >Perform thread local scaling of the result vector and multiplications. The multiplication results are stored locally in each thread.</p>
<p >Local scaling: \(y_q = \beta y_q\).</p>
<p >Clear the local result vector before the multiplication begins.</p>
<p >Iterate over each \(\mathcal{H}\)-matrix node in the interval of the leaf set for local multiplication: \(y_q&#39; = \alpha \sum_i A_{q,i} x\).</p>
<p >Result vector and input vector with respect to the current matrix node.</p>
<p >Restrict the global vector <code>x</code> to the local vector.</p>
<p >Merge back the result vector <code>local_y</code> obtained from the current leaf set matrix node to the thread local result vector.</p>
<p >When the top level \(\mathcal{H}\)-matrix is symmetric and the current leaf \(\mathcal{H}\)-matrix block type is <code>lower_triangular_block</code>, <code>Tvmult</code> should also be performed.</p>
<p >Restrict the global vector <code>x</code> to the local vector.</p>
<p >Merge back the result vector <code>local_y_for_Tvmult</code> obtained from the current leaf set matrix node to the thread local result vector.</p>
<p >When the top level \(\mathcal{H}\)-matrix is Hermite symmetric and the current leaf \(\mathcal{H}\)-matrix block type is <code>lower_triangular_block</code>, <code>Hvmult</code> should also be performed.</p>
<p >Restrict the global vector <code>x</code> to the local vector.</p>
<p >Merge back the result vector <code>local_y_for_Hvmult</code> obtained from the current leaf set matrix node to the thread local result vector.</p>
<p >When the top level \(\mathcal{H}\)-matrix is symmetric or Hermite, also merge the <code>Tvmult</code> or <code>Hvmult</code> results from other threads.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l23286">23286</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="ab9daef657e3ce80c6761c2efdd799b6c" name="ab9daef657e3ce80c6761c2efdd799b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9daef657e3ce80c6761c2efdd799b6c">&#9670;&nbsp;</a></span>write_fullmatrix_leaf_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::write_fullmatrix_leaf_node </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real_type&#160;</td>
          <td class="paramname"><em>singular_value_threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write formatted full matrix leaf node to the output stream.</p>
<p >The leaf node is written in the following format:</p>
<blockquote class="doxtable">
<p >&zwj; </p>
</blockquote>
<p>[list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank</p>
<p >For example,</p>
<blockquote class="doxtable">
<p >&zwj;[1 2 3 ...],[7 8 9 ...],1,1 </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">singular_value_threshold</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Print index range of cluster \(\tau\).</p>
<p >Print index range of cluster \(\sigma\).</p>
<p >Print the <code>is_near_field</code> flag.</p>
<p >Make a copy of the matrix block and calculate its rank using SVD. The state of the matrix should be <code>matrix</code> for further <code>svd</code> operation used in the rank calculation. Therefore, we make a check here and enforce it if necessary.</p>
<p >Print the <code>rank</code> flag.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l20250">20250</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>.</p>

</div>
</div>
<a id="a7c08c982804a0cbfd3210c6be3599ea3" name="a7c08c982804a0cbfd3210c6be3599ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c08c982804a0cbfd3210c6be3599ea3">&#9670;&nbsp;</a></span>write_leaf_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::write_leaf_set </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real_type&#160;</td>
          <td class="paramname"><em>singular_value_threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write formatted leaf set to the output stream as well as the rank of each matrix block by recursion.</p>
<p >Each leaf node is written in the following format:</p>
<blockquote class="doxtable">
<p >&zwj; </p>
</blockquote>
<p>[list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank</p>
<p >For example,</p>
<blockquote class="doxtable">
<p >&zwj;[1 2 3 ...],[7 8 9 ...],1,1 </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">singular_value_threshold</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l20353">20353</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, <a class="el" href="hmatrix_8h_source.html#l00069">HierarchicalMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

</div>
</div>
<a id="a5440e0e6e0c75066f200feaa4ebda40c" name="a5440e0e6e0c75066f200feaa4ebda40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5440e0e6e0c75066f200feaa4ebda40c">&#9670;&nbsp;</a></span>write_leaf_set_by_iteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::write_leaf_set_by_iteration </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real_type&#160;</td>
          <td class="paramname"><em>singular_value_threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write formatted leaf set to the output stream as well as the rank of each matrix block by iteration.</p>
<p >Each leaf node is written in the following format:</p>
<blockquote class="doxtable">
<p >&zwj; </p>
</blockquote>
<p>[list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank</p>
<p >For example,</p>
<blockquote class="doxtable">
<p >&zwj;[1 2 3 ...],[7 8 9 ...],1,1 </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">singular_value_threshold</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l20388">20388</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00067">FullMatrixType</a>, and <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

</div>
</div>
<a id="ac2c8ccd5763d3952505741c657b6468c" name="ac2c8ccd5763d3952505741c657b6468c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c8ccd5763d3952505741c657b6468c">&#9670;&nbsp;</a></span>write_rkmatrix_leaf_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::write_rkmatrix_leaf_node </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write formatted rank-k matrix leaf node to the output stream.</p>
<p >The leaf node is written in the following format:</p>
<blockquote class="doxtable">
<p >&zwj; </p>
</blockquote>
<p>[list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank</p>
<p >For example,</p>
<blockquote class="doxtable">
<p >&zwj;[1 2 3 ...],[7 8 9 ...],1,1 </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
  </table>
  </dd>
</dl>
<p >Print index range of cluster \(\tau\).</p>
<p >Print index range of cluster \(\sigma\).</p>
<p >Print the <code>is_near_field</code> flag.</p>
<p >Print the <code>rank</code> flag.</p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l20310">20310</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">References <a class="el" href="hmatrix_8h_source.html#l00068">RkMatrixType</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acc153ec757cd8fecdeca2274e1ed5a27" name="acc153ec757cd8fecdeca2274e1ed5a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc153ec757cd8fecdeca2274e1ed5a27">&#9670;&nbsp;</a></span>bc_node</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt;spacedim,real_type&gt;::node_pointer_type <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::bc_node</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pointer to the corresponding block cluster node in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree.">BlockClusterTree</a>. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04355">4355</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l34422">HMatrix&lt; spacedim, Number &gt;::cholesky_build_update_to_factorize_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l34463">HMatrix&lt; spacedim, Number &gt;::cholesky_build_update_to_solve_upper_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l33933">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_dag()</a>, <a class="el" href="hmatrix_8h_source.html#l32796">HMatrix&lt; spacedim, Number &gt;::compute_lu_dag()</a>, <a class="el" href="hmatrix_8h_source.html#l10017">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l17421">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l12342">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11894">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l12592">h_h_mmult_from_leaf_node()</a>, <a class="el" href="hmatrix_8h_source.html#l16039">h_h_mmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l28729">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_reduction()</a>, <a class="el" href="hmatrix_8h_source.html#l13910">h_h_mTmult_from_leaf_node()</a>, <a class="el" href="hmatrix_8h_source.html#l16558">h_h_mTmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l15219">h_h_Tmmult_from_leaf_node()</a>, <a class="el" href="hmatrix_8h_source.html#l17073">h_h_Tmmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04621">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h_source.html#l04455">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="hmatrix_8h_source.html#l35664">HMatrix&lt; spacedim, Number &gt;::link_hmat_nodes_on_same_levels()</a>, <a class="el" href="hmatrix_8h_source.html#l33399">HMatrix&lt; spacedim, Number &gt;::lu_build_solve_lower_to_update_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l33439">HMatrix&lt; spacedim, Number &gt;::lu_build_update_to_factorize_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l33475">HMatrix&lt; spacedim, Number &gt;::lu_build_update_to_solve_upper_or_lower_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l33358">HMatrix&lt; spacedim, Number &gt;::lu_or_cholesky_build_solve_upper_to_update_dependencies()</a>, and <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>.</p>

</div>
</div>
<a id="a6d2930c9ef5832e01cc98b3cb03b9a91" name="a6d2930c9ef5832e01cc98b3cb03b9a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2930c9ef5832e01cc98b3cb03b9a91">&#9670;&nbsp;</a></span>block_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hmatrix__support_8h.html#af15801e7429722907d3e51571eece28c">HMatrixSupport::BlockType</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::block_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Block type for the current \(\mathcal{H}\)-matrix node, which can be <code>diagonal_block</code>, <code>upper_triangular_block</code> or <code>lower_triangular_block</code>. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04269">4269</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l33644">HMatrix&lt; spacedim, Number &gt;::_compute_cholesky_factorization()</a>, <a class="el" href="hmatrix_8h_source.html#l34463">HMatrix&lt; spacedim, Number &gt;::cholesky_build_update_to_solve_upper_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l34326">HMatrix&lt; spacedim, Number &gt;::cholesky_solve_upper_task()</a>, <a class="el" href="hmatrix_8h_source.html#l17421">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l20581">HMatrix&lt; spacedim, Number &gt;::find_col_diag_block_for_offdiag_block()</a>, <a class="el" href="hmatrix_8h_source.html#l20419">HMatrix&lt; spacedim, Number &gt;::find_row_diag_block_for_offdiag_block()</a>, <a class="el" href="hmatrix_8h_source.html#l16039">h_h_mmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l16558">h_h_mTmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l17073">h_h_Tmmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04621">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h_source.html#l33475">HMatrix&lt; spacedim, Number &gt;::lu_build_update_to_solve_upper_or_lower_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l33267">HMatrix&lt; spacedim, Number &gt;::lu_solve_lower_task()</a>, <a class="el" href="hmatrix_8h_source.html#l33224">HMatrix&lt; spacedim, Number &gt;::lu_solve_upper_task()</a>, and <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>.</p>

</div>
</div>
<a id="a6fad92358cff261c113af5bd29ac9caf" name="a6fad92358cff261c113af5bd29ac9caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fad92358cff261c113af5bd29ac9caf">&#9670;&nbsp;</a></span>col_index_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;types::global_dof_index, 2&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::col_index_range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pointer to the range of column indices (in internal DoF numbering), which has been stored in the cluster \(\sigma\). It is a subset of \(J\). </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04367">4367</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l18760">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h_source.html#l34422">HMatrix&lt; spacedim, Number &gt;::cholesky_build_update_to_factorize_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l34463">HMatrix&lt; spacedim, Number &gt;::cholesky_build_update_to_solve_upper_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l34326">HMatrix&lt; spacedim, Number &gt;::cholesky_solve_upper_task()</a>, <a class="el" href="hmatrix_8h_source.html#l34370">HMatrix&lt; spacedim, Number &gt;::cholesky_update_task()</a>, <a class="el" href="hmatrix_8h_source.html#l33933">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_dag()</a>, <a class="el" href="hmatrix_8h_source.html#l32796">HMatrix&lt; spacedim, Number &gt;::compute_lu_dag()</a>, <a class="el" href="hmatrix_8h_source.html#l17421">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04621">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h_source.html#l04455">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="hmatrix_8h_source.html#l35747">HMatrix&lt; spacedim, Number &gt;::link_hmat_nodes_on_cross_from_diagonal_blocks()</a>, <a class="el" href="hmatrix_8h_source.html#l33399">HMatrix&lt; spacedim, Number &gt;::lu_build_solve_lower_to_update_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l33439">HMatrix&lt; spacedim, Number &gt;::lu_build_update_to_factorize_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l33475">HMatrix&lt; spacedim, Number &gt;::lu_build_update_to_solve_upper_or_lower_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l33358">HMatrix&lt; spacedim, Number &gt;::lu_or_cholesky_build_solve_upper_to_update_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l33267">HMatrix&lt; spacedim, Number &gt;::lu_solve_lower_task()</a>, <a class="el" href="hmatrix_8h_source.html#l33224">HMatrix&lt; spacedim, Number &gt;::lu_solve_upper_task()</a>, <a class="el" href="hmatrix_8h_source.html#l33309">HMatrix&lt; spacedim, Number &gt;::lu_update_task()</a>, and <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>.</p>

</div>
</div>
<a id="ab828dc70638fae2b3a4343389cbf09cf" name="ab828dc70638fae2b3a4343389cbf09cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab828dc70638fae2b3a4343389cbf09cf">&#9670;&nbsp;</a></span>data_for_vmult_or_tvmult_threads</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;std::vector&lt;<a class="el" href="structHMatrix_1_1VmultOrTvmultThreadData.html">VmultOrTvmultThreadData</a>&gt; &gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::data_for_vmult_or_tvmult_threads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The data for each thread which are used in (transposed) \(\mathcal{H}\)-matrix/vector multiplication.</p>
<p >The reason we wrap it in a <code>unique_ptr</code> is that we want to make the task parallel H-matrix/vector multiplication member functions <code>const</code>, as required by iterative solvers. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04436">4436</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aca26797a5d41fb0fb0a6f1f3b7817870" name="aca26797a5d41fb0fb0a6f1f3b7817870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca26797a5d41fb0fb0a6f1f3b7817870">&#9670;&nbsp;</a></span>dot_node_id</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::dot_node_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Node ID used for generating the directed graph in GraphViz dot. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04279">4279</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l20060">HMatrix&lt; spacedim, Number &gt;::assign_node_ids_for_dot()</a>, and <a class="el" href="hmatrix_8h_source.html#l17474">copy_hmatrix_node()</a>.</p>

</div>
</div>
<a id="a018c8f03c2e151d821067329262b368d" name="a018c8f03c2e151d821067329262b368d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018c8f03c2e151d821067329262b368d">&#9670;&nbsp;</a></span>factorize_lu_or_cholesky_graph_node</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TaskNodePtr <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::factorize_lu_or_cholesky_graph_node</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pointer to the task node for LU factorization of a diagonal \(\mathcal{H}\)-matrix node. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04409">4409</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l34422">HMatrix&lt; spacedim, Number &gt;::cholesky_build_update_to_factorize_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l33933">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_dag()</a>, <a class="el" href="hmatrix_8h_source.html#l35311">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_factorization_task_parallel()</a>, <a class="el" href="hmatrix_8h_source.html#l32796">HMatrix&lt; spacedim, Number &gt;::compute_lu_dag()</a>, <a class="el" href="hmatrix_8h_source.html#l32715">HMatrix&lt; spacedim, Number &gt;::compute_lu_factorization_task_parallel()</a>, and <a class="el" href="hmatrix_8h_source.html#l33439">HMatrix&lt; spacedim, Number &gt;::lu_build_update_to_factorize_dependencies()</a>.</p>

</div>
</div>
<a id="a6df8e2ca7b4d35778bc4e5fcd6f706f1" name="a6df8e2ca7b4d35778bc4e5fcd6f706f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df8e2ca7b4d35778bc4e5fcd6f706f1">&#9670;&nbsp;</a></span>far_field_leaf_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt; *&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::far_field_leaf_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Far field \(\mathcal{H}\)-matrix leaf node set. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04338">4338</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17474">copy_hmatrix_node()</a>.</p>

</div>
</div>
<a id="a328134c9e9cb2c4b05d5431c0ca8a533" name="a328134c9e9cb2c4b05d5431c0ca8a533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328134c9e9cb2c4b05d5431c0ca8a533">&#9670;&nbsp;</a></span>fullmatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt;Number&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::fullmatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pointer to the full matrix. It is not null when the current <a class="el" href="classHMatrix.html">HMatrix</a> object belongs to the near field. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04350">4350</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l33644">HMatrix&lt; spacedim, Number &gt;::_compute_cholesky_factorization()</a>, <a class="el" href="hmatrix_8h_source.html#l32504">HMatrix&lt; spacedim, Number &gt;::_compute_lu_factorization()</a>, <a class="el" href="hmatrix_8h_source.html#l29431">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="hmatrix_8h_source.html#l17421">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l12342">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11894">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l16039">h_h_mmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l12474">h_h_mmult_phase2()</a>, <a class="el" href="hmatrix_8h_source.html#l16558">h_h_mTmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l17073">h_h_Tmmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04621">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, and <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>.</p>

</div>
</div>
<a id="a61dbd471077be0ad8325d0f2afe3d43f" name="a61dbd471077be0ad8325d0f2afe3d43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61dbd471077be0ad8325d0f2afe3d43f">&#9670;&nbsp;</a></span>leaf_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt; *&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::leaf_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >A list of submatrices in the leaf set. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04328">4328</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17474">copy_hmatrix_node()</a>, and <a class="el" href="hmatrix_8h_source.html#l12474">h_h_mmult_phase2()</a>.</p>

</div>
</div>
<a id="aa2f41977cbee7201a4e97ad304f66358" name="aa2f41977cbee7201a4e97ad304f66358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f41977cbee7201a4e97ad304f66358">&#9670;&nbsp;</a></span>leaf_set_traversal_method</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;<a class="el" href="classHMatrix.html#a2b67e35d653ab864ae89c137ea3c8615">::SpaceFillingCurveType</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::leaf_set_traversal_method</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <a class="code hl_class" href="classHMatrix.html">HMatrix&lt;spacedim, Number&gt;::SpaceFillingCurveType::Z</a></div>
</div><!-- fragment --><p >Method used for traversing the leaf set by following a space-filling curve. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04246">4246</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="aa5523463043e4d542eae17d262bd22ad" name="aa5523463043e4d542eae17d262bd22ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5523463043e4d542eae17d262bd22ad">&#9670;&nbsp;</a></span>m</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::m</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Total number of rows in the matrix. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04372">4372</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17421">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l11964">f_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l12342">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l12038">f_h_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l12107">f_h_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11460">h_f_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11894">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11532">h_f_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11603">h_f_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10444">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10890">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10601">h_rk_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10751">h_rk_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04621">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h_source.html#l04455">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="hmatrix_8h_source.html#l10959">rk_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11411">rk_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11119">rk_h_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11273">rk_h_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l30447">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued()</a>, <a class="el" href="hmatrix_8h_source.html#l31253">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued()</a>, and <a class="el" href="hmatrix_8h_source.html#l30961">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued()</a>.</p>

</div>
</div>
<a id="ab5ae2eb472f81f80653ed4411629c2d1" name="ab5ae2eb472f81f80653ed4411629c2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ae2eb472f81f80653ed4411629c2d1">&#9670;&nbsp;</a></span>n</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::n</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Total number of columns in the matrix. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04377">4377</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17421">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l11964">f_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l12342">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l12038">f_h_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l12107">f_h_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11460">h_f_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11894">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11532">h_f_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11603">h_f_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10444">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10890">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10601">h_rk_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l10751">h_rk_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04621">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h_source.html#l04455">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="hmatrix_8h_source.html#l10959">rk_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11411">rk_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11119">rk_h_mTmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11273">rk_h_Tmmult()</a>, <a class="el" href="hmatrix_8h_source.html#l30447">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued()</a>, <a class="el" href="hmatrix_8h_source.html#l31253">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued()</a>, and <a class="el" href="hmatrix_8h_source.html#l30961">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued()</a>.</p>

</div>
</div>
<a id="a6816bb6905d4cce96eacaa1f6593e130" name="a6816bb6905d4cce96eacaa1f6593e130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6816bb6905d4cce96eacaa1f6593e130">&#9670;&nbsp;</a></span>near_field_leaf_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt; *&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::near_field_leaf_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Near field \(\mathcal{H}\)-matrix leaf node set. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04333">4333</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17474">copy_hmatrix_node()</a>.</p>

</div>
</div>
<a id="aa2e832b2b0ba418aed92692535aaa2cc" name="aa2e832b2b0ba418aed92692535aaa2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e832b2b0ba418aed92692535aaa2cc">&#9670;&nbsp;</a></span>next_same_level_hmat_node</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::next_same_level_hmat_node</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pointer to the next \(\mathcal{H}\)-matrix node on a same level. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04294">4294</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l33933">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_dag()</a>, <a class="el" href="hmatrix_8h_source.html#l32796">HMatrix&lt; spacedim, Number &gt;::compute_lu_dag()</a>, <a class="el" href="hmatrix_8h_source.html#l17474">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l35747">HMatrix&lt; spacedim, Number &gt;::link_hmat_nodes_on_cross_from_diagonal_blocks()</a>, and <a class="el" href="hmatrix_8h_source.html#l35664">HMatrix&lt; spacedim, Number &gt;::link_hmat_nodes_on_same_levels()</a>.</p>

</div>
</div>
<a id="abd7a717c26b61c24c0a6347f958edc74" name="abd7a717c26b61c24c0a6347f958edc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7a717c26b61c24c0a6347f958edc74">&#9670;&nbsp;</a></span>next_same_level_same_column_hmat_node</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::next_same_level_same_column_hmat_node</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pointer to the next \(\mathcal{H}\)-matrix node on a same level, which is also in a same column as the same-level diagonal block. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04306">4306</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l33933">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_dag()</a>, <a class="el" href="hmatrix_8h_source.html#l32796">HMatrix&lt; spacedim, Number &gt;::compute_lu_dag()</a>, <a class="el" href="hmatrix_8h_source.html#l17474">copy_hmatrix_node()</a>, and <a class="el" href="hmatrix_8h_source.html#l35747">HMatrix&lt; spacedim, Number &gt;::link_hmat_nodes_on_cross_from_diagonal_blocks()</a>.</p>

</div>
</div>
<a id="a50c0e3b27396d3d9120b2514f94cdb2e" name="a50c0e3b27396d3d9120b2514f94cdb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c0e3b27396d3d9120b2514f94cdb2e">&#9670;&nbsp;</a></span>next_same_level_same_row_hmat_node</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::next_same_level_same_row_hmat_node</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pointer to the next \(\mathcal{H}\)-matrix node on a same level, which is also in a same row as the same-level diagonal block. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04300">4300</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l32796">HMatrix&lt; spacedim, Number &gt;::compute_lu_dag()</a>, <a class="el" href="hmatrix_8h_source.html#l17474">copy_hmatrix_node()</a>, and <a class="el" href="hmatrix_8h_source.html#l35747">HMatrix&lt; spacedim, Number &gt;::link_hmat_nodes_on_cross_from_diagonal_blocks()</a>.</p>

</div>
</div>
<a id="a71690997092a4142799b2fa2dbf53db4" name="a71690997092a4142799b2fa2dbf53db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71690997092a4142799b2fa2dbf53db4">&#9670;&nbsp;</a></span>parent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::parent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pointer to the parent \(\mathcal{H}\)-matrix. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04289">4289</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17518">copy_hmatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l17474">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l20581">HMatrix&lt; spacedim, Number &gt;::find_col_diag_block_for_offdiag_block()</a>, <a class="el" href="hmatrix_8h_source.html#l20419">HMatrix&lt; spacedim, Number &gt;::find_row_diag_block_for_offdiag_block()</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04621">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, and <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>.</p>

</div>
</div>
<a id="a08561fd6dcd930b65fe0f2ffc77bc818" name="a08561fd6dcd930b65fe0f2ffc77bc818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08561fd6dcd930b65fe0f2ffc77bc818">&#9670;&nbsp;</a></span>previous_same_level_same_column_hmat_node</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::previous_same_level_same_column_hmat_node</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pointer to the previous \(\mathcal{H}\)-matrix node on a same level, which is also in a same column as the same-level diagonal block. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04318">4318</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17474">copy_hmatrix_node()</a>, and <a class="el" href="hmatrix_8h_source.html#l35747">HMatrix&lt; spacedim, Number &gt;::link_hmat_nodes_on_cross_from_diagonal_blocks()</a>.</p>

</div>
</div>
<a id="aa18aa785af706bad34c48883ce005c5d" name="aa18aa785af706bad34c48883ce005c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18aa785af706bad34c48883ce005c5d">&#9670;&nbsp;</a></span>previous_same_level_same_row_hmat_node</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::previous_same_level_same_row_hmat_node</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pointer to the previous \(\mathcal{H}\)-matrix node on a same level, which is also in a same row as the same-level diagonal block. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04312">4312</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17474">copy_hmatrix_node()</a>, and <a class="el" href="hmatrix_8h_source.html#l35747">HMatrix&lt; spacedim, Number &gt;::link_hmat_nodes_on_cross_from_diagonal_blocks()</a>.</p>

</div>
</div>
<a id="afef60ed63bd5b247116ce42cbb74e9b4" name="afef60ed63bd5b247116ce42cbb74e9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef60ed63bd5b247116ce42cbb74e9b4">&#9670;&nbsp;</a></span>property</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hmatrix__support_8h.html#a2651831f827cb8204df1771cf48301a2">HMatrixSupport::Property</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::property</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Property of the \(\mathcal{H}\)-matrix, such as <code>general</code>, <code>symmetric</code>, <code>lower_triangular</code>, <code>upper_triangular</code>, etc. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04263">4263</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l33644">HMatrix&lt; spacedim, Number &gt;::_compute_cholesky_factorization()</a>, <a class="el" href="hmatrix_8h_source.html#l17421">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l16039">h_h_mmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l16558">h_h_mTmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l17073">h_h_Tmmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04621">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, and <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>.</p>

</div>
</div>
<a id="aa97a8f5e42aba0f1d5faf41f35a27819" name="aa97a8f5e42aba0f1d5faf41f35a27819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97a8f5e42aba0f1d5faf41f35a27819">&#9670;&nbsp;</a></span>rkmatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt;Number&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::rkmatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pointer to the rank-k matrix. It is not null when the current <a class="el" href="classHMatrix.html">HMatrix</a> object belongs to the far field. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04344">4344</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l29431">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="hmatrix_8h_source.html#l10017">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l17421">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l16039">h_h_mmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l12474">h_h_mmult_phase2()</a>, <a class="el" href="hmatrix_8h_source.html#l16558">h_h_mTmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l17073">h_h_Tmmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l10890">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04621">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>, and <a class="el" href="hmatrix_8h_source.html#l11411">rk_h_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="a6fee69a46f53bb4fd168d6ff1e27a53a" name="a6fee69a46f53bb4fd168d6ff1e27a53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fee69a46f53bb4fd168d6ff1e27a53a">&#9670;&nbsp;</a></span>row_index_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;types::global_dof_index, 2&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::row_index_range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pointer to the range of row indices (in internal DoF numbering), which has been stored in the cluster \(\tau\). It is a subset of \(I\). </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04361">4361</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l18760">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h_source.html#l34422">HMatrix&lt; spacedim, Number &gt;::cholesky_build_update_to_factorize_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l34463">HMatrix&lt; spacedim, Number &gt;::cholesky_build_update_to_solve_upper_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l34326">HMatrix&lt; spacedim, Number &gt;::cholesky_solve_upper_task()</a>, <a class="el" href="hmatrix_8h_source.html#l34370">HMatrix&lt; spacedim, Number &gt;::cholesky_update_task()</a>, <a class="el" href="hmatrix_8h_source.html#l33933">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_dag()</a>, <a class="el" href="hmatrix_8h_source.html#l32796">HMatrix&lt; spacedim, Number &gt;::compute_lu_dag()</a>, <a class="el" href="hmatrix_8h_source.html#l17421">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04621">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h_source.html#l04455">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="hmatrix_8h_source.html#l35747">HMatrix&lt; spacedim, Number &gt;::link_hmat_nodes_on_cross_from_diagonal_blocks()</a>, <a class="el" href="hmatrix_8h_source.html#l33399">HMatrix&lt; spacedim, Number &gt;::lu_build_solve_lower_to_update_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l33439">HMatrix&lt; spacedim, Number &gt;::lu_build_update_to_factorize_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l33475">HMatrix&lt; spacedim, Number &gt;::lu_build_update_to_solve_upper_or_lower_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l33358">HMatrix&lt; spacedim, Number &gt;::lu_or_cholesky_build_solve_upper_to_update_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l33267">HMatrix&lt; spacedim, Number &gt;::lu_solve_lower_task()</a>, <a class="el" href="hmatrix_8h_source.html#l33224">HMatrix&lt; spacedim, Number &gt;::lu_solve_upper_task()</a>, <a class="el" href="hmatrix_8h_source.html#l33309">HMatrix&lt; spacedim, Number &gt;::lu_update_task()</a>, and <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>.</p>

</div>
</div>
<a id="aa659b6df63d533432ec1a24435cd9c40" name="aa659b6df63d533432ec1a24435cd9c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa659b6df63d533432ec1a24435cd9c40">&#9670;&nbsp;</a></span>Sigma_F</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt;Number&gt; *&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Sigma_F</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >List of full matrix pointers used in \(\mathcal{H}\)-matrix multiplication. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04403">4403</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l18760">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h_source.html#l17474">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l12342">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11894">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l12474">h_h_mmult_phase2()</a>, <a class="el" href="hmatrix_8h_source.html#l10890">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04455">InitHMatrixWrtBlockClusterNode()</a>, and <a class="el" href="hmatrix_8h_source.html#l11411">rk_h_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="a3d96d0252ef8c873ae06cf87874acaf3" name="a3d96d0252ef8c873ae06cf87874acaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d96d0252ef8c873ae06cf87874acaf3">&#9670;&nbsp;</a></span>Sigma_P</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt;<a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt; *&gt; &gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Sigma_P</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >List of pairs of pointers to \(\mathcal{H}\)-matrix nodes for multiplication. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04391">4391</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17474">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l12342">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11894">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l12403">h_h_mmult_phase1_recursion()</a>, <a class="el" href="hmatrix_8h_source.html#l12474">h_h_mmult_phase2()</a>, <a class="el" href="hmatrix_8h_source.html#l10890">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04455">InitHMatrixWrtBlockClusterNode()</a>, and <a class="el" href="hmatrix_8h_source.html#l11411">rk_h_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="a04d341b4e606d1be2d71b8ea636efe7b" name="a04d341b4e606d1be2d71b8ea636efe7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d341b4e606d1be2d71b8ea636efe7b">&#9670;&nbsp;</a></span>Sigma_R</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classRkMatrix.html">RkMatrix</a>&lt;Number&gt; *&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Sigma_R</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >List of rank-k matrix pointers used in \(\mathcal{H}\)-matrix multiplication. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04397">4397</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l18760">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h_source.html#l17474">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l12342">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11894">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l12474">h_h_mmult_phase2()</a>, <a class="el" href="hmatrix_8h_source.html#l10890">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04455">InitHMatrixWrtBlockClusterNode()</a>, and <a class="el" href="hmatrix_8h_source.html#l11411">rk_h_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="a4a4d781e9ee655382013b16e3c4943c1" name="a4a4d781e9ee655382013b16e3c4943c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4d781e9ee655382013b16e3c4943c1">&#9670;&nbsp;</a></span>solve_upper_or_lower_lu_or_cholesky_graph_node</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TaskNodePtr <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_upper_or_lower_lu_or_cholesky_graph_node</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pointer to the task node for solving a non-diagonal \(\mathcal{H}\)-matrix node. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04414">4414</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l34463">HMatrix&lt; spacedim, Number &gt;::cholesky_build_update_to_solve_upper_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l34326">HMatrix&lt; spacedim, Number &gt;::cholesky_solve_upper_task()</a>, <a class="el" href="hmatrix_8h_source.html#l33475">HMatrix&lt; spacedim, Number &gt;::lu_build_update_to_solve_upper_or_lower_dependencies()</a>, <a class="el" href="hmatrix_8h_source.html#l33267">HMatrix&lt; spacedim, Number &gt;::lu_solve_lower_task()</a>, and <a class="el" href="hmatrix_8h_source.html#l33224">HMatrix&lt; spacedim, Number &gt;::lu_solve_upper_task()</a>.</p>

</div>
</div>
<a id="ab504bacb27635c8962c8e58eba943e6b" name="ab504bacb27635c8962c8e58eba943e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab504bacb27635c8962c8e58eba943e6b">&#9670;&nbsp;</a></span>state</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hmatrix__support_8h.html#a8358c4882bca00f7e887d9b44e633aa0">HMatrixSupport::State</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >State of the \(\mathcal{H}\)-matrix, such as <code>matrix</code>, <code>lu</code>, <code>cholesky</code>, etc. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04257">4257</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l33644">HMatrix&lt; spacedim, Number &gt;::_compute_cholesky_factorization()</a>, <a class="el" href="hmatrix_8h_source.html#l17421">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04621">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, and <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>.</p>

</div>
</div>
<a id="a4bd1b9a32f2c7693e603a7c6ea916e4f" name="a4bd1b9a32f2c7693e603a7c6ea916e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd1b9a32f2c7693e603a7c6ea916e4f">&#9670;&nbsp;</a></span>submatrices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt; *&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::submatrices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >A list of submatrices of type \(\mathcal{H}\)-matrix. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04284">4284</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l29431">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="hmatrix_8h_source.html#l20060">HMatrix&lt; spacedim, Number &gt;::assign_node_ids_for_dot()</a>, <a class="el" href="hmatrix_8h_source.html#l10017">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l17518">copy_hmatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l17474">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l20581">HMatrix&lt; spacedim, Number &gt;::find_col_diag_block_for_offdiag_block()</a>, <a class="el" href="hmatrix_8h_source.html#l20419">HMatrix&lt; spacedim, Number &gt;::find_row_diag_block_for_offdiag_block()</a>, <a class="el" href="hmatrix_8h_source.html#l35878">HMatrix&lt; spacedim, Number &gt;::get_top_left_leaf_node()</a>, <a class="el" href="hmatrix_8h_source.html#l16039">h_h_mmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l16558">h_h_mTmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l17073">h_h_Tmmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04621">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h_source.html#l35664">HMatrix&lt; spacedim, Number &gt;::link_hmat_nodes_on_same_levels()</a>, and <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>.</p>

</div>
</div>
<a id="a64c851dd63ba1a466c19f451be369475" name="a64c851dd63ba1a466c19f451be369475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c851dd63ba1a466c19f451be369475">&#9670;&nbsp;</a></span>submatrix_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::submatrix_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Submatrix index of the current \(\mathcal{H}\)-matrix node wrt. its parent \(\mathcal{H}\)-matrix node. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04323">4323</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17421">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l20581">HMatrix&lt; spacedim, Number &gt;::find_col_diag_block_for_offdiag_block()</a>, <a class="el" href="hmatrix_8h_source.html#l20419">HMatrix&lt; spacedim, Number &gt;::find_row_diag_block_for_offdiag_block()</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04621">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, and <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>.</p>

</div>
</div>
<a id="a8b5a9fb65c716187d95bcdb43542884c" name="a8b5a9fb65c716187d95bcdb43542884c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5a9fb65c716187d95bcdb43542884c">&#9670;&nbsp;</a></span>submatrix_index_invalid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::submatrix_index_invalid = 9</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Invalid submatrix index of the current \(\mathcal{H}\)-matrix node wrt. its parent \(\mathcal{H}\)-matrix node, which is used for initializing the <code>submatrix_index</code> member variable. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l00911">911</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a7492f731ddeb720c3ff810e07fd64546" name="a7492f731ddeb720c3ff810e07fd64546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7492f731ddeb720c3ff810e07fd64546">&#9670;&nbsp;</a></span>Tind</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt;spacedim, real_type&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tind</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Block cluster tree when this matrix is the product of two \(\mathcal{H}\)-matrices. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04383">4383</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l17474">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l12474">h_h_mmult_phase2()</a>, and <a class="el" href="hmatrix_8h_source.html#l29207">HMatrix&lt; spacedim, Number &gt;::mmult()</a>.</p>

</div>
</div>
<a id="a89ef60f3ba737c04708195ca0bb13620" name="a89ef60f3ba737c04708195ca0bb13620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ef60f3ba737c04708195ca0bb13620">&#9670;&nbsp;</a></span>type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Matrix type, which is one of <code>FullMatrixType</code>, <code>RkMatrixType</code> and <code>HierarchicalMatrixType</code>. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04252">4252</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l10017">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h_source.html#l17421">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h_source.html#l12342">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l11894">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l16039">h_h_mmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l12474">h_h_mmult_phase2()</a>, <a class="el" href="hmatrix_8h_source.html#l28729">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_reduction()</a>, <a class="el" href="hmatrix_8h_source.html#l16558">h_h_mTmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l17073">h_h_Tmmult_level_conserving()</a>, <a class="el" href="hmatrix_8h_source.html#l10890">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l04976">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h_source.html#l04621">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h_source.html#l09483">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="hmatrix_8h_source.html#l11411">rk_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h_source.html#l30447">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued()</a>, <a class="el" href="hmatrix_8h_source.html#l31253">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued()</a>, and <a class="el" href="hmatrix_8h_source.html#l30961">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued()</a>.</p>

</div>
</div>
<a id="a6428e132a07e029b058d838feee19755" name="a6428e132a07e029b058d838feee19755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6428e132a07e029b058d838feee19755">&#9670;&nbsp;</a></span>update_lock</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::update_lock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Lock to prevent simultaneous execution of update tasks on a same \(\mathcal{H}\)-matrix node. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04425">4425</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<a id="a544b5099a50c5e911447382b5a62e651" name="a544b5099a50c5e911447382b5a62e651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544b5099a50c5e911447382b5a62e651">&#9670;&nbsp;</a></span>update_lu_or_cholesky_graph_nodes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classHMatrix_1_1UpdateTaskNodeForLUOrCholesky.html">UpdateTaskNodeForLUOrCholesky</a>&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::update_lu_or_cholesky_graph_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >List of pointers to the task nodes for updating the current \(\mathcal{H}\)-matrix node. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04419">4419</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h_source.html#l33399">HMatrix&lt; spacedim, Number &gt;::lu_build_solve_lower_to_update_dependencies()</a>, and <a class="el" href="hmatrix_8h_source.html#l33358">HMatrix&lt; spacedim, Number &gt;::lu_or_cholesky_build_solve_upper_to_update_dependencies()</a>.</p>

</div>
</div>
<a id="aab1fa017f02f9e961774f31200ab65b8" name="aab1fa017f02f9e961774f31200ab65b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1fa017f02f9e961774f31200ab65b8">&#9670;&nbsp;</a></span>vmult_strategy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classHMatrixVmultStrategy.html">HMatrixVmultStrategy</a>&lt;spacedim, Number&gt; &gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult_strategy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The strategy adopted for <code>vmult</code>, <code>Tvmult</code> and <code>Hvmult</code>. </p>

<p class="definition">Definition at line <a class="el" href="hmatrix_8h_source.html#l04274">4274</a> of file <a class="el" href="hmatrix_8h_source.html">hmatrix.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/hmatrix/<a class="el" href="hmatrix_8h_source.html">hmatrix.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
